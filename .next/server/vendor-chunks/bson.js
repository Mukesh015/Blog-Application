"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bson";
exports.ids = ["vendor-chunks/bson"];
exports.modules = {

/***/ "(ssr)/./node_modules/bson/lib/bson.cjs":
/*!****************************************!*\
  !*** ./node_modules/bson/lib/bson.cjs ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction isAnyArrayBuffer(value) {\n    return [\n        \"[object ArrayBuffer]\",\n        \"[object SharedArrayBuffer]\"\n    ].includes(Object.prototype.toString.call(value));\n}\nfunction isUint8Array(value) {\n    return Object.prototype.toString.call(value) === \"[object Uint8Array]\";\n}\nfunction isRegExp(d) {\n    return Object.prototype.toString.call(d) === \"[object RegExp]\";\n}\nfunction isMap(d) {\n    return Object.prototype.toString.call(d) === \"[object Map]\";\n}\nfunction isDate(d) {\n    return Object.prototype.toString.call(d) === \"[object Date]\";\n}\nfunction defaultInspect(x, _options) {\n    return JSON.stringify(x, (k, v)=>{\n        if (typeof v === \"bigint\") {\n            return {\n                $numberLong: `${v}`\n            };\n        } else if (isMap(v)) {\n            return Object.fromEntries(v);\n        }\n        return v;\n    });\n}\nfunction getStylizeFunction(options) {\n    const stylizeExists = options != null && typeof options === \"object\" && \"stylize\" in options && typeof options.stylize === \"function\";\n    if (stylizeExists) {\n        return options.stylize;\n    }\n}\nconst BSON_MAJOR_VERSION = 6;\nconst BSON_INT32_MAX = 0x7fffffff;\nconst BSON_INT32_MIN = -0x80000000;\nconst BSON_INT64_MAX = Math.pow(2, 63) - 1;\nconst BSON_INT64_MIN = -Math.pow(2, 63);\nconst JS_INT_MAX = Math.pow(2, 53);\nconst JS_INT_MIN = -Math.pow(2, 53);\nconst BSON_DATA_NUMBER = 1;\nconst BSON_DATA_STRING = 2;\nconst BSON_DATA_OBJECT = 3;\nconst BSON_DATA_ARRAY = 4;\nconst BSON_DATA_BINARY = 5;\nconst BSON_DATA_UNDEFINED = 6;\nconst BSON_DATA_OID = 7;\nconst BSON_DATA_BOOLEAN = 8;\nconst BSON_DATA_DATE = 9;\nconst BSON_DATA_NULL = 10;\nconst BSON_DATA_REGEXP = 11;\nconst BSON_DATA_DBPOINTER = 12;\nconst BSON_DATA_CODE = 13;\nconst BSON_DATA_SYMBOL = 14;\nconst BSON_DATA_CODE_W_SCOPE = 15;\nconst BSON_DATA_INT = 16;\nconst BSON_DATA_TIMESTAMP = 17;\nconst BSON_DATA_LONG = 18;\nconst BSON_DATA_DECIMAL128 = 19;\nconst BSON_DATA_MIN_KEY = 0xff;\nconst BSON_DATA_MAX_KEY = 0x7f;\nconst BSON_BINARY_SUBTYPE_DEFAULT = 0;\nconst BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nconst BSONType = Object.freeze({\n    double: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    binData: 5,\n    undefined: 6,\n    objectId: 7,\n    bool: 8,\n    date: 9,\n    null: 10,\n    regex: 11,\n    dbPointer: 12,\n    javascript: 13,\n    symbol: 14,\n    javascriptWithScope: 15,\n    int: 16,\n    timestamp: 17,\n    long: 18,\n    decimal: 19,\n    minKey: -1,\n    maxKey: 127\n});\nclass BSONError extends Error {\n    get bsonError() {\n        return true;\n    }\n    get name() {\n        return \"BSONError\";\n    }\n    constructor(message){\n        super(message);\n    }\n    static isBSONError(value) {\n        return value != null && typeof value === \"object\" && \"bsonError\" in value && value.bsonError === true && \"name\" in value && \"message\" in value && \"stack\" in value;\n    }\n}\nclass BSONVersionError extends BSONError {\n    get name() {\n        return \"BSONVersionError\";\n    }\n    constructor(){\n        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);\n    }\n}\nclass BSONRuntimeError extends BSONError {\n    get name() {\n        return \"BSONRuntimeError\";\n    }\n    constructor(message){\n        super(message);\n    }\n}\nfunction nodejsMathRandomBytes(byteLength) {\n    return nodeJsByteUtils.fromNumberArray(Array.from({\n        length: byteLength\n    }, ()=>Math.floor(Math.random() * 256)));\n}\nconst nodejsRandomBytes = (()=>{\n    try {\n        return (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\n    } catch  {\n        return nodejsMathRandomBytes;\n    }\n})();\nconst nodeJsByteUtils = {\n    toLocalBufferType (potentialBuffer) {\n        if (Buffer.isBuffer(potentialBuffer)) {\n            return potentialBuffer;\n        }\n        if (ArrayBuffer.isView(potentialBuffer)) {\n            return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n        }\n        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);\n        if (stringTag === \"ArrayBuffer\" || stringTag === \"SharedArrayBuffer\" || stringTag === \"[object ArrayBuffer]\" || stringTag === \"[object SharedArrayBuffer]\") {\n            return Buffer.from(potentialBuffer);\n        }\n        throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);\n    },\n    allocate (size) {\n        return Buffer.alloc(size);\n    },\n    equals (a, b) {\n        return nodeJsByteUtils.toLocalBufferType(a).equals(b);\n    },\n    fromNumberArray (array) {\n        return Buffer.from(array);\n    },\n    fromBase64 (base64) {\n        return Buffer.from(base64, \"base64\");\n    },\n    toBase64 (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"base64\");\n    },\n    fromISO88591 (codePoints) {\n        return Buffer.from(codePoints, \"binary\");\n    },\n    toISO88591 (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"binary\");\n    },\n    fromHex (hex) {\n        return Buffer.from(hex, \"hex\");\n    },\n    toHex (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"hex\");\n    },\n    fromUTF8 (text) {\n        return Buffer.from(text, \"utf8\");\n    },\n    toUTF8 (buffer, start, end) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"utf8\", start, end);\n    },\n    utf8ByteLength (input) {\n        return Buffer.byteLength(input, \"utf8\");\n    },\n    encodeUTF8Into (buffer, source, byteOffset) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, \"utf8\");\n    },\n    randomBytes: nodejsRandomBytes\n};\nfunction isReactNative() {\n    const { navigator } = globalThis;\n    return typeof navigator === \"object\" && navigator.product === \"ReactNative\";\n}\nfunction webMathRandomBytes(byteLength) {\n    if (byteLength < 0) {\n        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n    }\n    return webByteUtils.fromNumberArray(Array.from({\n        length: byteLength\n    }, ()=>Math.floor(Math.random() * 256)));\n}\nconst webRandomBytes = (()=>{\n    const { crypto } = globalThis;\n    if (crypto != null && typeof crypto.getRandomValues === \"function\") {\n        return (byteLength)=>{\n            return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n        };\n    } else {\n        if (isReactNative()) {\n            const { console } = globalThis;\n            console?.warn?.(\"BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.\");\n        }\n        return webMathRandomBytes;\n    }\n})();\nconst HEX_DIGIT = /(\\d|[a-f])/i;\nconst webByteUtils = {\n    toLocalBufferType (potentialUint8array) {\n        const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);\n        if (stringTag === \"Uint8Array\") {\n            return potentialUint8array;\n        }\n        if (ArrayBuffer.isView(potentialUint8array)) {\n            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));\n        }\n        if (stringTag === \"ArrayBuffer\" || stringTag === \"SharedArrayBuffer\" || stringTag === \"[object ArrayBuffer]\" || stringTag === \"[object SharedArrayBuffer]\") {\n            return new Uint8Array(potentialUint8array);\n        }\n        throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);\n    },\n    allocate (size) {\n        if (typeof size !== \"number\") {\n            throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n        }\n        return new Uint8Array(size);\n    },\n    equals (a, b) {\n        if (a.byteLength !== b.byteLength) {\n            return false;\n        }\n        for(let i = 0; i < a.byteLength; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    fromNumberArray (array) {\n        return Uint8Array.from(array);\n    },\n    fromBase64 (base64) {\n        return Uint8Array.from(atob(base64), (c)=>c.charCodeAt(0));\n    },\n    toBase64 (uint8array) {\n        return btoa(webByteUtils.toISO88591(uint8array));\n    },\n    fromISO88591 (codePoints) {\n        return Uint8Array.from(codePoints, (c)=>c.charCodeAt(0) & 0xff);\n    },\n    toISO88591 (uint8array) {\n        return Array.from(Uint16Array.from(uint8array), (b)=>String.fromCharCode(b)).join(\"\");\n    },\n    fromHex (hex) {\n        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n        const buffer = [];\n        for(let i = 0; i < evenLengthHex.length; i += 2){\n            const firstDigit = evenLengthHex[i];\n            const secondDigit = evenLengthHex[i + 1];\n            if (!HEX_DIGIT.test(firstDigit)) {\n                break;\n            }\n            if (!HEX_DIGIT.test(secondDigit)) {\n                break;\n            }\n            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n            buffer.push(hexDigit);\n        }\n        return Uint8Array.from(buffer);\n    },\n    toHex (uint8array) {\n        return Array.from(uint8array, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    },\n    fromUTF8 (text) {\n        return new TextEncoder().encode(text);\n    },\n    toUTF8 (uint8array, start, end) {\n        return new TextDecoder(\"utf8\", {\n            fatal: false\n        }).decode(uint8array.slice(start, end));\n    },\n    utf8ByteLength (input) {\n        return webByteUtils.fromUTF8(input).byteLength;\n    },\n    encodeUTF8Into (buffer, source, byteOffset) {\n        const bytes = webByteUtils.fromUTF8(source);\n        buffer.set(bytes, byteOffset);\n        return bytes.byteLength;\n    },\n    randomBytes: webRandomBytes\n};\nconst hasGlobalBuffer = typeof Buffer === \"function\" && Buffer.prototype?._isBuffer !== true;\nconst ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;\nclass BSONDataView extends DataView {\n    static fromUint8Array(input) {\n        return new DataView(input.buffer, input.byteOffset, input.byteLength);\n    }\n}\nclass BSONValue {\n    get [Symbol.for(\"@@mdb.bson.version\")]() {\n        return BSON_MAJOR_VERSION;\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")](depth, options, inspect) {\n        return this.inspect(depth, options, inspect);\n    }\n}\nclass Binary extends BSONValue {\n    get _bsontype() {\n        return \"Binary\";\n    }\n    constructor(buffer, subType){\n        super();\n        if (!(buffer == null) && typeof buffer === \"string\" && !ArrayBuffer.isView(buffer) && !isAnyArrayBuffer(buffer) && !Array.isArray(buffer)) {\n            throw new BSONError(\"Binary can only be constructed from Uint8Array or number[]\");\n        }\n        this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n        if (buffer == null) {\n            this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n            this.position = 0;\n        } else {\n            this.buffer = Array.isArray(buffer) ? ByteUtils.fromNumberArray(buffer) : ByteUtils.toLocalBufferType(buffer);\n            this.position = this.buffer.byteLength;\n        }\n    }\n    put(byteValue) {\n        if (typeof byteValue === \"string\" && byteValue.length !== 1) {\n            throw new BSONError(\"only accepts single character String\");\n        } else if (typeof byteValue !== \"number\" && byteValue.length !== 1) throw new BSONError(\"only accepts single character Uint8Array or Array\");\n        let decodedByte;\n        if (typeof byteValue === \"string\") {\n            decodedByte = byteValue.charCodeAt(0);\n        } else if (typeof byteValue === \"number\") {\n            decodedByte = byteValue;\n        } else {\n            decodedByte = byteValue[0];\n        }\n        if (decodedByte < 0 || decodedByte > 255) {\n            throw new BSONError(\"only accepts number in a valid unsigned byte range 0-255\");\n        }\n        if (this.buffer.byteLength > this.position) {\n            this.buffer[this.position++] = decodedByte;\n        } else {\n            const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n            this.buffer[this.position++] = decodedByte;\n        }\n    }\n    write(sequence, offset) {\n        offset = typeof offset === \"number\" ? offset : this.position;\n        if (this.buffer.byteLength < offset + sequence.length) {\n            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n        }\n        if (ArrayBuffer.isView(sequence)) {\n            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n            this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n        } else if (typeof sequence === \"string\") {\n            throw new BSONError(\"input cannot be string\");\n        }\n    }\n    read(position, length) {\n        length = length && length > 0 ? length : this.position;\n        return this.buffer.slice(position, position + length);\n    }\n    value() {\n        return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);\n    }\n    length() {\n        return this.position;\n    }\n    toJSON() {\n        return ByteUtils.toBase64(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === \"hex\") return ByteUtils.toHex(this.buffer);\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.buffer);\n        if (encoding === \"utf8\" || encoding === \"utf-8\") return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength);\n        return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength);\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        const base64String = ByteUtils.toBase64(this.buffer);\n        const subType = Number(this.sub_type).toString(16);\n        if (options.legacy) {\n            return {\n                $binary: base64String,\n                $type: subType.length === 1 ? \"0\" + subType : subType\n            };\n        }\n        return {\n            $binary: {\n                base64: base64String,\n                subType: subType.length === 1 ? \"0\" + subType : subType\n            }\n        };\n    }\n    toUUID() {\n        if (this.sub_type === Binary.SUBTYPE_UUID) {\n            return new UUID(this.buffer.slice(0, this.position));\n        }\n        throw new BSONError(`Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`);\n    }\n    static createFromHexString(hex, subType) {\n        return new Binary(ByteUtils.fromHex(hex), subType);\n    }\n    static createFromBase64(base64, subType) {\n        return new Binary(ByteUtils.fromBase64(base64), subType);\n    }\n    static fromExtendedJSON(doc, options) {\n        options = options || {};\n        let data;\n        let type;\n        if (\"$binary\" in doc) {\n            if (options.legacy && typeof doc.$binary === \"string\" && \"$type\" in doc) {\n                type = doc.$type ? parseInt(doc.$type, 16) : 0;\n                data = ByteUtils.fromBase64(doc.$binary);\n            } else {\n                if (typeof doc.$binary !== \"string\") {\n                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n                    data = ByteUtils.fromBase64(doc.$binary.base64);\n                }\n            }\n        } else if (\"$uuid\" in doc) {\n            type = 4;\n            data = UUID.bytesFromString(doc.$uuid);\n        }\n        if (!data) {\n            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n        }\n        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        const base64Arg = inspect(base64, options);\n        const subTypeArg = inspect(this.sub_type, options);\n        return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;\n    }\n}\nBinary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\nBinary.BUFFER_SIZE = 256;\nBinary.SUBTYPE_DEFAULT = 0;\nBinary.SUBTYPE_FUNCTION = 1;\nBinary.SUBTYPE_BYTE_ARRAY = 2;\nBinary.SUBTYPE_UUID_OLD = 3;\nBinary.SUBTYPE_UUID = 4;\nBinary.SUBTYPE_MD5 = 5;\nBinary.SUBTYPE_ENCRYPTED = 6;\nBinary.SUBTYPE_COLUMN = 7;\nBinary.SUBTYPE_USER_DEFINED = 128;\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\nclass UUID extends Binary {\n    constructor(input){\n        let bytes;\n        if (input == null) {\n            bytes = UUID.generate();\n        } else if (input instanceof UUID) {\n            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n        } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n            bytes = ByteUtils.toLocalBufferType(input);\n        } else if (typeof input === \"string\") {\n            bytes = UUID.bytesFromString(input);\n        } else {\n            throw new BSONError(\"Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\");\n        }\n        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n    }\n    toHexString(includeDashes = true) {\n        if (includeDashes) {\n            return [\n                ByteUtils.toHex(this.buffer.subarray(0, 4)),\n                ByteUtils.toHex(this.buffer.subarray(4, 6)),\n                ByteUtils.toHex(this.buffer.subarray(6, 8)),\n                ByteUtils.toHex(this.buffer.subarray(8, 10)),\n                ByteUtils.toHex(this.buffer.subarray(10, 16))\n            ].join(\"-\");\n        }\n        return ByteUtils.toHex(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === \"hex\") return ByteUtils.toHex(this.id);\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.id);\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (!otherId) {\n            return false;\n        }\n        if (otherId instanceof UUID) {\n            return ByteUtils.equals(otherId.id, this.id);\n        }\n        try {\n            return ByteUtils.equals(new UUID(otherId).id, this.id);\n        } catch  {\n            return false;\n        }\n    }\n    toBinary() {\n        return new Binary(this.id, Binary.SUBTYPE_UUID);\n    }\n    static generate() {\n        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n        bytes[6] = bytes[6] & 0x0f | 0x40;\n        bytes[8] = bytes[8] & 0x3f | 0x80;\n        return bytes;\n    }\n    static isValid(input) {\n        if (!input) {\n            return false;\n        }\n        if (typeof input === \"string\") {\n            return UUID.isValidUUIDString(input);\n        }\n        if (isUint8Array(input)) {\n            return input.byteLength === UUID_BYTE_LENGTH;\n        }\n        return input._bsontype === \"Binary\" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;\n    }\n    static createFromHexString(hexString) {\n        const buffer = UUID.bytesFromString(hexString);\n        return new UUID(buffer);\n    }\n    static createFromBase64(base64) {\n        return new UUID(ByteUtils.fromBase64(base64));\n    }\n    static bytesFromString(representation) {\n        if (!UUID.isValidUUIDString(representation)) {\n            throw new BSONError(\"UUID string representation must be 32 hex digits or canonical hyphenated representation\");\n        }\n        return ByteUtils.fromHex(representation.replace(/-/g, \"\"));\n    }\n    static isValidUUIDString(representation) {\n        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new UUID(${inspect(this.toHexString(), options)})`;\n    }\n}\nclass Code extends BSONValue {\n    get _bsontype() {\n        return \"Code\";\n    }\n    constructor(code, scope){\n        super();\n        this.code = code.toString();\n        this.scope = scope ?? null;\n    }\n    toJSON() {\n        if (this.scope != null) {\n            return {\n                code: this.code,\n                scope: this.scope\n            };\n        }\n        return {\n            code: this.code\n        };\n    }\n    toExtendedJSON() {\n        if (this.scope) {\n            return {\n                $code: this.code,\n                $scope: this.scope\n            };\n        }\n        return {\n            $code: this.code\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new Code(doc.$code, doc.$scope);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        let parametersString = inspect(this.code, options);\n        const multiLineFn = parametersString.includes(\"\\n\");\n        if (this.scope != null) {\n            parametersString += `,${multiLineFn ? \"\\n\" : \" \"}${inspect(this.scope, options)}`;\n        }\n        const endingNewline = multiLineFn && this.scope === null;\n        return `new Code(${multiLineFn ? \"\\n\" : \"\"}${parametersString}${endingNewline ? \"\\n\" : \"\"})`;\n    }\n}\nfunction isDBRefLike(value) {\n    return value != null && typeof value === \"object\" && \"$id\" in value && value.$id != null && \"$ref\" in value && typeof value.$ref === \"string\" && (!(\"$db\" in value) || \"$db\" in value && typeof value.$db === \"string\");\n}\nclass DBRef extends BSONValue {\n    get _bsontype() {\n        return \"DBRef\";\n    }\n    constructor(collection, oid, db, fields){\n        super();\n        const parts = collection.split(\".\");\n        if (parts.length === 2) {\n            db = parts.shift();\n            collection = parts.shift();\n        }\n        this.collection = collection;\n        this.oid = oid;\n        this.db = db;\n        this.fields = fields || {};\n    }\n    get namespace() {\n        return this.collection;\n    }\n    set namespace(value) {\n        this.collection = value;\n    }\n    toJSON() {\n        const o = Object.assign({\n            $ref: this.collection,\n            $id: this.oid\n        }, this.fields);\n        if (this.db != null) o.$db = this.db;\n        return o;\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        let o = {\n            $ref: this.collection,\n            $id: this.oid\n        };\n        if (options.legacy) {\n            return o;\n        }\n        if (this.db) o.$db = this.db;\n        o = Object.assign(o, this.fields);\n        return o;\n    }\n    static fromExtendedJSON(doc) {\n        const copy = Object.assign({}, doc);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const args = [\n            inspect(this.namespace, options),\n            inspect(this.oid, options),\n            ...this.db ? [\n                inspect(this.db, options)\n            ] : [],\n            ...Object.keys(this.fields).length > 0 ? [\n                inspect(this.fields, options)\n            ] : []\n        ];\n        args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];\n        return `new DBRef(${args.join(\", \")})`;\n    }\n}\nlet wasm = undefined;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        13,\n        2,\n        96,\n        0,\n        1,\n        127,\n        96,\n        4,\n        127,\n        127,\n        127,\n        127,\n        1,\n        127,\n        3,\n        7,\n        6,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        6,\n        6,\n        1,\n        127,\n        1,\n        65,\n        0,\n        11,\n        7,\n        50,\n        6,\n        3,\n        109,\n        117,\n        108,\n        0,\n        1,\n        5,\n        100,\n        105,\n        118,\n        95,\n        115,\n        0,\n        2,\n        5,\n        100,\n        105,\n        118,\n        95,\n        117,\n        0,\n        3,\n        5,\n        114,\n        101,\n        109,\n        95,\n        115,\n        0,\n        4,\n        5,\n        114,\n        101,\n        109,\n        95,\n        117,\n        0,\n        5,\n        8,\n        103,\n        101,\n        116,\n        95,\n        104,\n        105,\n        103,\n        104,\n        0,\n        0,\n        10,\n        191,\n        1,\n        6,\n        4,\n        0,\n        35,\n        0,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        126,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        127,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        128,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        129,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        130,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11\n    ])), {}).exports;\n} catch  {}\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst INT_CACHE = {};\nconst UINT_CACHE = {};\nconst MAX_INT64_STRING_LENGTH = 20;\nconst DECIMAL_REG_EX = /^(\\+?0|(\\+|-)?[1-9][0-9]*)$/;\nclass Long extends BSONValue {\n    get _bsontype() {\n        return \"Long\";\n    }\n    get __isLong__() {\n        return true;\n    }\n    constructor(low = 0, high, unsigned){\n        super();\n        if (typeof low === \"bigint\") {\n            Object.assign(this, Long.fromBigInt(low, !!high));\n        } else if (typeof low === \"string\") {\n            Object.assign(this, Long.fromString(low, !!high));\n        } else {\n            this.low = low | 0;\n            this.high = high | 0;\n            this.unsigned = !!unsigned;\n        }\n    }\n    static fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    static fromInt(value, unsigned) {\n        let obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if (cache = 0 <= value && value < 256) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n            if (cache) UINT_CACHE[value] = obj;\n            return obj;\n        } else {\n            value |= 0;\n            if (cache = -128 <= value && value < 128) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache) INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    static fromNumber(value, unsigned) {\n        if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO;\n        if (unsigned) {\n            if (value < 0) return Long.UZERO;\n            if (value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE;\n        } else {\n            if (value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE;\n        }\n        if (value < 0) return Long.fromNumber(-value, unsigned).neg();\n        return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    static fromBigInt(value, unsigned) {\n        return Long.fromString(value.toString(), unsigned);\n    }\n    static fromString(str, unsigned, radix) {\n        if (str.length === 0) throw new BSONError(\"empty string\");\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return Long.ZERO;\n        if (typeof unsigned === \"number\") {\n            radix = unsigned, unsigned = false;\n        } else {\n            unsigned = !!unsigned;\n        }\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw new BSONError(\"radix\");\n        let p;\n        if ((p = str.indexOf(\"-\")) > 0) throw new BSONError(\"interior hyphen\");\n        else if (p === 0) {\n            return Long.fromString(str.substring(1), unsigned, radix).neg();\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n        let result = Long.ZERO;\n        for(let i = 0; i < str.length; i += 8){\n            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                const power = Long.fromNumber(Math.pow(radix, size));\n                result = result.mul(power).add(Long.fromNumber(value));\n            } else {\n                result = result.mul(radixToPower);\n                result = result.add(Long.fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    static fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    }\n    static fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    }\n    static fromBytesBE(bytes, unsigned) {\n        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    }\n    static isLong(value) {\n        return value != null && typeof value === \"object\" && \"__isLong__\" in value && value.__isLong__ === true;\n    }\n    static fromValue(val, unsigned) {\n        if (typeof val === \"number\") return Long.fromNumber(val, unsigned);\n        if (typeof val === \"string\") return Long.fromString(val, unsigned);\n        return Long.fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    add(addend) {\n        if (!Long.isLong(addend)) addend = Long.fromValue(addend);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = addend.high >>> 16;\n        const b32 = addend.high & 0xffff;\n        const b16 = addend.low >>> 16;\n        const b00 = addend.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }\n    and(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    }\n    compare(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.eq(other)) return 0;\n        const thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg) return -1;\n        if (!thisNeg && otherNeg) return 1;\n        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    }\n    comp(other) {\n        return this.compare(other);\n    }\n    divide(divisor) {\n        if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n        if (divisor.isZero()) throw new BSONError(\"division by zero\");\n        if (wasm) {\n            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n                return this;\n            }\n            const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;\n        let approx, rem, res;\n        if (!this.unsigned) {\n            if (this.eq(Long.MIN_VALUE)) {\n                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE;\n                else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE;\n                else {\n                    const halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(Long.ZERO)) {\n                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n                    } else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            } else if (divisor.eq(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n            res = Long.ZERO;\n        } else {\n            if (!divisor.unsigned) divisor = divisor.toUnsigned();\n            if (divisor.gt(this)) return Long.UZERO;\n            if (divisor.gt(this.shru(1))) return Long.UONE;\n            res = Long.UZERO;\n        }\n        rem = this;\n        while(rem.gte(divisor)){\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            const log2 = Math.ceil(Math.log(approx) / Math.LN2);\n            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            let approxRes = Long.fromNumber(approx);\n            let approxRem = approxRes.mul(divisor);\n            while(approxRem.isNegative() || approxRem.gt(rem)){\n                approx -= delta;\n                approxRes = Long.fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            if (approxRes.isZero()) approxRes = Long.ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    }\n    div(divisor) {\n        return this.divide(divisor);\n    }\n    equals(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    }\n    eq(other) {\n        return this.equals(other);\n    }\n    getHighBits() {\n        return this.high;\n    }\n    getHighBitsUnsigned() {\n        return this.high >>> 0;\n    }\n    getLowBits() {\n        return this.low;\n    }\n    getLowBitsUnsigned() {\n        return this.low >>> 0;\n    }\n    getNumBitsAbs() {\n        if (this.isNegative()) {\n            return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        }\n        const val = this.high !== 0 ? this.high : this.low;\n        let bit;\n        for(bit = 31; bit > 0; bit--)if ((val & 1 << bit) !== 0) break;\n        return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    greaterThan(other) {\n        return this.comp(other) > 0;\n    }\n    gt(other) {\n        return this.greaterThan(other);\n    }\n    greaterThanOrEqual(other) {\n        return this.comp(other) >= 0;\n    }\n    gte(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    ge(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    isEven() {\n        return (this.low & 1) === 0;\n    }\n    isNegative() {\n        return !this.unsigned && this.high < 0;\n    }\n    isOdd() {\n        return (this.low & 1) === 1;\n    }\n    isPositive() {\n        return this.unsigned || this.high >= 0;\n    }\n    isZero() {\n        return this.high === 0 && this.low === 0;\n    }\n    lessThan(other) {\n        return this.comp(other) < 0;\n    }\n    lt(other) {\n        return this.lessThan(other);\n    }\n    lessThanOrEqual(other) {\n        return this.comp(other) <= 0;\n    }\n    lte(other) {\n        return this.lessThanOrEqual(other);\n    }\n    modulo(divisor) {\n        if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n        if (wasm) {\n            const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    }\n    mod(divisor) {\n        return this.modulo(divisor);\n    }\n    rem(divisor) {\n        return this.modulo(divisor);\n    }\n    multiply(multiplier) {\n        if (this.isZero()) return Long.ZERO;\n        if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier);\n        if (wasm) {\n            const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (multiplier.isZero()) return Long.ZERO;\n        if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n            else return this.neg().mul(multiplier).neg();\n        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n        if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = multiplier.high >>> 16;\n        const b32 = multiplier.high & 0xffff;\n        const b16 = multiplier.low >>> 16;\n        const b00 = multiplier.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }\n    mul(multiplier) {\n        return this.multiply(multiplier);\n    }\n    negate() {\n        if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE;\n        return this.not().add(Long.ONE);\n    }\n    neg() {\n        return this.negate();\n    }\n    not() {\n        return Long.fromBits(~this.low, ~this.high, this.unsigned);\n    }\n    notEquals(other) {\n        return !this.equals(other);\n    }\n    neq(other) {\n        return this.notEquals(other);\n    }\n    ne(other) {\n        return this.notEquals(other);\n    }\n    or(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    }\n    shiftLeft(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n        else return Long.fromBits(0, this.low << numBits - 32, this.unsigned);\n    }\n    shl(numBits) {\n        return this.shiftLeft(numBits);\n    }\n    shiftRight(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n        else return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    }\n    shr(numBits) {\n        return this.shiftRight(numBits);\n    }\n    shiftRightUnsigned(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        numBits &= 63;\n        if (numBits === 0) return this;\n        else {\n            const high = this.high;\n            if (numBits < 32) {\n                const low = this.low;\n                return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n            } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned);\n            else return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);\n        }\n    }\n    shr_u(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    shru(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    subtract(subtrahend) {\n        if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    }\n    sub(subtrahend) {\n        return this.subtract(subtrahend);\n    }\n    toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    }\n    toNumber() {\n        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    }\n    toBytesLE() {\n        const hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            lo >>> 8 & 0xff,\n            lo >>> 16 & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            hi >>> 8 & 0xff,\n            hi >>> 16 & 0xff,\n            hi >>> 24\n        ];\n    }\n    toBytesBE() {\n        const hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            hi >>> 16 & 0xff,\n            hi >>> 8 & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            lo >>> 16 & 0xff,\n            lo >>> 8 & 0xff,\n            lo & 0xff\n        ];\n    }\n    toSigned() {\n        if (!this.unsigned) return this;\n        return Long.fromBits(this.low, this.high, false);\n    }\n    toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw new BSONError(\"radix\");\n        if (this.isZero()) return \"0\";\n        if (this.isNegative()) {\n            if (this.eq(Long.MIN_VALUE)) {\n                const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            } else return \"-\" + this.neg().toString(radix);\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n        let rem = this;\n        let result = \"\";\n        while(true){\n            const remDiv = rem.div(radixToPower);\n            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n            let digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) {\n                return digits + result;\n            } else {\n                while(digits.length < 6)digits = \"0\" + digits;\n                result = \"\" + digits + result;\n            }\n        }\n    }\n    toUnsigned() {\n        if (this.unsigned) return this;\n        return Long.fromBits(this.low, this.high, true);\n    }\n    xor(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    }\n    eqz() {\n        return this.isZero();\n    }\n    le(other) {\n        return this.lessThanOrEqual(other);\n    }\n    toExtendedJSON(options) {\n        if (options && options.relaxed) return this.toNumber();\n        return {\n            $numberLong: this.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const { useBigInt64 = false, relaxed = true } = {\n            ...options\n        };\n        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {\n            throw new BSONError(\"$numberLong string is too long\");\n        }\n        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {\n            throw new BSONError(`$numberLong string \"${doc.$numberLong}\" is in an invalid format`);\n        }\n        if (useBigInt64) {\n            const bigIntResult = BigInt(doc.$numberLong);\n            return BigInt.asIntN(64, bigIntResult);\n        }\n        const longResult = Long.fromString(doc.$numberLong);\n        if (relaxed) {\n            return longResult.toNumber();\n        }\n        return longResult;\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const longVal = inspect(this.toString(), options);\n        const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : \"\";\n        return `new Long(${longVal}${unsignedVal})`;\n    }\n}\nLong.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\nLong.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\nLong.ZERO = Long.fromInt(0);\nLong.UZERO = Long.fromInt(0, true);\nLong.ONE = Long.fromInt(1);\nLong.UONE = Long.fromInt(1, true);\nLong.NEG_ONE = Long.fromInt(-1);\nLong.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\nLong.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nconst EXPONENT_MAX = 6111;\nconst EXPONENT_MIN = -6176;\nconst EXPONENT_BIAS = 6176;\nconst MAX_DIGITS = 34;\nconst NAN_BUFFER = ByteUtils.fromNumberArray([\n    0x7c,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([\n    0xf8,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([\n    0x78,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nconst COMBINATION_MASK = 0x1f;\nconst EXPONENT_MASK = 0x3fff;\nconst COMBINATION_INFINITY = 30;\nconst COMBINATION_NAN = 31;\nfunction isDigit(value) {\n    return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\n    let _rem = Long.fromNumber(0);\n    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n        return {\n            quotient: value,\n            rem: _rem\n        };\n    }\n    for(let i = 0; i <= 3; i++){\n        _rem = _rem.shiftLeft(32);\n        _rem = _rem.add(new Long(value.parts[i], 0));\n        value.parts[i] = _rem.div(DIVISOR).low;\n        _rem = _rem.modulo(DIVISOR);\n    }\n    return {\n        quotient: value,\n        rem: _rem\n    };\n}\nfunction multiply64x2(left, right) {\n    if (!left && !right) {\n        return {\n            high: Long.fromNumber(0),\n            low: Long.fromNumber(0)\n        };\n    }\n    const leftHigh = left.shiftRightUnsigned(32);\n    const leftLow = new Long(left.getLowBits(), 0);\n    const rightHigh = right.shiftRightUnsigned(32);\n    const rightLow = new Long(right.getLowBits(), 0);\n    let productHigh = leftHigh.multiply(rightHigh);\n    let productMid = leftHigh.multiply(rightLow);\n    const productMid2 = leftLow.multiply(rightHigh);\n    let productLow = leftLow.multiply(rightLow);\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n    return {\n        high: productHigh,\n        low: productLow\n    };\n}\nfunction lessThan(left, right) {\n    const uhleft = left.high >>> 0;\n    const uhright = right.high >>> 0;\n    if (uhleft < uhright) {\n        return true;\n    } else if (uhleft === uhright) {\n        const ulleft = left.low >>> 0;\n        const ulright = right.low >>> 0;\n        if (ulleft < ulright) return true;\n    }\n    return false;\n}\nfunction invalidErr(string, message) {\n    throw new BSONError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\n}\nclass Decimal128 extends BSONValue {\n    get _bsontype() {\n        return \"Decimal128\";\n    }\n    constructor(bytes){\n        super();\n        if (typeof bytes === \"string\") {\n            this.bytes = Decimal128.fromString(bytes).bytes;\n        } else if (isUint8Array(bytes)) {\n            if (bytes.byteLength !== 16) {\n                throw new BSONError(\"Decimal128 must take a Buffer of 16 bytes\");\n            }\n            this.bytes = bytes;\n        } else {\n            throw new BSONError(\"Decimal128 must take a Buffer or string\");\n        }\n    }\n    static fromString(representation) {\n        return Decimal128._fromString(representation, {\n            allowRounding: false\n        });\n    }\n    static fromStringWithRounding(representation) {\n        return Decimal128._fromString(representation, {\n            allowRounding: true\n        });\n    }\n    static _fromString(representation, options) {\n        let isNegative = false;\n        let sawSign = false;\n        let sawRadix = false;\n        let foundNonZero = false;\n        let significantDigits = 0;\n        let nDigitsRead = 0;\n        let nDigits = 0;\n        let radixPosition = 0;\n        let firstNonZero = 0;\n        const digits = [\n            0\n        ];\n        let nDigitsStored = 0;\n        let digitsInsert = 0;\n        let lastDigit = 0;\n        let exponent = 0;\n        let significandHigh = new Long(0, 0);\n        let significandLow = new Long(0, 0);\n        let biasedExponent = 0;\n        let index = 0;\n        if (representation.length >= 7000) {\n            throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        }\n        const stringMatch = representation.match(PARSE_STRING_REGEXP);\n        const infMatch = representation.match(PARSE_INF_REGEXP);\n        const nanMatch = representation.match(PARSE_NAN_REGEXP);\n        if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {\n            throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        }\n        if (stringMatch) {\n            const unsignedNumber = stringMatch[2];\n            const e = stringMatch[4];\n            const expSign = stringMatch[5];\n            const expNumber = stringMatch[6];\n            if (e && expNumber === undefined) invalidErr(representation, \"missing exponent power\");\n            if (e && unsignedNumber === undefined) invalidErr(representation, \"missing exponent base\");\n            if (e === undefined && (expSign || expNumber)) {\n                invalidErr(representation, \"missing e before exponent\");\n            }\n        }\n        if (representation[index] === \"+\" || representation[index] === \"-\") {\n            sawSign = true;\n            isNegative = representation[index++] === \"-\";\n        }\n        if (!isDigit(representation[index]) && representation[index] !== \".\") {\n            if (representation[index] === \"i\" || representation[index] === \"I\") {\n                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n            } else if (representation[index] === \"N\") {\n                return new Decimal128(NAN_BUFFER);\n            }\n        }\n        while(isDigit(representation[index]) || representation[index] === \".\"){\n            if (representation[index] === \".\") {\n                if (sawRadix) invalidErr(representation, \"contains multiple periods\");\n                sawRadix = true;\n                index = index + 1;\n                continue;\n            }\n            if (nDigitsStored < MAX_DIGITS) {\n                if (representation[index] !== \"0\" || foundNonZero) {\n                    if (!foundNonZero) {\n                        firstNonZero = nDigitsRead;\n                    }\n                    foundNonZero = true;\n                    digits[digitsInsert++] = parseInt(representation[index], 10);\n                    nDigitsStored = nDigitsStored + 1;\n                }\n            }\n            if (foundNonZero) nDigits = nDigits + 1;\n            if (sawRadix) radixPosition = radixPosition + 1;\n            nDigitsRead = nDigitsRead + 1;\n            index = index + 1;\n        }\n        if (sawRadix && !nDigitsRead) throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        if (representation[index] === \"e\" || representation[index] === \"E\") {\n            const match = representation.substr(++index).match(EXPONENT_REGEX);\n            if (!match || !match[2]) return new Decimal128(NAN_BUFFER);\n            exponent = parseInt(match[0], 10);\n            index = index + match[0].length;\n        }\n        if (representation[index]) return new Decimal128(NAN_BUFFER);\n        if (!nDigitsStored) {\n            digits[0] = 0;\n            nDigits = 1;\n            nDigitsStored = 1;\n            significantDigits = 0;\n        } else {\n            lastDigit = nDigitsStored - 1;\n            significantDigits = nDigits;\n            if (significantDigits !== 1) {\n                while(representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === \"0\"){\n                    significantDigits = significantDigits - 1;\n                }\n            }\n        }\n        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {\n            exponent = EXPONENT_MIN;\n        } else {\n            exponent = exponent - radixPosition;\n        }\n        while(exponent > EXPONENT_MAX){\n            lastDigit = lastDigit + 1;\n            if (lastDigit >= MAX_DIGITS) {\n                if (significantDigits === 0) {\n                    exponent = EXPONENT_MAX;\n                    break;\n                }\n                invalidErr(representation, \"overflow\");\n            }\n            exponent = exponent - 1;\n        }\n        if (options.allowRounding) {\n            while(exponent < EXPONENT_MIN || nDigitsStored < nDigits){\n                if (lastDigit === 0 && significantDigits < nDigitsStored) {\n                    exponent = EXPONENT_MIN;\n                    significantDigits = 0;\n                    break;\n                }\n                if (nDigitsStored < nDigits) {\n                    nDigits = nDigits - 1;\n                } else {\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                } else {\n                    const digitsString = digits.join(\"\");\n                    if (digitsString.match(/^0+$/)) {\n                        exponent = EXPONENT_MAX;\n                        break;\n                    }\n                    invalidErr(representation, \"overflow\");\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                let endOfString = nDigitsRead;\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                let roundBit = 0;\n                if (roundDigit >= 5) {\n                    roundBit = 1;\n                    if (roundDigit === 5) {\n                        roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n                        for(let i = firstNonZero + lastDigit + 2; i < endOfString; i++){\n                            if (parseInt(representation[i], 10)) {\n                                roundBit = 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (roundBit) {\n                    let dIdx = lastDigit;\n                    for(; dIdx >= 0; dIdx--){\n                        if (++digits[dIdx] > 9) {\n                            digits[dIdx] = 0;\n                            if (dIdx === 0) {\n                                if (exponent < EXPONENT_MAX) {\n                                    exponent = exponent + 1;\n                                    digits[dIdx] = 1;\n                                } else {\n                                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n                                }\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        } else {\n            while(exponent < EXPONENT_MIN || nDigitsStored < nDigits){\n                if (lastDigit === 0) {\n                    if (significantDigits === 0) {\n                        exponent = EXPONENT_MIN;\n                        break;\n                    }\n                    invalidErr(representation, \"exponent underflow\");\n                }\n                if (nDigitsStored < nDigits) {\n                    if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== \"0\" && significantDigits !== 0) {\n                        invalidErr(representation, \"inexact rounding\");\n                    }\n                    nDigits = nDigits - 1;\n                } else {\n                    if (digits[lastDigit] !== 0) {\n                        invalidErr(representation, \"inexact rounding\");\n                    }\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                } else {\n                    invalidErr(representation, \"overflow\");\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                if (roundDigit !== 0) {\n                    invalidErr(representation, \"inexact rounding\");\n                }\n            }\n        }\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n        if (significantDigits === 0) {\n            significandHigh = Long.fromNumber(0);\n            significandLow = Long.fromNumber(0);\n        } else if (lastDigit < 17) {\n            let dIdx = 0;\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            significandHigh = new Long(0, 0);\n            for(; dIdx <= lastDigit; dIdx++){\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        } else {\n            let dIdx = 0;\n            significandHigh = Long.fromNumber(digits[dIdx++]);\n            for(; dIdx <= lastDigit - 17; dIdx++){\n                significandHigh = significandHigh.multiply(Long.fromNumber(10));\n                significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n            }\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            for(; dIdx <= lastDigit; dIdx++){\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        const significand = multiply64x2(significandHigh, Long.fromString(\"100000000000000000\"));\n        significand.low = significand.low.add(significandLow);\n        if (lessThan(significand.low, significandLow)) {\n            significand.high = significand.high.add(Long.fromNumber(1));\n        }\n        biasedExponent = exponent + EXPONENT_BIAS;\n        const dec = {\n            low: Long.fromNumber(0),\n            high: Long.fromNumber(0)\n        };\n        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n            dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\n        } else {\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\n        }\n        dec.low = significand.low;\n        if (isNegative) {\n            dec.high = dec.high.or(Long.fromString(\"9223372036854775808\"));\n        }\n        const buffer = ByteUtils.allocate(16);\n        index = 0;\n        buffer[index++] = dec.low.low & 0xff;\n        buffer[index++] = dec.low.low >> 8 & 0xff;\n        buffer[index++] = dec.low.low >> 16 & 0xff;\n        buffer[index++] = dec.low.low >> 24 & 0xff;\n        buffer[index++] = dec.low.high & 0xff;\n        buffer[index++] = dec.low.high >> 8 & 0xff;\n        buffer[index++] = dec.low.high >> 16 & 0xff;\n        buffer[index++] = dec.low.high >> 24 & 0xff;\n        buffer[index++] = dec.high.low & 0xff;\n        buffer[index++] = dec.high.low >> 8 & 0xff;\n        buffer[index++] = dec.high.low >> 16 & 0xff;\n        buffer[index++] = dec.high.low >> 24 & 0xff;\n        buffer[index++] = dec.high.high & 0xff;\n        buffer[index++] = dec.high.high >> 8 & 0xff;\n        buffer[index++] = dec.high.high >> 16 & 0xff;\n        buffer[index++] = dec.high.high >> 24 & 0xff;\n        return new Decimal128(buffer);\n    }\n    toString() {\n        let biased_exponent;\n        let significand_digits = 0;\n        const significand = new Array(36);\n        for(let i = 0; i < significand.length; i++)significand[i] = 0;\n        let index = 0;\n        let is_zero = false;\n        let significand_msb;\n        let significand128 = {\n            parts: [\n                0,\n                0,\n                0,\n                0\n            ]\n        };\n        let j, k;\n        const string = [];\n        index = 0;\n        const buffer = this.bytes;\n        const low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        index = 0;\n        const dec = {\n            low: new Long(low, midl),\n            high: new Long(midh, high)\n        };\n        if (dec.high.lessThan(Long.ZERO)) {\n            string.push(\"-\");\n        }\n        const combination = high >> 26 & COMBINATION_MASK;\n        if (combination >> 3 === 3) {\n            if (combination === COMBINATION_INFINITY) {\n                return string.join(\"\") + \"Infinity\";\n            } else if (combination === COMBINATION_NAN) {\n                return \"NaN\";\n            } else {\n                biased_exponent = high >> 15 & EXPONENT_MASK;\n                significand_msb = 0x08 + (high >> 14 & 0x01);\n            }\n        } else {\n            significand_msb = high >> 14 & 0x07;\n            biased_exponent = high >> 17 & EXPONENT_MASK;\n        }\n        const exponent = biased_exponent - EXPONENT_BIAS;\n        significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n        significand128.parts[1] = midh;\n        significand128.parts[2] = midl;\n        significand128.parts[3] = low;\n        if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {\n            is_zero = true;\n        } else {\n            for(k = 3; k >= 0; k--){\n                let least_digits = 0;\n                const result = divideu128(significand128);\n                significand128 = result.quotient;\n                least_digits = result.rem.low;\n                if (!least_digits) continue;\n                for(j = 8; j >= 0; j--){\n                    significand[k * 9 + j] = least_digits % 10;\n                    least_digits = Math.floor(least_digits / 10);\n                }\n            }\n        }\n        if (is_zero) {\n            significand_digits = 1;\n            significand[index] = 0;\n        } else {\n            significand_digits = 36;\n            while(!significand[index]){\n                significand_digits = significand_digits - 1;\n                index = index + 1;\n            }\n        }\n        const scientific_exponent = significand_digits - 1 + exponent;\n        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n            if (significand_digits > 34) {\n                string.push(`${0}`);\n                if (exponent > 0) string.push(`E+${exponent}`);\n                else if (exponent < 0) string.push(`E${exponent}`);\n                return string.join(\"\");\n            }\n            string.push(`${significand[index++]}`);\n            significand_digits = significand_digits - 1;\n            if (significand_digits) {\n                string.push(\".\");\n            }\n            for(let i = 0; i < significand_digits; i++){\n                string.push(`${significand[index++]}`);\n            }\n            string.push(\"E\");\n            if (scientific_exponent > 0) {\n                string.push(`+${scientific_exponent}`);\n            } else {\n                string.push(`${scientific_exponent}`);\n            }\n        } else {\n            if (exponent >= 0) {\n                for(let i = 0; i < significand_digits; i++){\n                    string.push(`${significand[index++]}`);\n                }\n            } else {\n                let radix_position = significand_digits + exponent;\n                if (radix_position > 0) {\n                    for(let i = 0; i < radix_position; i++){\n                        string.push(`${significand[index++]}`);\n                    }\n                } else {\n                    string.push(\"0\");\n                }\n                string.push(\".\");\n                while(radix_position++ < 0){\n                    string.push(\"0\");\n                }\n                for(let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++){\n                    string.push(`${significand[index++]}`);\n                }\n            }\n        }\n        return string.join(\"\");\n    }\n    toJSON() {\n        return {\n            $numberDecimal: this.toString()\n        };\n    }\n    toExtendedJSON() {\n        return {\n            $numberDecimal: this.toString()\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return Decimal128.fromString(doc.$numberDecimal);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const d128string = inspect(this.toString(), options);\n        return `new Decimal128(${d128string})`;\n    }\n}\nclass Double extends BSONValue {\n    get _bsontype() {\n        return \"Double\";\n    }\n    constructor(value){\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toExtendedJSON(options) {\n        if (options && (options.legacy || options.relaxed && isFinite(this.value))) {\n            return this.value;\n        }\n        if (Object.is(Math.sign(this.value), -0)) {\n            return {\n                $numberDouble: \"-0.0\"\n            };\n        }\n        return {\n            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const doubleValue = parseFloat(doc.$numberDouble);\n        return options && options.relaxed ? doubleValue : new Double(doubleValue);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Double(${inspect(this.value, options)})`;\n    }\n}\nclass Int32 extends BSONValue {\n    get _bsontype() {\n        return \"Int32\";\n    }\n    constructor(value){\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value | 0;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON(options) {\n        if (options && (options.relaxed || options.legacy)) return this.value;\n        return {\n            $numberInt: this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Int32(${inspect(this.value, options)})`;\n    }\n}\nclass MaxKey extends BSONValue {\n    get _bsontype() {\n        return \"MaxKey\";\n    }\n    toExtendedJSON() {\n        return {\n            $maxKey: 1\n        };\n    }\n    static fromExtendedJSON() {\n        return new MaxKey();\n    }\n    inspect() {\n        return \"new MaxKey()\";\n    }\n}\nclass MinKey extends BSONValue {\n    get _bsontype() {\n        return \"MinKey\";\n    }\n    toExtendedJSON() {\n        return {\n            $minKey: 1\n        };\n    }\n    static fromExtendedJSON() {\n        return new MinKey();\n    }\n    inspect() {\n        return \"new MinKey()\";\n    }\n}\nconst checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");\nlet PROCESS_UNIQUE = null;\nconst kId = Symbol(\"id\");\nclass ObjectId extends BSONValue {\n    get _bsontype() {\n        return \"ObjectId\";\n    }\n    constructor(inputId){\n        super();\n        let workingId;\n        if (typeof inputId === \"object\" && inputId && \"id\" in inputId) {\n            if (typeof inputId.id !== \"string\" && !ArrayBuffer.isView(inputId.id)) {\n                throw new BSONError(\"Argument passed in must have an id that is of type string or Buffer\");\n            }\n            if (\"toHexString\" in inputId && typeof inputId.toHexString === \"function\") {\n                workingId = ByteUtils.fromHex(inputId.toHexString());\n            } else {\n                workingId = inputId.id;\n            }\n        } else {\n            workingId = inputId;\n        }\n        if (workingId == null || typeof workingId === \"number\") {\n            this[kId] = ObjectId.generate(typeof workingId === \"number\" ? workingId : undefined);\n        } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n            this[kId] = ByteUtils.toLocalBufferType(workingId);\n        } else if (typeof workingId === \"string\") {\n            if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n                this[kId] = ByteUtils.fromHex(workingId);\n            } else {\n                throw new BSONError(\"input must be a 24 character hex string, 12 byte Uint8Array, or an integer\");\n            }\n        } else {\n            throw new BSONError(\"Argument passed in does not match the accepted types\");\n        }\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(this.id);\n        }\n    }\n    get id() {\n        return this[kId];\n    }\n    set id(value) {\n        this[kId] = value;\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(value);\n        }\n    }\n    toHexString() {\n        if (ObjectId.cacheHexString && this.__id) {\n            return this.__id;\n        }\n        const hexString = ByteUtils.toHex(this.id);\n        if (ObjectId.cacheHexString && !this.__id) {\n            this.__id = hexString;\n        }\n        return hexString;\n    }\n    static getInc() {\n        return ObjectId.index = (ObjectId.index + 1) % 0xffffff;\n    }\n    static generate(time) {\n        if (\"number\" !== typeof time) {\n            time = Math.floor(Date.now() / 1000);\n        }\n        const inc = ObjectId.getInc();\n        const buffer = ByteUtils.allocate(12);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        if (PROCESS_UNIQUE === null) {\n            PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n        }\n        buffer[4] = PROCESS_UNIQUE[0];\n        buffer[5] = PROCESS_UNIQUE[1];\n        buffer[6] = PROCESS_UNIQUE[2];\n        buffer[7] = PROCESS_UNIQUE[3];\n        buffer[8] = PROCESS_UNIQUE[4];\n        buffer[11] = inc & 0xff;\n        buffer[10] = inc >> 8 & 0xff;\n        buffer[9] = inc >> 16 & 0xff;\n        return buffer;\n    }\n    toString(encoding) {\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.id);\n        if (encoding === \"hex\") return this.toHexString();\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    static is(variable) {\n        return variable != null && typeof variable === \"object\" && \"_bsontype\" in variable && variable._bsontype === \"ObjectId\";\n    }\n    equals(otherId) {\n        if (otherId === undefined || otherId === null) {\n            return false;\n        }\n        if (ObjectId.is(otherId)) {\n            return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]);\n        }\n        if (typeof otherId === \"string\") {\n            return otherId.toLowerCase() === this.toHexString();\n        }\n        if (typeof otherId === \"object\" && typeof otherId.toHexString === \"function\") {\n            const otherIdString = otherId.toHexString();\n            const thisIdString = this.toHexString();\n            return typeof otherIdString === \"string\" && otherIdString.toLowerCase() === thisIdString;\n        }\n        return false;\n    }\n    getTimestamp() {\n        const timestamp = new Date();\n        const time = BSONDataView.fromUint8Array(this.id).getUint32(0, false);\n        timestamp.setTime(Math.floor(time) * 1000);\n        return timestamp;\n    }\n    static createPk() {\n        return new ObjectId();\n    }\n    static createFromTime(time) {\n        const buffer = ByteUtils.fromNumberArray([\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ]);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        return new ObjectId(buffer);\n    }\n    static createFromHexString(hexString) {\n        if (hexString?.length !== 24) {\n            throw new BSONError(\"hex string must be 24 characters\");\n        }\n        return new ObjectId(ByteUtils.fromHex(hexString));\n    }\n    static createFromBase64(base64) {\n        if (base64?.length !== 16) {\n            throw new BSONError(\"base64 string must be 16 characters\");\n        }\n        return new ObjectId(ByteUtils.fromBase64(base64));\n    }\n    static isValid(id) {\n        if (id == null) return false;\n        try {\n            new ObjectId(id);\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    toExtendedJSON() {\n        if (this.toHexString) return {\n            $oid: this.toHexString()\n        };\n        return {\n            $oid: this.toString(\"hex\")\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new ObjectId(doc.$oid);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new ObjectId(${inspect(this.toHexString(), options)})`;\n    }\n}\nObjectId.index = Math.floor(Math.random() * 0xffffff);\nfunction internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {\n    let totalLength = 4 + 1;\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; i++){\n            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n        }\n    } else {\n        if (typeof object?.toBSON === \"function\") {\n            object = object.toBSON();\n        }\n        for (const key of Object.keys(object)){\n            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n        }\n    }\n    return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {\n    if (typeof value?.toBSON === \"function\") {\n        value = value.toBSON();\n    }\n    switch(typeof value){\n        case \"string\":\n            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;\n        case \"number\":\n            if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {\n                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n                }\n            } else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n        case \"undefined\":\n            if (isArray || !ignoreUndefined) return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            return 0;\n        case \"boolean\":\n            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);\n        case \"object\":\n            if (value != null && typeof value._bsontype === \"string\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value == null || value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            } else if (value._bsontype === \"ObjectId\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);\n            } else if (value instanceof Date || isDate(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Double\" || value._bsontype === \"Timestamp\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            } else if (value._bsontype === \"Decimal128\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);\n            } else if (value._bsontype === \"Code\") {\n                if (value.scope != null && Object.keys(value.scope).length > 0) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;\n                }\n            } else if (value._bsontype === \"Binary\") {\n                const binary = value;\n                if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);\n                }\n            } else if (value._bsontype === \"Symbol\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;\n            } else if (value._bsontype === \"DBRef\") {\n                const ordered_values = Object.assign({\n                    $ref: value.collection,\n                    $id: value.oid\n                }, value.fields);\n                if (value.db != null) {\n                    ordered_values[\"$db\"] = value.db;\n                }\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;\n            } else if (value._bsontype === \"BSONRegExp\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;\n            } else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;\n            }\n        case \"function\":\n            if (serializeFunctions) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;\n            }\n    }\n    return 0;\n}\nfunction alphabetize(str) {\n    return str.split(\"\").sort().join(\"\");\n}\nclass BSONRegExp extends BSONValue {\n    get _bsontype() {\n        return \"BSONRegExp\";\n    }\n    constructor(pattern, options){\n        super();\n        this.pattern = pattern;\n        this.options = alphabetize(options ?? \"\");\n        if (this.pattern.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);\n        }\n        if (this.options.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);\n        }\n        for(let i = 0; i < this.options.length; i++){\n            if (!(this.options[i] === \"i\" || this.options[i] === \"m\" || this.options[i] === \"x\" || this.options[i] === \"l\" || this.options[i] === \"s\" || this.options[i] === \"u\")) {\n                throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\n            }\n        }\n    }\n    static parseOptions(options) {\n        return options ? options.split(\"\").sort().join(\"\") : \"\";\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (options.legacy) {\n            return {\n                $regex: this.pattern,\n                $options: this.options\n            };\n        }\n        return {\n            $regularExpression: {\n                pattern: this.pattern,\n                options: this.options\n            }\n        };\n    }\n    static fromExtendedJSON(doc) {\n        if (\"$regex\" in doc) {\n            if (typeof doc.$regex !== \"string\") {\n                if (doc.$regex._bsontype === \"BSONRegExp\") {\n                    return doc;\n                }\n            } else {\n                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n            }\n        }\n        if (\"$regularExpression\" in doc) {\n            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n        }\n        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\n    }\n    inspect(depth, options, inspect) {\n        const stylize = getStylizeFunction(options) ?? ((v)=>v);\n        inspect ??= defaultInspect;\n        const pattern = stylize(inspect(this.pattern), \"regexp\");\n        const flags = stylize(inspect(this.options), \"regexp\");\n        return `new BSONRegExp(${pattern}, ${flags})`;\n    }\n}\nclass BSONSymbol extends BSONValue {\n    get _bsontype() {\n        return \"BSONSymbol\";\n    }\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON() {\n        return {\n            $symbol: this.value\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new BSONSymbol(doc.$symbol);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new BSONSymbol(${inspect(this.value, options)})`;\n    }\n}\nconst LongWithoutOverridesClass = Long;\nclass Timestamp extends LongWithoutOverridesClass {\n    get _bsontype() {\n        return \"Timestamp\";\n    }\n    constructor(low){\n        if (low == null) {\n            super(0, 0, true);\n        } else if (typeof low === \"bigint\") {\n            super(low, true);\n        } else if (Long.isLong(low)) {\n            super(low.low, low.high, true);\n        } else if (typeof low === \"object\" && \"t\" in low && \"i\" in low) {\n            if (typeof low.t !== \"number\" && (typeof low.t !== \"object\" || low.t._bsontype !== \"Int32\")) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide t as a number\");\n            }\n            if (typeof low.i !== \"number\" && (typeof low.i !== \"object\" || low.i._bsontype !== \"Int32\")) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide i as a number\");\n            }\n            const t = Number(low.t);\n            const i = Number(low.i);\n            if (t < 0 || Number.isNaN(t)) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide a positive t\");\n            }\n            if (i < 0 || Number.isNaN(i)) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide a positive i\");\n            }\n            if (t > 4294967295) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide t equal or less than uint32 max\");\n            }\n            if (i > 4294967295) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide i equal or less than uint32 max\");\n            }\n            super(i, t, true);\n        } else {\n            throw new BSONError(\"A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }\");\n        }\n    }\n    toJSON() {\n        return {\n            $timestamp: this.toString()\n        };\n    }\n    static fromInt(value) {\n        return new Timestamp(Long.fromInt(value, true));\n    }\n    static fromNumber(value) {\n        return new Timestamp(Long.fromNumber(value, true));\n    }\n    static fromBits(lowBits, highBits) {\n        return new Timestamp({\n            i: lowBits,\n            t: highBits\n        });\n    }\n    static fromString(str, optRadix) {\n        return new Timestamp(Long.fromString(str, true, optRadix));\n    }\n    toExtendedJSON() {\n        return {\n            $timestamp: {\n                t: this.high >>> 0,\n                i: this.low >>> 0\n            }\n        };\n    }\n    static fromExtendedJSON(doc) {\n        const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;\n        const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;\n        return new Timestamp({\n            t,\n            i\n        });\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const t = inspect(this.high >>> 0, options);\n        const i = inspect(this.low >>> 0, options);\n        return `new Timestamp({ t: ${t}, i: ${i} })`;\n    }\n}\nTimestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\nconst FIRST_BIT = 0x80;\nconst FIRST_TWO_BITS = 0xc0;\nconst FIRST_THREE_BITS = 0xe0;\nconst FIRST_FOUR_BITS = 0xf0;\nconst FIRST_FIVE_BITS = 0xf8;\nconst TWO_BIT_CHAR = 0xc0;\nconst THREE_BIT_CHAR = 0xe0;\nconst FOUR_BIT_CHAR = 0xf0;\nconst CONTINUING_CHAR = 0x80;\nfunction validateUtf8(bytes, start, end) {\n    let continuation = 0;\n    for(let i = start; i < end; i += 1){\n        const byte = bytes[i];\n        if (continuation) {\n            if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {\n                return false;\n            }\n            continuation -= 1;\n        } else if (byte & FIRST_BIT) {\n            if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {\n                continuation = 1;\n            } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {\n                continuation = 2;\n            } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {\n                continuation = 3;\n            } else {\n                return false;\n            }\n        }\n    }\n    return !continuation;\n}\nconst JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nfunction internalDeserialize(buffer, options, isArray) {\n    options = options == null ? {} : options;\n    const index = options && options.index ? options.index : 0;\n    const size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n    if (size < 5) {\n        throw new BSONError(`bson size must be >= 5, is ${size}`);\n    }\n    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n        throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n    }\n    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n        throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n    }\n    if (size + index > buffer.byteLength) {\n        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);\n    }\n    if (buffer[index + size - 1] !== 0) {\n        throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n    }\n    return deserializeObject(buffer, index, options, isArray);\n}\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray = false) {\n    const fieldsAsRaw = options[\"fieldsAsRaw\"] == null ? null : options[\"fieldsAsRaw\"];\n    const raw = options[\"raw\"] == null ? false : options[\"raw\"];\n    const bsonRegExp = typeof options[\"bsonRegExp\"] === \"boolean\" ? options[\"bsonRegExp\"] : false;\n    const promoteBuffers = options.promoteBuffers ?? false;\n    const promoteLongs = options.promoteLongs ?? true;\n    const promoteValues = options.promoteValues ?? true;\n    const useBigInt64 = options.useBigInt64 ?? false;\n    if (useBigInt64 && !promoteValues) {\n        throw new BSONError(\"Must either request bigint or Long for int64 deserialization\");\n    }\n    if (useBigInt64 && !promoteLongs) {\n        throw new BSONError(\"Must either request bigint or Long for int64 deserialization\");\n    }\n    const validation = options.validation == null ? {\n        utf8: true\n    } : options.validation;\n    let globalUTFValidation = true;\n    let validationSetting;\n    const utf8KeysSet = new Set();\n    const utf8ValidatedKeys = validation.utf8;\n    if (typeof utf8ValidatedKeys === \"boolean\") {\n        validationSetting = utf8ValidatedKeys;\n    } else {\n        globalUTFValidation = false;\n        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {\n            return utf8ValidatedKeys[key];\n        });\n        if (utf8ValidationValues.length === 0) {\n            throw new BSONError(\"UTF-8 validation setting cannot be empty\");\n        }\n        if (typeof utf8ValidationValues[0] !== \"boolean\") {\n            throw new BSONError(\"Invalid UTF-8 validation option, must specify boolean values\");\n        }\n        validationSetting = utf8ValidationValues[0];\n        if (!utf8ValidationValues.every((item)=>item === validationSetting)) {\n            throw new BSONError(\"Invalid UTF-8 validation option - keys must be all true or all false\");\n        }\n    }\n    if (!globalUTFValidation) {\n        for (const key of Object.keys(utf8ValidatedKeys)){\n            utf8KeysSet.add(key);\n        }\n    }\n    const startIndex = index;\n    if (buffer.length < 5) throw new BSONError(\"corrupt bson message < 5 bytes long\");\n    const size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    if (size < 5 || size > buffer.length) throw new BSONError(\"corrupt bson message\");\n    const object = isArray ? [] : {};\n    let arrayIndex = 0;\n    const done = false;\n    let isPossibleDBRef = isArray ? false : null;\n    const dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    while(!done){\n        const elementType = buffer[index++];\n        if (elementType === 0) break;\n        let i = index;\n        while(buffer[i] !== 0x00 && i < buffer.length){\n            i++;\n        }\n        if (i >= buffer.byteLength) throw new BSONError(\"Bad BSON Document: illegal CString\");\n        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i);\n        let shouldValidateKey = true;\n        if (globalUTFValidation || utf8KeysSet.has(name)) {\n            shouldValidateKey = validationSetting;\n        } else {\n            shouldValidateKey = !validationSetting;\n        }\n        if (isPossibleDBRef !== false && name[0] === \"$\") {\n            isPossibleDBRef = allowedDBRefKeys.test(name);\n        }\n        let value;\n        index = i + 1;\n        if (elementType === BSON_DATA_STRING) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            value = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_OID) {\n            const oid = ByteUtils.allocate(12);\n            oid.set(buffer.subarray(index, index + 12));\n            value = new ObjectId(oid);\n            index = index + 12;\n        } else if (elementType === BSON_DATA_INT && promoteValues === false) {\n            value = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);\n        } else if (elementType === BSON_DATA_INT) {\n            value = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {\n            value = new Double(dataview.getFloat64(index, true));\n            index = index + 8;\n        } else if (elementType === BSON_DATA_NUMBER) {\n            value = dataview.getFloat64(index, true);\n            index = index + 8;\n        } else if (elementType === BSON_DATA_DATE) {\n            const lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            value = new Date(new Long(lowBits, highBits).toNumber());\n        } else if (elementType === BSON_DATA_BOOLEAN) {\n            if (buffer[index] !== 0 && buffer[index] !== 1) throw new BSONError(\"illegal boolean type value\");\n            value = buffer[index++] === 1;\n        } else if (elementType === BSON_DATA_OBJECT) {\n            const _index = index;\n            const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n            if (objectSize <= 0 || objectSize > buffer.length - index) throw new BSONError(\"bad embedded document length in bson\");\n            if (raw) {\n                value = buffer.slice(index, index + objectSize);\n            } else {\n                let objectOptions = options;\n                if (!globalUTFValidation) {\n                    objectOptions = {\n                        ...options,\n                        validation: {\n                            utf8: shouldValidateKey\n                        }\n                    };\n                }\n                value = deserializeObject(buffer, _index, objectOptions, false);\n            }\n            index = index + objectSize;\n        } else if (elementType === BSON_DATA_ARRAY) {\n            const _index = index;\n            const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n            let arrayOptions = options;\n            const stopIndex = index + objectSize;\n            if (fieldsAsRaw && fieldsAsRaw[name]) {\n                arrayOptions = {\n                    ...options,\n                    raw: true\n                };\n            }\n            if (!globalUTFValidation) {\n                arrayOptions = {\n                    ...arrayOptions,\n                    validation: {\n                        utf8: shouldValidateKey\n                    }\n                };\n            }\n            value = deserializeObject(buffer, _index, arrayOptions, true);\n            index = index + objectSize;\n            if (buffer[index - 1] !== 0) throw new BSONError(\"invalid array terminator byte\");\n            if (index !== stopIndex) throw new BSONError(\"corrupted array bson\");\n        } else if (elementType === BSON_DATA_UNDEFINED) {\n            value = undefined;\n        } else if (elementType === BSON_DATA_NULL) {\n            value = null;\n        } else if (elementType === BSON_DATA_LONG) {\n            const dataview = BSONDataView.fromUint8Array(buffer.subarray(index, index + 8));\n            const lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const long = new Long(lowBits, highBits);\n            if (useBigInt64) {\n                value = dataview.getBigInt64(0, true);\n            } else if (promoteLongs && promoteValues === true) {\n                value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n            } else {\n                value = long;\n            }\n        } else if (elementType === BSON_DATA_DECIMAL128) {\n            const bytes = ByteUtils.allocate(16);\n            bytes.set(buffer.subarray(index, index + 16), 0);\n            index = index + 16;\n            value = new Decimal128(bytes);\n        } else if (elementType === BSON_DATA_BINARY) {\n            let binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const totalBinarySize = binarySize;\n            const subType = buffer[index++];\n            if (binarySize < 0) throw new BSONError(\"Negative binary type element size found\");\n            if (binarySize > buffer.byteLength) throw new BSONError(\"Binary type size larger than document size\");\n            if (buffer[\"slice\"] != null) {\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n                    if (binarySize < 0) throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n                    if (binarySize > totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n                    if (binarySize < totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));\n                } else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            } else {\n                const _buffer = ByteUtils.allocate(binarySize);\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n                    if (binarySize < 0) throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n                    if (binarySize > totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n                    if (binarySize < totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n                }\n                for(i = 0; i < binarySize; i++){\n                    _buffer[i] = buffer[index + i];\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = _buffer;\n                } else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            }\n            index = index + binarySize;\n        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const source = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            const optionsArray = new Array(regExpOptions.length);\n            for(i = 0; i < regExpOptions.length; i++){\n                switch(regExpOptions[i]){\n                    case \"m\":\n                        optionsArray[i] = \"m\";\n                        break;\n                    case \"s\":\n                        optionsArray[i] = \"g\";\n                        break;\n                    case \"i\":\n                        optionsArray[i] = \"i\";\n                        break;\n                }\n            }\n            value = new RegExp(source, optionsArray.join(\"\"));\n        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const source = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            value = new BSONRegExp(source, regExpOptions);\n        } else if (elementType === BSON_DATA_SYMBOL) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const symbol = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = promoteValues ? symbol : new BSONSymbol(symbol);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_TIMESTAMP) {\n            const i = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);\n            const t = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);\n            value = new Timestamp({\n                i,\n                t\n            });\n        } else if (elementType === BSON_DATA_MIN_KEY) {\n            value = new MinKey();\n        } else if (elementType === BSON_DATA_MAX_KEY) {\n            value = new MaxKey();\n        } else if (elementType === BSON_DATA_CODE) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = new Code(functionString);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n            const totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (totalSize < 4 + 4 + 4 + 1) {\n                throw new BSONError(\"code_w_scope total size shorter minimum expected length\");\n            }\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const _index = index;\n            const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n            const scopeObject = deserializeObject(buffer, _index, options, false);\n            index = index + objectSize;\n            if (totalSize < 4 + 4 + objectSize + stringSize) {\n                throw new BSONError(\"code_w_scope total size is too short, truncating scope\");\n            }\n            if (totalSize > 4 + 4 + objectSize + stringSize) {\n                throw new BSONError(\"code_w_scope total size is too long, clips outer document\");\n            }\n            value = new Code(functionString, scopeObject);\n        } else if (elementType === BSON_DATA_DBPOINTER) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new BSONError(\"bad string length in bson\");\n            if (validation != null && validation.utf8) {\n                if (!validateUtf8(buffer, index, index + stringSize - 1)) {\n                    throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n                }\n            }\n            const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1);\n            index = index + stringSize;\n            const oidBuffer = ByteUtils.allocate(12);\n            oidBuffer.set(buffer.subarray(index, index + 12), 0);\n            const oid = new ObjectId(oidBuffer);\n            index = index + 12;\n            value = new DBRef(namespace, oid);\n        } else {\n            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`);\n        }\n        if (name === \"__proto__\") {\n            Object.defineProperty(object, name, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        } else {\n            object[name] = value;\n        }\n    }\n    if (size !== index - startIndex) {\n        if (isArray) throw new BSONError(\"corrupt array bson\");\n        throw new BSONError(\"corrupt object bson\");\n    }\n    if (!isPossibleDBRef) return object;\n    if (isDBRefLike(object)) {\n        const copy = Object.assign({}, object);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(object.$ref, object.$id, object.$db, copy);\n    }\n    return object;\n}\nfunction getValidatedString(buffer, start, end, shouldValidateUtf8) {\n    const value = ByteUtils.toUTF8(buffer, start, end);\n    if (shouldValidateUtf8) {\n        for(let i = 0; i < value.length; i++){\n            if (value.charCodeAt(i) === 0xfffd) {\n                if (!validateUtf8(buffer, start, end)) {\n                    throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n                }\n                break;\n            }\n        }\n    }\n    return value;\n}\nconst regexp = /\\x00/;\nconst ignoreKeys = new Set([\n    \"$db\",\n    \"$ref\",\n    \"$id\",\n    \"$clusterTime\"\n]);\nfunction serializeString(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_STRING;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes + 1;\n    buffer[index - 1] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n    buffer[index + 3] = size + 1 >> 24 & 0xff;\n    buffer[index + 2] = size + 1 >> 16 & 0xff;\n    buffer[index + 1] = size + 1 >> 8 & 0xff;\n    buffer[index] = size + 1 & 0xff;\n    index = index + 4 + size;\n    buffer[index++] = 0;\n    return index;\n}\nconst NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);\nconst FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);\nconst EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);\nfunction serializeNumber(buffer, key, value, index) {\n    const isNegativeZero = Object.is(value, -0);\n    const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;\n    if (type === BSON_DATA_INT) {\n        NUMBER_SPACE.setInt32(0, value, true);\n    } else {\n        NUMBER_SPACE.setFloat64(0, value, true);\n    }\n    const bytes = type === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;\n    buffer[index++] = type;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0x00;\n    buffer.set(bytes, index);\n    index += bytes.byteLength;\n    return index;\n}\nfunction serializeBigInt(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_LONG;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index += numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setBigInt64(0, value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;\n    return index;\n}\nfunction serializeNull(buffer, key, _, index) {\n    buffer[index++] = BSON_DATA_NULL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeBoolean(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BOOLEAN;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value ? 1 : 0;\n    return index;\n}\nfunction serializeDate(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DATE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const dateInMilis = Long.fromNumber(value.getTime());\n    const lowBits = dateInMilis.getLowBits();\n    const highBits = dateInMilis.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = lowBits >> 8 & 0xff;\n    buffer[index++] = lowBits >> 16 & 0xff;\n    buffer[index++] = lowBits >> 24 & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = highBits >> 8 & 0xff;\n    buffer[index++] = highBits >> 16 & 0xff;\n    buffer[index++] = highBits >> 24 & 0xff;\n    return index;\n}\nfunction serializeRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.source && value.source.match(regexp) != null) {\n        throw new BSONError(\"value \" + value.source + \" must not contain null bytes\");\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n    buffer[index++] = 0x00;\n    if (value.ignoreCase) buffer[index++] = 0x69;\n    if (value.global) buffer[index++] = 0x73;\n    if (value.multiline) buffer[index++] = 0x6d;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.pattern.match(regexp) != null) {\n        throw new BSONError(\"pattern \" + value.pattern + \" must not contain null bytes\");\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n    buffer[index++] = 0x00;\n    const sortedOptions = value.options.split(\"\").sort().join(\"\");\n    index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeMinMax(buffer, key, value, index) {\n    if (value === null) {\n        buffer[index++] = BSON_DATA_NULL;\n    } else if (value._bsontype === \"MinKey\") {\n        buffer[index++] = BSON_DATA_MIN_KEY;\n    } else {\n        buffer[index++] = BSON_DATA_MAX_KEY;\n    }\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeObjectId(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_OID;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const idValue = value.id;\n    if (isUint8Array(idValue)) {\n        for(let i = 0; i < 12; i++){\n            buffer[index++] = idValue[i];\n        }\n    } else {\n        throw new BSONError(\"object [\" + JSON.stringify(value) + \"] is not a valid ObjectId\");\n    }\n    return index;\n}\nfunction serializeBuffer(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = value.length;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n    buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n    buffer.set(value, index);\n    index = index + size;\n    return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path.has(value)) {\n        throw new BSONError(\"Cannot convert circular structure to BSON\");\n    }\n    path.add(value);\n    buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n    path.delete(value);\n    return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DECIMAL128;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer.set(value.bytes.subarray(0, 16), index);\n    return index + 16;\n}\nfunction serializeLong(buffer, key, value, index) {\n    buffer[index++] = value._bsontype === \"Long\" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const lowBits = value.getLowBits();\n    const highBits = value.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = lowBits >> 8 & 0xff;\n    buffer[index++] = lowBits >> 16 & 0xff;\n    buffer[index++] = lowBits >> 24 & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = highBits >> 8 & 0xff;\n    buffer[index++] = highBits >> 16 & 0xff;\n    buffer[index++] = highBits >> 24 & 0xff;\n    return index;\n}\nfunction serializeInt32(buffer, key, value, index) {\n    value = value.valueOf();\n    buffer[index++] = BSON_DATA_INT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value & 0xff;\n    buffer[index++] = value >> 8 & 0xff;\n    buffer[index++] = value >> 16 & 0xff;\n    buffer[index++] = value >> 24 & 0xff;\n    return index;\n}\nfunction serializeDouble(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_NUMBER;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setFloat64(0, value.value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index = index + 8;\n    return index;\n}\nfunction serializeFunction(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_CODE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const functionString = value.toString();\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {\n    if (value.scope && typeof value.scope === \"object\") {\n        buffer[index++] = BSON_DATA_CODE_W_SCOPE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        let startIndex = index;\n        const functionString = value.code;\n        index = index + 4;\n        const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = codeSize & 0xff;\n        buffer[index + 1] = codeSize >> 8 & 0xff;\n        buffer[index + 2] = codeSize >> 16 & 0xff;\n        buffer[index + 3] = codeSize >> 24 & 0xff;\n        buffer[index + 4 + codeSize - 1] = 0;\n        index = index + codeSize + 4;\n        const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n        index = endIndex - 1;\n        const totalSize = endIndex - startIndex;\n        buffer[startIndex++] = totalSize & 0xff;\n        buffer[startIndex++] = totalSize >> 8 & 0xff;\n        buffer[startIndex++] = totalSize >> 16 & 0xff;\n        buffer[startIndex++] = totalSize >> 24 & 0xff;\n        buffer[index++] = 0;\n    } else {\n        buffer[index++] = BSON_DATA_CODE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        const functionString = value.code.toString();\n        const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = size & 0xff;\n        buffer[index + 1] = size >> 8 & 0xff;\n        buffer[index + 2] = size >> 16 & 0xff;\n        buffer[index + 3] = size >> 24 & 0xff;\n        index = index + 4 + size - 1;\n        buffer[index++] = 0;\n    }\n    return index;\n}\nfunction serializeBinary(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const data = value.buffer;\n    let size = value.position;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n    buffer[index++] = value.sub_type;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n        size = size - 4;\n        buffer[index++] = size & 0xff;\n        buffer[index++] = size >> 8 & 0xff;\n        buffer[index++] = size >> 16 & 0xff;\n        buffer[index++] = size >> 24 & 0xff;\n    }\n    buffer.set(data, index);\n    index = index + value.position;\n    return index;\n}\nfunction serializeSymbol(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_SYMBOL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {\n    buffer[index++] = BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    let startIndex = index;\n    let output = {\n        $ref: value.collection || value.namespace,\n        $id: value.oid\n    };\n    if (value.db != null) {\n        output.$db = value.db;\n    }\n    output = Object.assign(output, value.fields);\n    const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);\n    const size = endIndex - startIndex;\n    buffer[startIndex++] = size & 0xff;\n    buffer[startIndex++] = size >> 8 & 0xff;\n    buffer[startIndex++] = size >> 16 & 0xff;\n    buffer[startIndex++] = size >> 24 & 0xff;\n    return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path == null) {\n        if (object == null) {\n            buffer[0] = 0x05;\n            buffer[1] = 0x00;\n            buffer[2] = 0x00;\n            buffer[3] = 0x00;\n            buffer[4] = 0x00;\n            return 5;\n        }\n        if (Array.isArray(object)) {\n            throw new BSONError(\"serialize does not support an array as the root input\");\n        }\n        if (typeof object !== \"object\") {\n            throw new BSONError(\"serialize does not support non-object as the root input\");\n        } else if (\"_bsontype\" in object && typeof object._bsontype === \"string\") {\n            throw new BSONError(`BSON types cannot be serialized as a document`);\n        } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {\n            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n        }\n        path = new Set();\n    }\n    path.add(object);\n    let index = startingIndex + 4;\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; i++){\n            const key = `${i}`;\n            let value = object[i];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            if (typeof value === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (typeof value === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (typeof value === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (typeof value === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === undefined) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (typeof value === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    } else if (object instanceof Map || isMap(object)) {\n        const iterator = object.entries();\n        let done = false;\n        while(!done){\n            const entry = iterator.next();\n            done = !!entry.done;\n            if (done) continue;\n            const key = entry.value[0];\n            let value = entry.value[1];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError(\"key \" + key + \" must not contain null bytes\");\n                }\n                if (checkKeys) {\n                    if (\"$\" === key[0]) {\n                        throw new BSONError(\"key \" + key + \" must not start with '$'\");\n                    } else if (~key.indexOf(\".\")) {\n                        throw new BSONError(\"key \" + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (type === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (type === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (type === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === null || value === undefined && ignoreUndefined === false) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    } else {\n        if (typeof object?.toBSON === \"function\") {\n            object = object.toBSON();\n            if (object != null && typeof object !== \"object\") {\n                throw new BSONError(\"toBSON function did not return an object\");\n            }\n        }\n        for (const key of Object.keys(object)){\n            let value = object[key];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError(\"key \" + key + \" must not contain null bytes\");\n                }\n                if (checkKeys) {\n                    if (\"$\" === key[0]) {\n                        throw new BSONError(\"key \" + key + \" must not start with '$'\");\n                    } else if (~key.indexOf(\".\")) {\n                        throw new BSONError(\"key \" + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (type === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (type === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (type === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === undefined) {\n                if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n            } else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    path.delete(object);\n    buffer[index++] = 0x00;\n    const size = index - startingIndex;\n    buffer[startingIndex++] = size & 0xff;\n    buffer[startingIndex++] = size >> 8 & 0xff;\n    buffer[startingIndex++] = size >> 16 & 0xff;\n    buffer[startingIndex++] = size >> 24 & 0xff;\n    return index;\n}\nfunction isBSONType(value) {\n    return value != null && typeof value === \"object\" && \"_bsontype\" in value && typeof value._bsontype === \"string\";\n}\nconst keysToCodecs = {\n    $oid: ObjectId,\n    $binary: Binary,\n    $uuid: Binary,\n    $symbol: BSONSymbol,\n    $numberInt: Int32,\n    $numberDecimal: Decimal128,\n    $numberDouble: Double,\n    $numberLong: Long,\n    $minKey: MinKey,\n    $maxKey: MaxKey,\n    $regex: BSONRegExp,\n    $regularExpression: BSONRegExp,\n    $timestamp: Timestamp\n};\nfunction deserializeValue(value, options = {}) {\n    if (typeof value === \"number\") {\n        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;\n        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;\n        if (options.relaxed || options.legacy) {\n            return value;\n        }\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (in32BitRange) {\n                return new Int32(value);\n            }\n            if (in64BitRange) {\n                if (options.useBigInt64) {\n                    return BigInt(value);\n                }\n                return Long.fromNumber(value);\n            }\n        }\n        return new Double(value);\n    }\n    if (value == null || typeof value !== \"object\") return value;\n    if (value.$undefined) return null;\n    const keys = Object.keys(value).filter((k)=>k.startsWith(\"$\") && value[k] != null);\n    for(let i = 0; i < keys.length; i++){\n        const c = keysToCodecs[keys[i]];\n        if (c) return c.fromExtendedJSON(value, options);\n    }\n    if (value.$date != null) {\n        const d = value.$date;\n        const date = new Date();\n        if (options.legacy) {\n            if (typeof d === \"number\") date.setTime(d);\n            else if (typeof d === \"string\") date.setTime(Date.parse(d));\n            else if (typeof d === \"bigint\") date.setTime(Number(d));\n            else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        } else {\n            if (typeof d === \"string\") date.setTime(Date.parse(d));\n            else if (Long.isLong(d)) date.setTime(d.toNumber());\n            else if (typeof d === \"number\" && options.relaxed) date.setTime(d);\n            else if (typeof d === \"bigint\") date.setTime(Number(d));\n            else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        return date;\n    }\n    if (value.$code != null) {\n        const copy = Object.assign({}, value);\n        if (value.$scope) {\n            copy.$scope = deserializeValue(value.$scope);\n        }\n        return Code.fromExtendedJSON(value);\n    }\n    if (isDBRefLike(value) || value.$dbPointer) {\n        const v = value.$ref ? value : value.$dbPointer;\n        if (v instanceof DBRef) return v;\n        const dollarKeys = Object.keys(v).filter((k)=>k.startsWith(\"$\"));\n        let valid = true;\n        dollarKeys.forEach((k)=>{\n            if ([\n                \"$ref\",\n                \"$id\",\n                \"$db\"\n            ].indexOf(k) === -1) valid = false;\n        });\n        if (valid) return DBRef.fromExtendedJSON(v);\n    }\n    return value;\n}\nfunction serializeArray(array, options) {\n    return array.map((v, index)=>{\n        options.seenObjects.push({\n            propertyName: `index ${index}`,\n            obj: null\n        });\n        try {\n            return serializeValue(v, options);\n        } finally{\n            options.seenObjects.pop();\n        }\n    });\n}\nfunction getISOString(date) {\n    const isoStr = date.toISOString();\n    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + \"Z\";\n}\nfunction serializeValue(value, options) {\n    if (value instanceof Map || isMap(value)) {\n        const obj = Object.create(null);\n        for (const [k, v] of value){\n            if (typeof k !== \"string\") {\n                throw new BSONError(\"Can only serialize maps with string keys\");\n            }\n            obj[k] = v;\n        }\n        return serializeValue(obj, options);\n    }\n    if ((typeof value === \"object\" || typeof value === \"function\") && value !== null) {\n        const index = options.seenObjects.findIndex((entry)=>entry.obj === value);\n        if (index !== -1) {\n            const props = options.seenObjects.map((entry)=>entry.propertyName);\n            const leadingPart = props.slice(0, index).map((prop)=>`${prop} -> `).join(\"\");\n            const alreadySeen = props[index];\n            const circularPart = \" -> \" + props.slice(index + 1, props.length - 1).map((prop)=>`${prop} -> `).join(\"\");\n            const current = props[props.length - 1];\n            const leadingSpace = \" \".repeat(leadingPart.length + alreadySeen.length / 2);\n            const dashes = \"-\".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n            throw new BSONError(\"Converting circular structure to EJSON:\\n\" + `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` + `    ${leadingSpace}\\\\${dashes}/`);\n        }\n        options.seenObjects[options.seenObjects.length - 1].obj = value;\n    }\n    if (Array.isArray(value)) return serializeArray(value, options);\n    if (value === undefined) return null;\n    if (value instanceof Date || isDate(value)) {\n        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;\n        if (options.legacy) {\n            return options.relaxed && inRange ? {\n                $date: value.getTime()\n            } : {\n                $date: getISOString(value)\n            };\n        }\n        return options.relaxed && inRange ? {\n            $date: getISOString(value)\n        } : {\n            $date: {\n                $numberLong: value.getTime().toString()\n            }\n        };\n    }\n    if (typeof value === \"number\" && (!options.relaxed || !isFinite(value))) {\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                return {\n                    $numberInt: value.toString()\n                };\n            }\n            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {\n                return {\n                    $numberLong: value.toString()\n                };\n            }\n        }\n        return {\n            $numberDouble: Object.is(value, -0) ? \"-0.0\" : value.toString()\n        };\n    }\n    if (typeof value === \"bigint\") {\n        if (!options.relaxed) {\n            return {\n                $numberLong: BigInt.asIntN(64, value).toString()\n            };\n        }\n        return Number(BigInt.asIntN(64, value));\n    }\n    if (value instanceof RegExp || isRegExp(value)) {\n        let flags = value.flags;\n        if (flags === undefined) {\n            const match = value.toString().match(/[gimuy]*$/);\n            if (match) {\n                flags = match[0];\n            }\n        }\n        const rx = new BSONRegExp(value.source, flags);\n        return rx.toExtendedJSON(options);\n    }\n    if (value != null && typeof value === \"object\") return serializeDocument(value, options);\n    return value;\n}\nconst BSON_TYPE_MAPPINGS = {\n    Binary: (o)=>new Binary(o.value(), o.sub_type),\n    Code: (o)=>new Code(o.code, o.scope),\n    DBRef: (o)=>new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),\n    Decimal128: (o)=>new Decimal128(o.bytes),\n    Double: (o)=>new Double(o.value),\n    Int32: (o)=>new Int32(o.value),\n    Long: (o)=>Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),\n    MaxKey: ()=>new MaxKey(),\n    MinKey: ()=>new MinKey(),\n    ObjectId: (o)=>new ObjectId(o),\n    BSONRegExp: (o)=>new BSONRegExp(o.pattern, o.options),\n    BSONSymbol: (o)=>new BSONSymbol(o.value),\n    Timestamp: (o)=>Timestamp.fromBits(o.low, o.high)\n};\nfunction serializeDocument(doc, options) {\n    if (doc == null || typeof doc !== \"object\") throw new BSONError(\"not an object instance\");\n    const bsontype = doc._bsontype;\n    if (typeof bsontype === \"undefined\") {\n        const _doc = {};\n        for (const name of Object.keys(doc)){\n            options.seenObjects.push({\n                propertyName: name,\n                obj: null\n            });\n            try {\n                const value = serializeValue(doc[name], options);\n                if (name === \"__proto__\") {\n                    Object.defineProperty(_doc, name, {\n                        value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                } else {\n                    _doc[name] = value;\n                }\n            } finally{\n                options.seenObjects.pop();\n            }\n        }\n        return _doc;\n    } else if (doc != null && typeof doc === \"object\" && typeof doc._bsontype === \"string\" && doc[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n    } else if (isBSONType(doc)) {\n        let outDoc = doc;\n        if (typeof outDoc.toExtendedJSON !== \"function\") {\n            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n            if (!mapper) {\n                throw new BSONError(\"Unrecognized or invalid _bsontype: \" + doc._bsontype);\n            }\n            outDoc = mapper(outDoc);\n        }\n        if (bsontype === \"Code\" && outDoc.scope) {\n            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n        } else if (bsontype === \"DBRef\" && outDoc.oid) {\n            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n        }\n        return outDoc.toExtendedJSON(options);\n    } else {\n        throw new BSONError(\"_bsontype must be a string, but was: \" + typeof bsontype);\n    }\n}\nfunction parse(text, options) {\n    const ejsonOptions = {\n        useBigInt64: options?.useBigInt64 ?? false,\n        relaxed: options?.relaxed ?? true,\n        legacy: options?.legacy ?? false\n    };\n    return JSON.parse(text, (key, value)=>{\n        if (key.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);\n        }\n        return deserializeValue(value, ejsonOptions);\n    });\n}\nfunction stringify(value, replacer, space, options) {\n    if (space != null && typeof space === \"object\") {\n        options = space;\n        space = 0;\n    }\n    if (replacer != null && typeof replacer === \"object\" && !Array.isArray(replacer)) {\n        options = replacer;\n        replacer = undefined;\n        space = 0;\n    }\n    const serializeOptions = Object.assign({\n        relaxed: true,\n        legacy: false\n    }, options, {\n        seenObjects: [\n            {\n                propertyName: \"(root)\",\n                obj: null\n            }\n        ]\n    });\n    const doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n}\nfunction EJSONserialize(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n}\nfunction EJSONdeserialize(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n}\nconst EJSON = Object.create(null);\nEJSON.parse = parse;\nEJSON.stringify = stringify;\nEJSON.serialize = EJSONserialize;\nEJSON.deserialize = EJSONdeserialize;\nObject.freeze(EJSON);\nconst MAXSIZE = 1024 * 1024 * 17;\nlet buffer = ByteUtils.allocate(MAXSIZE);\nfunction setInternalBufferSize(size) {\n    if (buffer.length < size) {\n        buffer = ByteUtils.allocate(size);\n    }\n}\nfunction serialize(object, options = {}) {\n    const checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    const minInternalBufferSize = typeof options.minInternalBufferSize === \"number\" ? options.minInternalBufferSize : MAXSIZE;\n    if (buffer.length < minInternalBufferSize) {\n        buffer = ByteUtils.allocate(minInternalBufferSize);\n    }\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    const finishedBuffer = ByteUtils.allocate(serializationIndex);\n    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);\n    return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options = {}) {\n    const checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    const startIndex = typeof options.index === \"number\" ? options.index : 0;\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);\n    return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer, options = {}) {\n    return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);\n}\nfunction calculateObjectSize(object, options = {}) {\n    options = options || {};\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n    const internalOptions = Object.assign({\n        allowObjectSmallerThanBufferSize: true,\n        index: 0\n    }, options);\n    const bufferData = ByteUtils.toLocalBufferType(data);\n    let index = startIndex;\n    for(let i = 0; i < numberOfDocuments; i++){\n        const size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;\n        internalOptions.index = index;\n        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);\n        index = index + size;\n    }\n    return index;\n}\nvar bson = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BSONError: BSONError,\n    BSONRegExp: BSONRegExp,\n    BSONRuntimeError: BSONRuntimeError,\n    BSONSymbol: BSONSymbol,\n    BSONType: BSONType,\n    BSONValue: BSONValue,\n    BSONVersionError: BSONVersionError,\n    Binary: Binary,\n    Code: Code,\n    DBRef: DBRef,\n    Decimal128: Decimal128,\n    Double: Double,\n    EJSON: EJSON,\n    Int32: Int32,\n    Long: Long,\n    MaxKey: MaxKey,\n    MinKey: MinKey,\n    ObjectId: ObjectId,\n    Timestamp: Timestamp,\n    UUID: UUID,\n    calculateObjectSize: calculateObjectSize,\n    deserialize: deserialize,\n    deserializeStream: deserializeStream,\n    serialize: serialize,\n    serializeWithBufferAndIndex: serializeWithBufferAndIndex,\n    setInternalBufferSize: setInternalBufferSize\n});\nexports.BSON = bson;\nexports.BSONError = BSONError;\nexports.BSONRegExp = BSONRegExp;\nexports.BSONRuntimeError = BSONRuntimeError;\nexports.BSONSymbol = BSONSymbol;\nexports.BSONType = BSONType;\nexports.BSONValue = BSONValue;\nexports.BSONVersionError = BSONVersionError;\nexports.Binary = Binary;\nexports.Code = Code;\nexports.DBRef = DBRef;\nexports.Decimal128 = Decimal128;\nexports.Double = Double;\nexports.EJSON = EJSON;\nexports.Int32 = Int32;\nexports.Long = Long;\nexports.MaxKey = MaxKey;\nexports.MinKey = MinKey;\nexports.ObjectId = ObjectId;\nexports.Timestamp = Timestamp;\nexports.UUID = UUID;\nexports.calculateObjectSize = calculateObjectSize;\nexports.deserialize = deserialize;\nexports.deserializeStream = deserializeStream;\nexports.serialize = serialize;\nexports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;\nexports.setInternalBufferSize = setInternalBufferSize; //# sourceMappingURL=bson.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYnNvbi9saWIvYnNvbi5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxTQUFTQSxpQkFBaUJDLEtBQUs7SUFDM0IsT0FBTztRQUFDO1FBQXdCO0tBQTZCLENBQUNDLFFBQVEsQ0FBQ0MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0w7QUFDMUc7QUFDQSxTQUFTTSxhQUFhTixLQUFLO0lBQ3ZCLE9BQU9FLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNMLFdBQVc7QUFDckQ7QUFDQSxTQUFTTyxTQUFTQyxDQUFDO0lBQ2YsT0FBT04sT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0csT0FBTztBQUNqRDtBQUNBLFNBQVNDLE1BQU1ELENBQUM7SUFDWixPQUFPTixPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRyxPQUFPO0FBQ2pEO0FBQ0EsU0FBU0UsT0FBT0YsQ0FBQztJQUNiLE9BQU9OLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNHLE9BQU87QUFDakQ7QUFDQSxTQUFTRyxlQUFlQyxDQUFDLEVBQUVDLFFBQVE7SUFDL0IsT0FBT0MsS0FBS0MsU0FBUyxDQUFDSCxHQUFHLENBQUNJLEdBQUdDO1FBQ3pCLElBQUksT0FBT0EsTUFBTSxVQUFVO1lBQ3ZCLE9BQU87Z0JBQUVDLGFBQWEsQ0FBQyxFQUFFRCxFQUFFLENBQUM7WUFBQztRQUNqQyxPQUNLLElBQUlSLE1BQU1RLElBQUk7WUFDZixPQUFPZixPQUFPaUIsV0FBVyxDQUFDRjtRQUM5QjtRQUNBLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLFNBQVNHLG1CQUFtQkMsT0FBTztJQUMvQixNQUFNQyxnQkFBZ0JELFdBQVcsUUFDN0IsT0FBT0EsWUFBWSxZQUNuQixhQUFhQSxXQUNiLE9BQU9BLFFBQVFFLE9BQU8sS0FBSztJQUMvQixJQUFJRCxlQUFlO1FBQ2YsT0FBT0QsUUFB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QyxVQUFVLEVBQUVBLEtBQUs3RyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUM7QUFDSjtBQUVBLElBQUkrRyxPQUFPbE47QUFDWCxJQUFJO0lBQ0FrTixPQUFPLElBQUlDLFlBQVlDLFFBQVEsQ0FBQyxJQUFJRCxZQUFZRSxNQUFNLENBQUMsSUFBSTdILFdBQVc7UUFBQztRQUFHO1FBQUk7UUFBSztRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFHO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFHO1FBQUc7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FB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QixHQUFHcU07QUFDckJyTSxjQUFjLEdBQUd1UDtBQUNqQnZQLGFBQWEsR0FBR29lO0FBQ2hCcGUsYUFBYSxHQUFHaVE7QUFDaEJqUSxZQUFZLEdBQUdVO0FBQ2ZWLGNBQWMsR0FBR21RO0FBQ2pCblEsY0FBYyxHQUFHcVE7QUFDakJyUSxnQkFBZ0IsR0FBRzJRO0FBQ25CM1EsaUJBQWlCLEdBQUd3VDtBQUNwQnhULFlBQVksR0FBRy9EO0FBQ2YrRCwyQkFBMkIsR0FBRzhlO0FBQzlCOWUsbUJBQW1CLEdBQUdzZTtBQUN0QnRlLHlCQUF5QixHQUFHK2U7QUFDNUIvZSxpQkFBaUIsR0FBR3FlO0FBQ3BCcmUsbUNBQW1DLEdBQUc0ZTtBQUN0QzVlLDZCQUE2QixHQUFHd2UsdUJBQ2hDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Jsb2ctYXBwbGljYXRpb24vLi9ub2RlX21vZHVsZXMvYnNvbi9saWIvYnNvbi5janM/M2ZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gWydbb2JqZWN0IEFycmF5QnVmZmVyXScsICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSddLmluY2x1ZGVzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJztcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwKGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmZ1bmN0aW9uIGlzTWFwKGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZnVuY3Rpb24gZGVmYXVsdEluc3BlY3QoeCwgX29wdGlvbnMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCwgKGssIHYpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckxvbmc6IGAke3Z9YCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWFwKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3R5bGl6ZUZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsaXplRXhpc3RzID0gb3B0aW9ucyAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnc3R5bGl6ZScgaW4gb3B0aW9ucyAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zdHlsaXplID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChzdHlsaXplRXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnN0eWxpemU7XG4gICAgfVxufVxuXG5jb25zdCBCU09OX01BSk9SX1ZFUlNJT04gPSA2O1xuY29uc3QgQlNPTl9JTlQzMl9NQVggPSAweDdmZmZmZmZmO1xuY29uc3QgQlNPTl9JTlQzMl9NSU4gPSAtMHg4MDAwMDAwMDtcbmNvbnN0IEJTT05fSU5UNjRfTUFYID0gTWF0aC5wb3coMiwgNjMpIC0gMTtcbmNvbnN0IEJTT05fSU5UNjRfTUlOID0gLU1hdGgucG93KDIsIDYzKTtcbmNvbnN0IEpTX0lOVF9NQVggPSBNYXRoLnBvdygyLCA1Myk7XG5jb25zdCBKU19JTlRfTUlOID0gLU1hdGgucG93KDIsIDUzKTtcbmNvbnN0IEJTT05fREFUQV9OVU1CRVIgPSAxO1xuY29uc3QgQlNPTl9EQVRBX1NUUklORyA9IDI7XG5jb25zdCBCU09OX0RBVEFfT0JKRUNUID0gMztcbmNvbnN0IEJTT05fREFUQV9BUlJBWSA9IDQ7XG5jb25zdCBCU09OX0RBVEFfQklOQVJZID0gNTtcbmNvbnN0IEJTT05fREFUQV9VTkRFRklORUQgPSA2O1xuY29uc3QgQlNPTl9EQVRBX09JRCA9IDc7XG5jb25zdCBCU09OX0RBVEFfQk9PTEVBTiA9IDg7XG5jb25zdCBCU09OX0RBVEFfREFURSA9IDk7XG5jb25zdCBCU09OX0RBVEFfTlVMTCA9IDEwO1xuY29uc3QgQlNPTl9EQVRBX1JFR0VYUCA9IDExO1xuY29uc3QgQlNPTl9EQVRBX0RCUE9JTlRFUiA9IDEyO1xuY29uc3QgQlNPTl9EQVRBX0NPREUgPSAxMztcbmNvbnN0IEJTT05fREFUQV9TWU1CT0wgPSAxNDtcbmNvbnN0IEJTT05fREFUQV9DT0RFX1dfU0NPUEUgPSAxNTtcbmNvbnN0IEJTT05fREFUQV9JTlQgPSAxNjtcbmNvbnN0IEJTT05fREFUQV9USU1FU1RBTVAgPSAxNztcbmNvbnN0IEJTT05fREFUQV9MT05HID0gMTg7XG5jb25zdCBCU09OX0RBVEFfREVDSU1BTDEyOCA9IDE5O1xuY29uc3QgQlNPTl9EQVRBX01JTl9LRVkgPSAweGZmO1xuY29uc3QgQlNPTl9EQVRBX01BWF9LRVkgPSAweDdmO1xuY29uc3QgQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUID0gMDtcbmNvbnN0IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgPSA0O1xuY29uc3QgQlNPTlR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBkb3VibGU6IDEsXG4gICAgc3RyaW5nOiAyLFxuICAgIG9iamVjdDogMyxcbiAgICBhcnJheTogNCxcbiAgICBiaW5EYXRhOiA1LFxuICAgIHVuZGVmaW5lZDogNixcbiAgICBvYmplY3RJZDogNyxcbiAgICBib29sOiA4LFxuICAgIGRhdGU6IDksXG4gICAgbnVsbDogMTAsXG4gICAgcmVnZXg6IDExLFxuICAgIGRiUG9pbnRlcjogMTIsXG4gICAgamF2YXNjcmlwdDogMTMsXG4gICAgc3ltYm9sOiAxNCxcbiAgICBqYXZhc2NyaXB0V2l0aFNjb3BlOiAxNSxcbiAgICBpbnQ6IDE2LFxuICAgIHRpbWVzdGFtcDogMTcsXG4gICAgbG9uZzogMTgsXG4gICAgZGVjaW1hbDogMTksXG4gICAgbWluS2V5OiAtMSxcbiAgICBtYXhLZXk6IDEyN1xufSk7XG5cbmNsYXNzIEJTT05FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgYnNvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQlNPTkVycm9yJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQlNPTkVycm9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2Jzb25FcnJvcicgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgIHZhbHVlLmJzb25FcnJvciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgJ25hbWUnIGluIHZhbHVlICYmXG4gICAgICAgICAgICAnbWVzc2FnZScgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgICdzdGFjaycgaW4gdmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIEJTT05WZXJzaW9uRXJyb3IgZXh0ZW5kcyBCU09ORXJyb3Ige1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05WZXJzaW9uRXJyb3InO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYFVuc3VwcG9ydGVkIEJTT04gdmVyc2lvbiwgYnNvbiB0eXBlcyBtdXN0IGJlIGZyb20gYnNvbiAke0JTT05fTUFKT1JfVkVSU0lPTn0ueC54YCk7XG4gICAgfVxufVxuY2xhc3MgQlNPTlJ1bnRpbWVFcnJvciBleHRlbmRzIEJTT05FcnJvciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQlNPTlJ1bnRpbWVFcnJvcic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub2RlanNNYXRoUmFuZG9tQnl0ZXMoYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KEFycmF5LmZyb20oeyBsZW5ndGg6IGJ5dGVMZW5ndGggfSwgKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSkpO1xufVxuY29uc3Qgbm9kZWpzUmFuZG9tQnl0ZXMgPSAoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcztcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gbm9kZWpzTWF0aFJhbmRvbUJ5dGVzO1xuICAgIH1cbn0pKCk7XG5jb25zdCBub2RlSnNCeXRlVXRpbHMgPSB7XG4gICAgdG9Mb2NhbEJ1ZmZlclR5cGUocG90ZW50aWFsQnVmZmVyKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocG90ZW50aWFsQnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvdGVudGlhbEJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBvdGVudGlhbEJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShwb3RlbnRpYWxCdWZmZXIuYnVmZmVyLCBwb3RlbnRpYWxCdWZmZXIuYnl0ZU9mZnNldCwgcG90ZW50aWFsQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmluZ1RhZyA9IHBvdGVudGlhbEJ1ZmZlcj8uW1N5bWJvbC50b1N0cmluZ1RhZ10gPz8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBvdGVudGlhbEJ1ZmZlcik7XG4gICAgICAgIGlmIChzdHJpbmdUYWcgPT09ICdBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1NoYXJlZEFycmF5QnVmZmVyJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShwb3RlbnRpYWxCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYENhbm5vdCBjcmVhdGUgQnVmZmVyIGZyb20gJHtTdHJpbmcocG90ZW50aWFsQnVmZmVyKX1gKTtcbiAgICB9LFxuICAgIGFsbG9jYXRlKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgICB9LFxuICAgIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYSkuZXF1YWxzKGIpO1xuICAgIH0sXG4gICAgZnJvbU51bWJlckFycmF5KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnJheSk7XG4gICAgfSxcbiAgICBmcm9tQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYmFzZTY0LCAnYmFzZTY0Jyk7XG4gICAgfSxcbiAgICB0b0Jhc2U2NChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9LFxuICAgIGZyb21JU084ODU5MShjb2RlUG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShjb2RlUG9pbnRzLCAnYmluYXJ5Jyk7XG4gICAgfSxcbiAgICB0b0lTTzg4NTkxKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcikudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIH0sXG4gICAgZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xuICAgIH0sXG4gICAgdG9IZXgoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgfSxcbiAgICBmcm9tVVRGOCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0ZXh0LCAndXRmOCcpO1xuICAgIH0sXG4gICAgdG9VVEY4KGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcikudG9TdHJpbmcoJ3V0ZjgnLCBzdGFydCwgZW5kKTtcbiAgICB9LFxuICAgIHV0ZjhCeXRlTGVuZ3RoKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChpbnB1dCwgJ3V0ZjgnKTtcbiAgICB9LFxuICAgIGVuY29kZVVURjhJbnRvKGJ1ZmZlciwgc291cmNlLCBieXRlT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKS53cml0ZShzb3VyY2UsIGJ5dGVPZmZzZXQsIHVuZGVmaW5lZCwgJ3V0ZjgnKTtcbiAgICB9LFxuICAgIHJhbmRvbUJ5dGVzOiBub2RlanNSYW5kb21CeXRlc1xufTtcblxuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcbiAgICBjb25zdCB7IG5hdmlnYXRvciB9ID0gZ2xvYmFsVGhpcztcbiAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSc7XG59XG5mdW5jdGlvbiB3ZWJNYXRoUmFuZG9tQnl0ZXMoYnl0ZUxlbmd0aCkge1xuICAgIGlmIChieXRlTGVuZ3RoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlIGFyZ3VtZW50ICdieXRlTGVuZ3RoJyBpcyBpbnZhbGlkLiBSZWNlaXZlZCAke2J5dGVMZW5ndGh9YCk7XG4gICAgfVxuICAgIHJldHVybiB3ZWJCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KEFycmF5LmZyb20oeyBsZW5ndGg6IGJ5dGVMZW5ndGggfSwgKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSkpO1xufVxuY29uc3Qgd2ViUmFuZG9tQnl0ZXMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3J5cHRvIH0gPSBnbG9iYWxUaGlzO1xuICAgIGlmIChjcnlwdG8gIT0gbnVsbCAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gKGJ5dGVMZW5ndGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHdlYkJ5dGVVdGlscy5hbGxvY2F0ZShieXRlTGVuZ3RoKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbnNvbGUgfSA9IGdsb2JhbFRoaXM7XG4gICAgICAgICAgICBjb25zb2xlPy53YXJuPy4oJ0JTT046IEZvciBSZWFjdCBOYXRpdmUgcGxlYXNlIHBvbHlmaWxsIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMsIGUuZy4gdXNpbmc6IGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlYWN0LW5hdGl2ZS1nZXQtcmFuZG9tLXZhbHVlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2ViTWF0aFJhbmRvbUJ5dGVzO1xuICAgIH1cbn0pKCk7XG5jb25zdCBIRVhfRElHSVQgPSAvKFxcZHxbYS1mXSkvaTtcbmNvbnN0IHdlYkJ5dGVVdGlscyA9IHtcbiAgICB0b0xvY2FsQnVmZmVyVHlwZShwb3RlbnRpYWxVaW50OGFycmF5KSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ1RhZyA9IHBvdGVudGlhbFVpbnQ4YXJyYXk/LltTeW1ib2wudG9TdHJpbmdUYWddID8/XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocG90ZW50aWFsVWludDhhcnJheSk7XG4gICAgICAgIGlmIChzdHJpbmdUYWcgPT09ICdVaW50OEFycmF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHBvdGVudGlhbFVpbnQ4YXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwb3RlbnRpYWxVaW50OGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHBvdGVudGlhbFVpbnQ4YXJyYXkuYnVmZmVyLnNsaWNlKHBvdGVudGlhbFVpbnQ4YXJyYXkuYnl0ZU9mZnNldCwgcG90ZW50aWFsVWludDhhcnJheS5ieXRlT2Zmc2V0ICsgcG90ZW50aWFsVWludDhhcnJheS5ieXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZ1RhZyA9PT0gJ0FycmF5QnVmZmVyJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnU2hhcmVkQXJyYXlCdWZmZXInIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHBvdGVudGlhbFVpbnQ4YXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYENhbm5vdCBtYWtlIGEgVWludDhBcnJheSBmcm9tICR7U3RyaW5nKHBvdGVudGlhbFVpbnQ4YXJyYXkpfWApO1xuICAgIH0sXG4gICAgYWxsb2NhdGUoc2l6ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgJHtTdHJpbmcoc2l6ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH0sXG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBmcm9tTnVtYmVyQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhcnJheSk7XG4gICAgfSxcbiAgICBmcm9tQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoYmFzZTY0KSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH0sXG4gICAgdG9CYXNlNjQodWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gYnRvYSh3ZWJCeXRlVXRpbHMudG9JU084ODU5MSh1aW50OGFycmF5KSk7XG4gICAgfSxcbiAgICBmcm9tSVNPODg1OTEoY29kZVBvaW50cykge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvZGVQb2ludHMsIGMgPT4gYy5jaGFyQ29kZUF0KDApICYgMHhmZik7XG4gICAgfSxcbiAgICB0b0lTTzg4NTkxKHVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oVWludDE2QXJyYXkuZnJvbSh1aW50OGFycmF5KSwgYiA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKS5qb2luKCcnKTtcbiAgICB9LFxuICAgIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGNvbnN0IGV2ZW5MZW5ndGhIZXggPSBoZXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleCA6IGhleC5zbGljZSgwLCBoZXgubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW5MZW5ndGhIZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGlnaXQgPSBldmVuTGVuZ3RoSGV4W2ldO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kRGlnaXQgPSBldmVuTGVuZ3RoSGV4W2kgKyAxXTtcbiAgICAgICAgICAgIGlmICghSEVYX0RJR0lULnRlc3QoZmlyc3REaWdpdCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSEVYX0RJR0lULnRlc3Qoc2Vjb25kRGlnaXQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZXhEaWdpdCA9IE51bWJlci5wYXJzZUludChgJHtmaXJzdERpZ2l0fSR7c2Vjb25kRGlnaXR9YCwgMTYpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goaGV4RGlnaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmZmVyKTtcbiAgICB9LFxuICAgIHRvSGV4KHVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odWludDhhcnJheSwgYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICB9LFxuICAgIGZyb21VVEY4KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KTtcbiAgICB9LFxuICAgIHRvVVRGOCh1aW50OGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGZhdGFsOiBmYWxzZSB9KS5kZWNvZGUodWludDhhcnJheS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgfSxcbiAgICB1dGY4Qnl0ZUxlbmd0aChpbnB1dCkge1xuICAgICAgICByZXR1cm4gd2ViQnl0ZVV0aWxzLmZyb21VVEY4KGlucHV0KS5ieXRlTGVuZ3RoO1xuICAgIH0sXG4gICAgZW5jb2RlVVRGOEludG8oYnVmZmVyLCBzb3VyY2UsIGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB3ZWJCeXRlVXRpbHMuZnJvbVVURjgoc291cmNlKTtcbiAgICAgICAgYnVmZmVyLnNldChieXRlcywgYnl0ZU9mZnNldCk7XG4gICAgICAgIHJldHVybiBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IHdlYlJhbmRvbUJ5dGVzXG59O1xuXG5jb25zdCBoYXNHbG9iYWxCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5wcm90b3R5cGU/Ll9pc0J1ZmZlciAhPT0gdHJ1ZTtcbmNvbnN0IEJ5dGVVdGlscyA9IGhhc0dsb2JhbEJ1ZmZlciA/IG5vZGVKc0J5dGVVdGlscyA6IHdlYkJ5dGVVdGlscztcbmNsYXNzIEJTT05EYXRhVmlldyBleHRlbmRzIERhdGFWaWV3IHtcbiAgICBzdGF0aWMgZnJvbVVpbnQ4QXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhpbnB1dC5idWZmZXIsIGlucHV0LmJ5dGVPZmZzZXQsIGlucHV0LmJ5dGVMZW5ndGgpO1xuICAgIH1cbn1cblxuY2xhc3MgQlNPTlZhbHVlIHtcbiAgICBnZXQgW1N5bWJvbC5mb3IoJ0BAbWRiLmJzb24udmVyc2lvbicpXSgpIHtcbiAgICAgICAgcmV0dXJuIEJTT05fTUFKT1JfVkVSU0lPTjtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpO1xuICAgIH1cbn1cblxuY2xhc3MgQmluYXJ5IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JpbmFyeSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgc3ViVHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIShidWZmZXIgPT0gbnVsbCkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAhQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikgJiZcbiAgICAgICAgICAgICFpc0FueUFycmF5QnVmZmVyKGJ1ZmZlcikgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSBjYW4gb25seSBiZSBjb25zdHJ1Y3RlZCBmcm9tIFVpbnQ4QXJyYXkgb3IgbnVtYmVyW10nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1Yl90eXBlID0gc3ViVHlwZSA/PyBCaW5hcnkuQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUO1xuICAgICAgICBpZiAoYnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKEJpbmFyeS5CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQXJyYXkuaXNBcnJheShidWZmZXIpXG4gICAgICAgICAgICAgICAgPyBCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KGJ1ZmZlcilcbiAgICAgICAgICAgICAgICA6IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0KGJ5dGVWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGJ5dGVWYWx1ZSA9PT0gJ3N0cmluZycgJiYgYnl0ZVZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignb25seSBhY2NlcHRzIHNpbmdsZSBjaGFyYWN0ZXIgU3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ5dGVWYWx1ZSAhPT0gJ251bWJlcicgJiYgYnl0ZVZhbHVlLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ29ubHkgYWNjZXB0cyBzaW5nbGUgY2hhcmFjdGVyIFVpbnQ4QXJyYXkgb3IgQXJyYXknKTtcbiAgICAgICAgbGV0IGRlY29kZWRCeXRlO1xuICAgICAgICBpZiAodHlwZW9mIGJ5dGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRlY29kZWRCeXRlID0gYnl0ZVZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ5dGVWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRlY29kZWRCeXRlID0gYnl0ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVjb2RlZEJ5dGUgPSBieXRlVmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY29kZWRCeXRlIDwgMCB8fCBkZWNvZGVkQnl0ZSA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignb25seSBhY2NlcHRzIG51bWJlciBpbiBhIHZhbGlkIHVuc2lnbmVkIGJ5dGUgcmFuZ2UgMC0yNTUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCA+IHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBkZWNvZGVkQnl0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NwYWNlID0gQnl0ZVV0aWxzLmFsbG9jYXRlKEJpbmFyeS5CVUZGRVJfU0laRSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdTcGFjZS5zZXQodGhpcy5idWZmZXIsIDApO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdTcGFjZTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBkZWNvZGVkQnl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZShzZXF1ZW5jZSwgb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggPCBvZmZzZXQgKyBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NwYWNlID0gQnl0ZVV0aWxzLmFsbG9jYXRlKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggKyBzZXF1ZW5jZS5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3U3BhY2Uuc2V0KHRoaXMuYnVmZmVyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3U3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnNldChCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoc2VxdWVuY2UpLCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICsgc2VxdWVuY2UuYnl0ZUxlbmd0aCA+IHRoaXMucG9zaXRpb24gPyBvZmZzZXQgKyBzZXF1ZW5jZS5sZW5ndGggOiB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZXF1ZW5jZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2lucHV0IGNhbm5vdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkKHBvc2l0aW9uLCBsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggOiB0aGlzLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IHRoaXMucG9zaXRpb25cbiAgICAgICAgICAgID8gdGhpcy5idWZmZXJcbiAgICAgICAgICAgIDogdGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbik7XG4gICAgfVxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9VVEY4KHRoaXMuYnVmZmVyLCAwLCB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b1VURjgodGhpcy5idWZmZXIsIDAsIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIpO1xuICAgICAgICBjb25zdCBzdWJUeXBlID0gTnVtYmVyKHRoaXMuc3ViX3R5cGUpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICRiaW5hcnk6IGJhc2U2NFN0cmluZyxcbiAgICAgICAgICAgICAgICAkdHlwZTogc3ViVHlwZS5sZW5ndGggPT09IDEgPyAnMCcgKyBzdWJUeXBlIDogc3ViVHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGJpbmFyeToge1xuICAgICAgICAgICAgICAgIGJhc2U2NDogYmFzZTY0U3RyaW5nLFxuICAgICAgICAgICAgICAgIHN1YlR5cGU6IHN1YlR5cGUubGVuZ3RoID09PSAxID8gJzAnICsgc3ViVHlwZSA6IHN1YlR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9VVUlEKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfVVVJRCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVVUlEKHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCaW5hcnkgc3ViX3R5cGUgXCIke3RoaXMuc3ViX3R5cGV9XCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgY29udmVydGluZyB0byBVVUlELiBPbmx5IFwiJHtCaW5hcnkuU1VCVFlQRV9VVUlEfVwiIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSGV4U3RyaW5nKGhleCwgc3ViVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShCeXRlVXRpbHMuZnJvbUhleChoZXgpLCBzdWJUeXBlKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0LCBzdWJUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5KEJ5dGVVdGlscy5mcm9tQmFzZTY0KGJhc2U2NCksIHN1YlR5cGUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgaWYgKCckYmluYXJ5JyBpbiBkb2MpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSAmJiB0eXBlb2YgZG9jLiRiaW5hcnkgPT09ICdzdHJpbmcnICYmICckdHlwZScgaW4gZG9jKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGRvYy4kdHlwZSA/IHBhcnNlSW50KGRvYy4kdHlwZSwgMTYpIDogMDtcbiAgICAgICAgICAgICAgICBkYXRhID0gQnl0ZVV0aWxzLmZyb21CYXNlNjQoZG9jLiRiaW5hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2MuJGJpbmFyeSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGRvYy4kYmluYXJ5LnN1YlR5cGUgPyBwYXJzZUludChkb2MuJGJpbmFyeS5zdWJUeXBlLCAxNikgOiAwO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gQnl0ZVV0aWxzLmZyb21CYXNlNjQoZG9jLiRiaW5hcnkuYmFzZTY0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJyR1dWlkJyBpbiBkb2MpIHtcbiAgICAgICAgICAgIHR5cGUgPSA0O1xuICAgICAgICAgICAgZGF0YSA9IFVVSUQuYnl0ZXNGcm9tU3RyaW5nKGRvYy4kdXVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbmV4cGVjdGVkIEJpbmFyeSBFeHRlbmRlZCBKU09OIGZvcm1hdCAke0pTT04uc3RyaW5naWZ5KGRvYyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgPyBuZXcgVVVJRChkYXRhKSA6IG5ldyBCaW5hcnkoZGF0YSwgdHlwZSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSk7XG4gICAgICAgIGNvbnN0IGJhc2U2NEFyZyA9IGluc3BlY3QoYmFzZTY0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3ViVHlwZUFyZyA9IGluc3BlY3QodGhpcy5zdWJfdHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBgQmluYXJ5LmNyZWF0ZUZyb21CYXNlNjQoJHtiYXNlNjRBcmd9LCAke3N1YlR5cGVBcmd9KWA7XG4gICAgfVxufVxuQmluYXJ5LkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVCA9IDA7XG5CaW5hcnkuQlVGRkVSX1NJWkUgPSAyNTY7XG5CaW5hcnkuU1VCVFlQRV9ERUZBVUxUID0gMDtcbkJpbmFyeS5TVUJUWVBFX0ZVTkNUSU9OID0gMTtcbkJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkgPSAyO1xuQmluYXJ5LlNVQlRZUEVfVVVJRF9PTEQgPSAzO1xuQmluYXJ5LlNVQlRZUEVfVVVJRCA9IDQ7XG5CaW5hcnkuU1VCVFlQRV9NRDUgPSA1O1xuQmluYXJ5LlNVQlRZUEVfRU5DUllQVEVEID0gNjtcbkJpbmFyeS5TVUJUWVBFX0NPTFVNTiA9IDc7XG5CaW5hcnkuU1VCVFlQRV9VU0VSX0RFRklORUQgPSAxMjg7XG5jb25zdCBVVUlEX0JZVEVfTEVOR1RIID0gMTY7XG5jb25zdCBVVUlEX1dJVEhPVVRfREFTSEVTID0gL15bMC05QS1GXXszMn0kL2k7XG5jb25zdCBVVUlEX1dJVEhfREFTSEVTID0gL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXsxMn0kL2k7XG5jbGFzcyBVVUlEIGV4dGVuZHMgQmluYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBsZXQgYnl0ZXM7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBieXRlcyA9IFVVSUQuZ2VuZXJhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIFVVSUQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKG5ldyBVaW50OEFycmF5KGlucHV0LmJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhpbnB1dCkgJiYgaW5wdXQuYnl0ZUxlbmd0aCA9PT0gVVVJRF9CWVRFX0xFTkdUSCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gVVVJRC5ieXRlc0Zyb21TdHJpbmcoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQXJndW1lbnQgcGFzc2VkIGluIFVVSUQgY29uc3RydWN0b3IgbXVzdCBiZSBhIFVVSUQsIGEgMTYgYnl0ZSBCdWZmZXIgb3IgYSAzMi8zNiBjaGFyYWN0ZXIgaGV4IHN0cmluZyAoZGFzaGVzIGV4Y2x1ZGVkL2luY2x1ZGVkLCBmb3JtYXQ6IHh4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYnl0ZXMsIEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcpO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICB9XG4gICAgc2V0IGlkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSGV4U3RyaW5nKGluY2x1ZGVEYXNoZXMgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlRGFzaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCA0KSksXG4gICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDQsIDYpKSxcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoNiwgOCkpLFxuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSg4LCAxMCkpLFxuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgxMCwgMTYpKVxuICAgICAgICAgICAgXS5qb2luKCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvSGV4KHRoaXMuaWQpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJJZCkge1xuICAgICAgICBpZiAoIW90aGVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJJZCBpbnN0YW5jZW9mIFVVSUQpIHtcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMuZXF1YWxzKG90aGVySWQuaWQsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmVxdWFscyhuZXcgVVVJRChvdGhlcklkKS5pZCwgdGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvQmluYXJ5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeSh0aGlzLmlkLCBCaW5hcnkuU1VCVFlQRV9VVUlEKTtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IEJ5dGVVdGlscy5yYW5kb21CeXRlcyhVVUlEX0JZVEVfTEVOR1RIKTtcbiAgICAgICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkKGlucHV0KSB7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFVVSUQuaXNWYWxpZFVVSURTdHJpbmcoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VpbnQ4QXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuYnl0ZUxlbmd0aCA9PT0gVVVJRF9CWVRFX0xFTkdUSDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGlucHV0Ll9ic29udHlwZSA9PT0gJ0JpbmFyeScgJiZcbiAgICAgICAgICAgIGlucHV0LnN1Yl90eXBlID09PSB0aGlzLlNVQlRZUEVfVVVJRCAmJlxuICAgICAgICAgICAgaW5wdXQuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDE2KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21IZXhTdHJpbmcoaGV4U3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFVVSUQuYnl0ZXNGcm9tU3RyaW5nKGhleFN0cmluZyk7XG4gICAgICAgIHJldHVybiBuZXcgVVVJRChidWZmZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVVUlEKEJ5dGVVdGlscy5mcm9tQmFzZTY0KGJhc2U2NCkpO1xuICAgIH1cbiAgICBzdGF0aWMgYnl0ZXNGcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIGlmICghVVVJRC5pc1ZhbGlkVVVJRFN0cmluZyhyZXByZXNlbnRhdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1VVSUQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG11c3QgYmUgMzIgaGV4IGRpZ2l0cyBvciBjYW5vbmljYWwgaHlwaGVuYXRlZCByZXByZXNlbnRhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMuZnJvbUhleChyZXByZXNlbnRhdGlvbi5yZXBsYWNlKC8tL2csICcnKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkVVVJRFN0cmluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gVVVJRF9XSVRIT1VUX0RBU0hFUy50ZXN0KHJlcHJlc2VudGF0aW9uKSB8fCBVVUlEX1dJVEhfREFTSEVTLnRlc3QocmVwcmVzZW50YXRpb24pO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICByZXR1cm4gYG5ldyBVVUlEKCR7aW5zcGVjdCh0aGlzLnRvSGV4U3RyaW5nKCksIG9wdGlvbnMpfSlgO1xuICAgIH1cbn1cblxuY2xhc3MgQ29kZSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdDb2RlJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29kZSwgc2NvcGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGUgPz8gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAodGhpcy5zY29wZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb2RlOiB0aGlzLmNvZGUsIHNjb3BlOiB0aGlzLnNjb3BlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29kZTogdGhpcy5jb2RlIH07XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJGNvZGU6IHRoaXMuY29kZSwgJHNjb3BlOiB0aGlzLnNjb3BlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJGNvZGU6IHRoaXMuY29kZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2RlKGRvYy4kY29kZSwgZG9jLiRzY29wZSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIGxldCBwYXJhbWV0ZXJzU3RyaW5nID0gaW5zcGVjdCh0aGlzLmNvZGUsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtdWx0aUxpbmVGbiA9IHBhcmFtZXRlcnNTdHJpbmcuaW5jbHVkZXMoJ1xcbicpO1xuICAgICAgICBpZiAodGhpcy5zY29wZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzU3RyaW5nICs9IGAsJHttdWx0aUxpbmVGbiA/ICdcXG4nIDogJyAnfSR7aW5zcGVjdCh0aGlzLnNjb3BlLCBvcHRpb25zKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZGluZ05ld2xpbmUgPSBtdWx0aUxpbmVGbiAmJiB0aGlzLnNjb3BlID09PSBudWxsO1xuICAgICAgICByZXR1cm4gYG5ldyBDb2RlKCR7bXVsdGlMaW5lRm4gPyAnXFxuJyA6ICcnfSR7cGFyYW1ldGVyc1N0cmluZ30ke2VuZGluZ05ld2xpbmUgPyAnXFxuJyA6ICcnfSlgO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNEQlJlZkxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnJGlkJyBpbiB2YWx1ZSAmJlxuICAgICAgICB2YWx1ZS4kaWQgIT0gbnVsbCAmJlxuICAgICAgICAnJHJlZicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLiRyZWYgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICghKCckZGInIGluIHZhbHVlKSB8fCAoJyRkYicgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLiRkYiA9PT0gJ3N0cmluZycpKSk7XG59XG5jbGFzcyBEQlJlZiBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdEQlJlZic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24sIG9pZCwgZGIsIGZpZWxkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGNvbGxlY3Rpb24uc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgZGIgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgY29sbGVjdGlvbiA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgICAgdGhpcy5vaWQgPSBvaWQ7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHMgfHwge307XG4gICAgfVxuICAgIGdldCBuYW1lc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb247XG4gICAgfVxuICAgIHNldCBuYW1lc3BhY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgbyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgJHJlZjogdGhpcy5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgJGlkOiB0aGlzLm9pZFxuICAgICAgICB9LCB0aGlzLmZpZWxkcyk7XG4gICAgICAgIGlmICh0aGlzLmRiICE9IG51bGwpXG4gICAgICAgICAgICBvLiRkYiA9IHRoaXMuZGI7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgbyA9IHtcbiAgICAgICAgICAgICRyZWY6IHRoaXMuY29sbGVjdGlvbixcbiAgICAgICAgICAgICRpZDogdGhpcy5vaWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYilcbiAgICAgICAgICAgIG8uJGRiID0gdGhpcy5kYjtcbiAgICAgICAgbyA9IE9iamVjdC5hc3NpZ24obywgdGhpcy5maWVsZHMpO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBkb2MpO1xuICAgICAgICBkZWxldGUgY29weS4kcmVmO1xuICAgICAgICBkZWxldGUgY29weS4kaWQ7XG4gICAgICAgIGRlbGV0ZSBjb3B5LiRkYjtcbiAgICAgICAgcmV0dXJuIG5ldyBEQlJlZihkb2MuJHJlZiwgZG9jLiRpZCwgZG9jLiRkYiwgY29weSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBpbnNwZWN0KHRoaXMubmFtZXNwYWNlLCBvcHRpb25zKSxcbiAgICAgICAgICAgIGluc3BlY3QodGhpcy5vaWQsIG9wdGlvbnMpLFxuICAgICAgICAgICAgLi4uKHRoaXMuZGIgPyBbaW5zcGVjdCh0aGlzLmRiLCBvcHRpb25zKV0gOiBbXSksXG4gICAgICAgICAgICAuLi4oT2JqZWN0LmtleXModGhpcy5maWVsZHMpLmxlbmd0aCA+IDAgPyBbaW5zcGVjdCh0aGlzLmZpZWxkcywgb3B0aW9ucyldIDogW10pXG4gICAgICAgIF07XG4gICAgICAgIGFyZ3NbMV0gPSBpbnNwZWN0ID09PSBkZWZhdWx0SW5zcGVjdCA/IGBuZXcgT2JqZWN0SWQoJHthcmdzWzFdfSlgIDogYXJnc1sxXTtcbiAgICAgICAgcmV0dXJuIGBuZXcgREJSZWYoJHthcmdzLmpvaW4oJywgJyl9KWA7XG4gICAgfVxufVxuXG5sZXQgd2FzbSA9IHVuZGVmaW5lZDtcbnRyeSB7XG4gICAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMV0pKSwge30pLmV4cG9ydHM7XG59XG5jYXRjaCB7XG59XG5jb25zdCBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG5jb25zdCBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG5jb25zdCBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG5jb25zdCBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcbmNvbnN0IElOVF9DQUNIRSA9IHt9O1xuY29uc3QgVUlOVF9DQUNIRSA9IHt9O1xuY29uc3QgTUFYX0lOVDY0X1NUUklOR19MRU5HVEggPSAyMDtcbmNvbnN0IERFQ0lNQUxfUkVHX0VYID0gL14oXFwrPzB8KFxcK3wtKT9bMS05XVswLTldKikkLztcbmNsYXNzIExvbmcgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnTG9uZyc7XG4gICAgfVxuICAgIGdldCBfX2lzTG9uZ19fKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobG93ID0gMCwgaGlnaCwgdW5zaWduZWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsb3cgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIExvbmcuZnJvbUJpZ0ludChsb3csICEhaGlnaCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3cgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIExvbmcuZnJvbVN0cmluZyhsb3csICEhaGlnaCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuICAgICAgICAgICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG4gICAgICAgICAgICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICAgICAgbGV0IG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gTG9uZy5mcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChjYWNoZSlcbiAgICAgICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gTG9uZy5mcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGUpXG4gICAgICAgICAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBMb25nLlVaRVJPIDogTG9uZy5aRVJPO1xuICAgICAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuVVpFUk87XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5NSU5fVkFMVUU7XG4gICAgICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsICh2YWx1ZSAvIFRXT19QV1JfMzJfREJMKSB8IDAsIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaWdJbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcodmFsdWUudG9TdHJpbmcoKSwgdW5zaWduZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2VtcHR5IHN0cmluZycpO1xuICAgICAgICBpZiAoc3RyID09PSAnTmFOJyB8fCBzdHIgPT09ICdJbmZpbml0eScgfHwgc3RyID09PSAnK0luZmluaXR5JyB8fCBzdHIgPT09ICctSW5maW5pdHknKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcbiAgICAgICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIChyYWRpeCA9IHVuc2lnbmVkKSwgKHVuc2lnbmVkID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3JhZGl4Jyk7XG4gICAgICAgIGxldCBwO1xuICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcbiAgICAgICAgZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhZGl4VG9Qb3dlciA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgOCkpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gTG9uZy5aRVJPO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSwgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPCA4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIHNpemUpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoTG9uZy5mcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChMb25nLmZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XG4gICAgICAgIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbMF0gfCAoYnl0ZXNbMV0gPDwgOCkgfCAoYnl0ZXNbMl0gPDwgMTYpIHwgKGJ5dGVzWzNdIDw8IDI0KSwgYnl0ZXNbNF0gfCAoYnl0ZXNbNV0gPDwgOCkgfCAoYnl0ZXNbNl0gPDwgMTYpIHwgKGJ5dGVzWzddIDw8IDI0KSwgdW5zaWduZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9uZygoYnl0ZXNbNF0gPDwgMjQpIHwgKGJ5dGVzWzVdIDw8IDE2KSB8IChieXRlc1s2XSA8PCA4KSB8IGJ5dGVzWzddLCAoYnl0ZXNbMF0gPDwgMjQpIHwgKGJ5dGVzWzFdIDw8IDE2KSB8IChieXRlc1syXSA8PCA4KSB8IGJ5dGVzWzNdLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0xvbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAnX19pc0xvbmdfXycgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgIHZhbHVlLl9faXNMb25nX18gPT09IHRydWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xuICAgIH1cbiAgICBhZGQoYWRkZW5kKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcoYWRkZW5kKSlcbiAgICAgICAgICAgIGFkZGVuZCA9IExvbmcuZnJvbVZhbHVlKGFkZGVuZCk7XG4gICAgICAgIGNvbnN0IGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuaGlnaCAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xuICAgICAgICBjb25zdCBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGIwMCA9IGFkZGVuZC5sb3cgJiAweGZmZmY7XG4gICAgICAgIGxldCBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xuICAgICAgICBjMDAgKz0gYTAwICsgYjAwO1xuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcbiAgICAgICAgYzAwICY9IDB4ZmZmZjtcbiAgICAgICAgYzE2ICs9IGExNiArIGIxNjtcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICAgIGMzMiArPSBhMzIgKyBiMzI7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4O1xuICAgICAgICBjNDggJj0gMHhmZmZmO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBhbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xuICAgICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHxcbiAgICAgICAgICAgIChvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDApXG4gICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICA6IDE7XG4gICAgfVxuICAgIGNvbXAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcik7XG4gICAgfVxuICAgIGRpdmlkZShkaXZpc29yKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcoZGl2aXNvcikpXG4gICAgICAgICAgICBkaXZpc29yID0gTG9uZy5mcm9tVmFsdWUoZGl2aXNvcik7XG4gICAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignZGl2aXNpb24gYnkgemVybycpO1xuICAgICAgICBpZiAod2FzbSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5oaWdoID09PSAtMHg4MDAwMDAwMCAmJlxuICAgICAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpO1xuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBMb25nLlVaRVJPIDogTG9uZy5aRVJPO1xuICAgICAgICBsZXQgYXBwcm94LCByZW0sIHJlcztcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcShMb25nLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5lcShMb25nLk9ORSkgfHwgZGl2aXNvci5lcShMb25nLk5FR19PTkUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5NSU5fVkFMVUU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk9ORTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShMb25nLlpFUk8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBMb25nLk9ORSA6IExvbmcuTkVHX09ORTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKExvbmcuTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IExvbmcuVVpFUk8gOiBMb25nLlpFUk87XG4gICAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gICAgICAgICAgICByZXMgPSBMb25nLlpFUk87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXG4gICAgICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuVVpFUk87XG4gICAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLlVPTkU7XG4gICAgICAgICAgICByZXMgPSBMb25nLlVaRVJPO1xuICAgICAgICB9XG4gICAgICAgIHJlbSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XG4gICAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XG4gICAgICAgICAgICBjb25zdCBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMik7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogTWF0aC5wb3coMiwgbG9nMiAtIDQ4KTtcbiAgICAgICAgICAgIGxldCBhcHByb3hSZXMgPSBMb25nLmZyb21OdW1iZXIoYXBwcm94KTtcbiAgICAgICAgICAgIGxldCBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gTG9uZy5mcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gTG9uZy5PTkU7XG4gICAgICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XG4gICAgICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZGl2KGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlKGRpdmlzb3IpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKG90aGVyKTtcbiAgICB9XG4gICAgZ2V0SGlnaEJpdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2g7XG4gICAgfVxuICAgIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XG4gICAgfVxuICAgIGdldExvd0JpdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvdztcbiAgICB9XG4gICAgZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XG4gICAgfVxuICAgIGdldE51bUJpdHNBYnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLmhpZ2ggIT09IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcbiAgICAgICAgbGV0IGJpdDtcbiAgICAgICAgZm9yIChiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXG4gICAgICAgICAgICBpZiAoKHZhbCAmICgxIDw8IGJpdCkpICE9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICE9PSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xuICAgIH1cbiAgICBncmVhdGVyVGhhbihvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+IDA7XG4gICAgfVxuICAgIGd0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyZWF0ZXJUaGFuKG90aGVyKTtcbiAgICB9XG4gICAgZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID49IDA7XG4gICAgfVxuICAgIGd0ZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICBnZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICBpc0V2ZW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcbiAgICB9XG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XG4gICAgfVxuICAgIGlzT2RkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XG4gICAgfVxuICAgIGlzUG9zaXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xuICAgIH1cbiAgICBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XG4gICAgfVxuICAgIGxlc3NUaGFuKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDwgMDtcbiAgICB9XG4gICAgbHQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVzc1RoYW4ob3RoZXIpO1xuICAgIH1cbiAgICBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPD0gMDtcbiAgICB9XG4gICAgbHRlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlc3NUaGFuT3JFcXVhbChvdGhlcik7XG4gICAgfVxuICAgIG1vZHVsbyhkaXZpc29yKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcoZGl2aXNvcikpXG4gICAgICAgICAgICBkaXZpc29yID0gTG9uZy5mcm9tVmFsdWUoZGl2aXNvcik7XG4gICAgICAgIGlmICh3YXNtKSB7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcbiAgICB9XG4gICAgbW9kKGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxvKGRpdmlzb3IpO1xuICAgIH1cbiAgICByZW0oZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bG8oZGl2aXNvcik7XG4gICAgfVxuICAgIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG11bHRpcGxpZXIpKVxuICAgICAgICAgICAgbXVsdGlwbGllciA9IExvbmcuZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xuICAgICAgICBpZiAod2FzbSkge1xuICAgICAgICAgICAgY29uc3QgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csIHRoaXMuaGlnaCwgbXVsdGlwbGllci5sb3csIG11bHRpcGxpZXIuaGlnaCk7XG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xuICAgICAgICBpZiAodGhpcy5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTG9uZy5NSU5fVkFMVUUgOiBMb25nLlpFUk87XG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKExvbmcuTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBMb25nLk1JTl9WQUxVRSA6IExvbmcuWkVSTztcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcbiAgICAgICAgaWYgKHRoaXMubHQoTG9uZy5UV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KExvbmcuVFdPX1BXUl8yNCkpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGNvbnN0IGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuaGlnaCAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcbiAgICAgICAgY29uc3QgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhmZmZmO1xuICAgICAgICBsZXQgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcbiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDtcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICAgIGMwMCAmPSAweGZmZmY7XG4gICAgICAgIGMxNiArPSBhMTYgKiBiMDA7XG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgICBjMTYgKz0gYTAwICogYjE2O1xuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICAgIGMzMiArPSBhMTYgKiBiMTY7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTAwICogYjMyO1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcbiAgICAgICAgYzQ4ICY9IDB4ZmZmZjtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgbXVsKG11bHRpcGxpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkobXVsdGlwbGllcik7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1ZBTFVFO1xuICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoTG9uZy5PTkUpO1xuICAgIH1cbiAgICBuZWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xuICAgIH1cbiAgICBub3QoKSB7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIG5vdEVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXF1YWxzKG90aGVyKTtcbiAgICB9XG4gICAgbmVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdEVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIG5lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdEVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIG9yKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgc2hpZnRMZWZ0KG51bUJpdHMpIHtcbiAgICAgICAgaWYgKExvbmcuaXNMb25nKG51bUJpdHMpKVxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiAoMzIgLSBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIHNobChudW1CaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0TGVmdChudW1CaXRzKTtcbiAgICB9XG4gICAgc2hpZnRSaWdodChudW1CaXRzKSB7XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyhudW1CaXRzKSlcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBzaHIobnVtQml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdFJpZ2h0KG51bUJpdHMpO1xuICAgIH1cbiAgICBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICAgICAgICBpZiAoTG9uZy5pc0xvbmcobnVtQml0cykpXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgICBudW1CaXRzICY9IDYzO1xuICAgICAgICBpZiAobnVtQml0cyA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSB0aGlzLmhpZ2g7XG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG93ID0gdGhpcy5sb3c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNocl91KG51bUJpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpO1xuICAgIH1cbiAgICBzaHJ1KG51bUJpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcoc3VidHJhaGVuZCkpXG4gICAgICAgICAgICBzdWJ0cmFoZW5kID0gTG9uZy5mcm9tVmFsdWUoc3VidHJhaGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcbiAgICB9XG4gICAgc3ViKHN1YnRyYWhlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qoc3VidHJhaGVuZCk7XG4gICAgfVxuICAgIHRvSW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICBpZiAodGhpcy51bnNpZ25lZClcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdG9CeXRlcyhsZSkge1xuICAgICAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcbiAgICB9XG4gICAgdG9CeXRlc0xFKCkge1xuICAgICAgICBjb25zdCBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxvICYgMHhmZixcbiAgICAgICAgICAgIChsbyA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgKGxvID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgbG8gPj4+IDI0LFxuICAgICAgICAgICAgaGkgJiAweGZmLFxuICAgICAgICAgICAgKGhpID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICBoaSA+Pj4gMjRcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdG9CeXRlc0JFKCkge1xuICAgICAgICBjb25zdCBoaSA9IHRoaXMuaGlnaCwgbG8gPSB0aGlzLmxvdztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhpID4+PiAyNCxcbiAgICAgICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIChoaSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgaGkgJiAweGZmLFxuICAgICAgICAgICAgbG8gPj4+IDI0LFxuICAgICAgICAgICAgKGxvID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgKGxvID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICBsbyAmIDB4ZmZcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdG9TaWduZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3JhZGl4Jyk7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcShMb25nLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpeExvbmcgPSBMb25nLmZyb21OdW1iZXIocmFkaXgpLCBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLCByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhZGl4VG9Qb3dlciA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBsZXQgcmVtID0gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpO1xuICAgICAgICAgICAgY29uc3QgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDA7XG4gICAgICAgICAgICBsZXQgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgICAgIHJlbSA9IHJlbURpdjtcbiAgICAgICAgICAgIGlmIChyZW0uaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9VbnNpZ25lZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XG4gICAgfVxuICAgIHhvcihvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIGVxeigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNaZXJvKCk7XG4gICAgfVxuICAgIGxlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlc3NUaGFuT3JFcXVhbChvdGhlcik7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWxheGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9OdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckxvbmc6IHRoaXMudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB1c2VCaWdJbnQ2NCA9IGZhbHNlLCByZWxheGVkID0gdHJ1ZSB9ID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgIGlmIChkb2MuJG51bWJlckxvbmcubGVuZ3RoID4gTUFYX0lOVDY0X1NUUklOR19MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJyRudW1iZXJMb25nIHN0cmluZyBpcyB0b28gbG9uZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghREVDSU1BTF9SRUdfRVgudGVzdChkb2MuJG51bWJlckxvbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGAkbnVtYmVyTG9uZyBzdHJpbmcgXCIke2RvYy4kbnVtYmVyTG9uZ31cIiBpcyBpbiBhbiBpbnZhbGlkIGZvcm1hdGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VCaWdJbnQ2NCkge1xuICAgICAgICAgICAgY29uc3QgYmlnSW50UmVzdWx0ID0gQmlnSW50KGRvYy4kbnVtYmVyTG9uZyk7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50LmFzSW50Tig2NCwgYmlnSW50UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb25nUmVzdWx0ID0gTG9uZy5mcm9tU3RyaW5nKGRvYy4kbnVtYmVyTG9uZyk7XG4gICAgICAgIGlmIChyZWxheGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9uZ1Jlc3VsdC50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb25nUmVzdWx0O1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBsb25nVmFsID0gaW5zcGVjdCh0aGlzLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB1bnNpZ25lZFZhbCA9IHRoaXMudW5zaWduZWQgPyBgLCAke2luc3BlY3QodGhpcy51bnNpZ25lZCwgb3B0aW9ucyl9YCA6ICcnO1xuICAgICAgICByZXR1cm4gYG5ldyBMb25nKCR7bG9uZ1ZhbH0ke3Vuc2lnbmVkVmFsfSlgO1xuICAgIH1cbn1cbkxvbmcuVFdPX1BXUl8yNCA9IExvbmcuZnJvbUludChUV09fUFdSXzI0X0RCTCk7XG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4ZmZmZmZmZmYgfCAwLCB0cnVlKTtcbkxvbmcuWkVSTyA9IExvbmcuZnJvbUludCgwKTtcbkxvbmcuVVpFUk8gPSBMb25nLmZyb21JbnQoMCwgdHJ1ZSk7XG5Mb25nLk9ORSA9IExvbmcuZnJvbUludCgxKTtcbkxvbmcuVU9ORSA9IExvbmcuZnJvbUludCgxLCB0cnVlKTtcbkxvbmcuTkVHX09ORSA9IExvbmcuZnJvbUludCgtMSk7XG5Mb25nLk1BWF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4N2ZmZmZmZmYgfCAwLCBmYWxzZSk7XG5Mb25nLk1JTl9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMCwgMHg4MDAwMDAwMCB8IDAsIGZhbHNlKTtcblxuY29uc3QgUEFSU0VfU1RSSU5HX1JFR0VYUCA9IC9eKFxcK3wtKT8oXFxkK3woXFxkKlxcLlxcZCopKT8oRXxlKT8oWy0rXSk/KFxcZCspPyQvO1xuY29uc3QgUEFSU0VfSU5GX1JFR0VYUCA9IC9eKFxcK3wtKT8oSW5maW5pdHl8aW5mKSQvaTtcbmNvbnN0IFBBUlNFX05BTl9SRUdFWFAgPSAvXihcXCt8LSk/TmFOJC9pO1xuY29uc3QgRVhQT05FTlRfTUFYID0gNjExMTtcbmNvbnN0IEVYUE9ORU5UX01JTiA9IC02MTc2O1xuY29uc3QgRVhQT05FTlRfQklBUyA9IDYxNzY7XG5jb25zdCBNQVhfRElHSVRTID0gMzQ7XG5jb25zdCBOQU5fQlVGRkVSID0gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShbXG4gICAgMHg3YywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMFxuXS5yZXZlcnNlKCkpO1xuY29uc3QgSU5GX05FR0FUSVZFX0JVRkZFUiA9IEJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoW1xuICAgIDB4ZjgsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBcbl0ucmV2ZXJzZSgpKTtcbmNvbnN0IElORl9QT1NJVElWRV9CVUZGRVIgPSBCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KFtcbiAgICAweDc4LCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXG5dLnJldmVyc2UoKSk7XG5jb25zdCBFWFBPTkVOVF9SRUdFWCA9IC9eKFstK10pPyhcXGQrKT8kLztcbmNvbnN0IENPTUJJTkFUSU9OX01BU0sgPSAweDFmO1xuY29uc3QgRVhQT05FTlRfTUFTSyA9IDB4M2ZmZjtcbmNvbnN0IENPTUJJTkFUSU9OX0lORklOSVRZID0gMzA7XG5jb25zdCBDT01CSU5BVElPTl9OQU4gPSAzMTtcbmZ1bmN0aW9uIGlzRGlnaXQodmFsdWUpIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xufVxuZnVuY3Rpb24gZGl2aWRldTEyOCh2YWx1ZSkge1xuICAgIGNvbnN0IERJVklTT1IgPSBMb25nLmZyb21OdW1iZXIoMTAwMCAqIDEwMDAgKiAxMDAwKTtcbiAgICBsZXQgX3JlbSA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICBpZiAoIXZhbHVlLnBhcnRzWzBdICYmICF2YWx1ZS5wYXJ0c1sxXSAmJiAhdmFsdWUucGFydHNbMl0gJiYgIXZhbHVlLnBhcnRzWzNdKSB7XG4gICAgICAgIHJldHVybiB7IHF1b3RpZW50OiB2YWx1ZSwgcmVtOiBfcmVtIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDM7IGkrKykge1xuICAgICAgICBfcmVtID0gX3JlbS5zaGlmdExlZnQoMzIpO1xuICAgICAgICBfcmVtID0gX3JlbS5hZGQobmV3IExvbmcodmFsdWUucGFydHNbaV0sIDApKTtcbiAgICAgICAgdmFsdWUucGFydHNbaV0gPSBfcmVtLmRpdihESVZJU09SKS5sb3c7XG4gICAgICAgIF9yZW0gPSBfcmVtLm1vZHVsbyhESVZJU09SKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcXVvdGllbnQ6IHZhbHVlLCByZW06IF9yZW0gfTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5NjR4MihsZWZ0LCByaWdodCkge1xuICAgIGlmICghbGVmdCAmJiAhcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHsgaGlnaDogTG9uZy5mcm9tTnVtYmVyKDApLCBsb3c6IExvbmcuZnJvbU51bWJlcigwKSB9O1xuICAgIH1cbiAgICBjb25zdCBsZWZ0SGlnaCA9IGxlZnQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKTtcbiAgICBjb25zdCBsZWZ0TG93ID0gbmV3IExvbmcobGVmdC5nZXRMb3dCaXRzKCksIDApO1xuICAgIGNvbnN0IHJpZ2h0SGlnaCA9IHJpZ2h0LnNoaWZ0UmlnaHRVbnNpZ25lZCgzMik7XG4gICAgY29uc3QgcmlnaHRMb3cgPSBuZXcgTG9uZyhyaWdodC5nZXRMb3dCaXRzKCksIDApO1xuICAgIGxldCBwcm9kdWN0SGlnaCA9IGxlZnRIaWdoLm11bHRpcGx5KHJpZ2h0SGlnaCk7XG4gICAgbGV0IHByb2R1Y3RNaWQgPSBsZWZ0SGlnaC5tdWx0aXBseShyaWdodExvdyk7XG4gICAgY29uc3QgcHJvZHVjdE1pZDIgPSBsZWZ0TG93Lm11bHRpcGx5KHJpZ2h0SGlnaCk7XG4gICAgbGV0IHByb2R1Y3RMb3cgPSBsZWZ0TG93Lm11bHRpcGx5KHJpZ2h0TG93KTtcbiAgICBwcm9kdWN0SGlnaCA9IHByb2R1Y3RIaWdoLmFkZChwcm9kdWN0TWlkLnNoaWZ0UmlnaHRVbnNpZ25lZCgzMikpO1xuICAgIHByb2R1Y3RNaWQgPSBuZXcgTG9uZyhwcm9kdWN0TWlkLmdldExvd0JpdHMoKSwgMClcbiAgICAgICAgLmFkZChwcm9kdWN0TWlkMilcbiAgICAgICAgLmFkZChwcm9kdWN0TG93LnNoaWZ0UmlnaHRVbnNpZ25lZCgzMikpO1xuICAgIHByb2R1Y3RIaWdoID0gcHJvZHVjdEhpZ2guYWRkKHByb2R1Y3RNaWQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKSk7XG4gICAgcHJvZHVjdExvdyA9IHByb2R1Y3RNaWQuc2hpZnRMZWZ0KDMyKS5hZGQobmV3IExvbmcocHJvZHVjdExvdy5nZXRMb3dCaXRzKCksIDApKTtcbiAgICByZXR1cm4geyBoaWdoOiBwcm9kdWN0SGlnaCwgbG93OiBwcm9kdWN0TG93IH07XG59XG5mdW5jdGlvbiBsZXNzVGhhbihsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IHVobGVmdCA9IGxlZnQuaGlnaCA+Pj4gMDtcbiAgICBjb25zdCB1aHJpZ2h0ID0gcmlnaHQuaGlnaCA+Pj4gMDtcbiAgICBpZiAodWhsZWZ0IDwgdWhyaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodWhsZWZ0ID09PSB1aHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHVsbGVmdCA9IGxlZnQubG93ID4+PiAwO1xuICAgICAgICBjb25zdCB1bHJpZ2h0ID0gcmlnaHQubG93ID4+PiAwO1xuICAgICAgICBpZiAodWxsZWZ0IDwgdWxyaWdodClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbnZhbGlkRXJyKHN0cmluZywgbWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFwiJHtzdHJpbmd9XCIgaXMgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcgLSAke21lc3NhZ2V9YCk7XG59XG5jbGFzcyBEZWNpbWFsMTI4IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0RlY2ltYWwxMjgnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5ieXRlcyA9IERlY2ltYWwxMjguZnJvbVN0cmluZyhieXRlcykuYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNVaW50OEFycmF5KGJ5dGVzKSkge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignRGVjaW1hbDEyOCBtdXN0IHRha2UgYSBCdWZmZXIgb2YgMTYgYnl0ZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0RlY2ltYWwxMjggbXVzdCB0YWtlIGEgQnVmZmVyIG9yIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsMTI4Ll9mcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uLCB7IGFsbG93Um91bmRpbmc6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZ1dpdGhSb3VuZGluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gRGVjaW1hbDEyOC5fZnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbiwgeyBhbGxvd1JvdW5kaW5nOiB0cnVlIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21TdHJpbmcocmVwcmVzZW50YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGlzTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNhd1NpZ24gPSBmYWxzZTtcbiAgICAgICAgbGV0IHNhd1JhZGl4ID0gZmFsc2U7XG4gICAgICAgIGxldCBmb3VuZE5vblplcm8gPSBmYWxzZTtcbiAgICAgICAgbGV0IHNpZ25pZmljYW50RGlnaXRzID0gMDtcbiAgICAgICAgbGV0IG5EaWdpdHNSZWFkID0gMDtcbiAgICAgICAgbGV0IG5EaWdpdHMgPSAwO1xuICAgICAgICBsZXQgcmFkaXhQb3NpdGlvbiA9IDA7XG4gICAgICAgIGxldCBmaXJzdE5vblplcm8gPSAwO1xuICAgICAgICBjb25zdCBkaWdpdHMgPSBbMF07XG4gICAgICAgIGxldCBuRGlnaXRzU3RvcmVkID0gMDtcbiAgICAgICAgbGV0IGRpZ2l0c0luc2VydCA9IDA7XG4gICAgICAgIGxldCBsYXN0RGlnaXQgPSAwO1xuICAgICAgICBsZXQgZXhwb25lbnQgPSAwO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRIaWdoID0gbmV3IExvbmcoMCwgMCk7XG4gICAgICAgIGxldCBzaWduaWZpY2FuZExvdyA9IG5ldyBMb25nKDAsIDApO1xuICAgICAgICBsZXQgYmlhc2VkRXhwb25lbnQgPSAwO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBpZiAocmVwcmVzZW50YXRpb24ubGVuZ3RoID49IDcwMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJycgKyByZXByZXNlbnRhdGlvbiArICcgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmdNYXRjaCA9IHJlcHJlc2VudGF0aW9uLm1hdGNoKFBBUlNFX1NUUklOR19SRUdFWFApO1xuICAgICAgICBjb25zdCBpbmZNYXRjaCA9IHJlcHJlc2VudGF0aW9uLm1hdGNoKFBBUlNFX0lORl9SRUdFWFApO1xuICAgICAgICBjb25zdCBuYW5NYXRjaCA9IHJlcHJlc2VudGF0aW9uLm1hdGNoKFBBUlNFX05BTl9SRUdFWFApO1xuICAgICAgICBpZiAoKCFzdHJpbmdNYXRjaCAmJiAhaW5mTWF0Y2ggJiYgIW5hbk1hdGNoKSB8fCByZXByZXNlbnRhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJycgKyByZXByZXNlbnRhdGlvbiArICcgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nTWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkTnVtYmVyID0gc3RyaW5nTWF0Y2hbMl07XG4gICAgICAgICAgICBjb25zdCBlID0gc3RyaW5nTWF0Y2hbNF07XG4gICAgICAgICAgICBjb25zdCBleHBTaWduID0gc3RyaW5nTWF0Y2hbNV07XG4gICAgICAgICAgICBjb25zdCBleHBOdW1iZXIgPSBzdHJpbmdNYXRjaFs2XTtcbiAgICAgICAgICAgIGlmIChlICYmIGV4cE51bWJlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdtaXNzaW5nIGV4cG9uZW50IHBvd2VyJyk7XG4gICAgICAgICAgICBpZiAoZSAmJiB1bnNpZ25lZE51bWJlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdtaXNzaW5nIGV4cG9uZW50IGJhc2UnKTtcbiAgICAgICAgICAgIGlmIChlID09PSB1bmRlZmluZWQgJiYgKGV4cFNpZ24gfHwgZXhwTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdtaXNzaW5nIGUgYmVmb3JlIGV4cG9uZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJysnIHx8IHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzYXdTaWduID0gdHJ1ZTtcbiAgICAgICAgICAgIGlzTmVnYXRpdmUgPSByZXByZXNlbnRhdGlvbltpbmRleCsrXSA9PT0gJy0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEaWdpdChyZXByZXNlbnRhdGlvbltpbmRleF0pICYmIHJlcHJlc2VudGF0aW9uW2luZGV4XSAhPT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnaScgfHwgcmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnSScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoaXNOZWdhdGl2ZSA/IElORl9ORUdBVElWRV9CVUZGRVIgOiBJTkZfUE9TSVRJVkVfQlVGRkVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ04nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KE5BTl9CVUZGRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpc0RpZ2l0KHJlcHJlc2VudGF0aW9uW2luZGV4XSkgfHwgcmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnLicpIHtcbiAgICAgICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGlmIChzYXdSYWRpeClcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2NvbnRhaW5zIG11bHRpcGxlIHBlcmlvZHMnKTtcbiAgICAgICAgICAgICAgICBzYXdSYWRpeCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobkRpZ2l0c1N0b3JlZCA8IE1BWF9ESUdJVFMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdICE9PSAnMCcgfHwgZm91bmROb25aZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmROb25aZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8gPSBuRGlnaXRzUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3VuZE5vblplcm8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkaWdpdHNbZGlnaXRzSW5zZXJ0KytdID0gcGFyc2VJbnQocmVwcmVzZW50YXRpb25baW5kZXhdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIG5EaWdpdHNTdG9yZWQgPSBuRGlnaXRzU3RvcmVkICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmROb25aZXJvKVxuICAgICAgICAgICAgICAgIG5EaWdpdHMgPSBuRGlnaXRzICsgMTtcbiAgICAgICAgICAgIGlmIChzYXdSYWRpeClcbiAgICAgICAgICAgICAgICByYWRpeFBvc2l0aW9uID0gcmFkaXhQb3NpdGlvbiArIDE7XG4gICAgICAgICAgICBuRGlnaXRzUmVhZCA9IG5EaWdpdHNSZWFkICsgMTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYXdSYWRpeCAmJiAhbkRpZ2l0c1JlYWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCcnICsgcmVwcmVzZW50YXRpb24gKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7XG4gICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICdlJyB8fCByZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICdFJykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZXByZXNlbnRhdGlvbi5zdWJzdHIoKytpbmRleCkubWF0Y2goRVhQT05FTlRfUkVHRVgpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2hbMl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KE5BTl9CVUZGRVIpO1xuICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChtYXRjaFswXSwgMTApO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KE5BTl9CVUZGRVIpO1xuICAgICAgICBpZiAoIW5EaWdpdHNTdG9yZWQpIHtcbiAgICAgICAgICAgIGRpZ2l0c1swXSA9IDA7XG4gICAgICAgICAgICBuRGlnaXRzID0gMTtcbiAgICAgICAgICAgIG5EaWdpdHNTdG9yZWQgPSAxO1xuICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFzdERpZ2l0ID0gbkRpZ2l0c1N0b3JlZCAtIDE7XG4gICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IG5EaWdpdHM7XG4gICAgICAgICAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVwcmVzZW50YXRpb25bZmlyc3ROb25aZXJvICsgc2lnbmlmaWNhbnREaWdpdHMgLSAxICsgTnVtYmVyKHNhd1NpZ24pICsgTnVtYmVyKHNhd1JhZGl4KV0gPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IHNpZ25pZmljYW50RGlnaXRzIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9uZW50IDw9IHJhZGl4UG9zaXRpb24gJiYgcmFkaXhQb3NpdGlvbiA+IGV4cG9uZW50ICsgKDEgPDwgMTQpKSB7XG4gICAgICAgICAgICBleHBvbmVudCA9IEVYUE9ORU5UX01JTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSByYWRpeFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChleHBvbmVudCA+IEVYUE9ORU5UX01BWCkge1xuICAgICAgICAgICAgbGFzdERpZ2l0ID0gbGFzdERpZ2l0ICsgMTtcbiAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgPj0gTUFYX0RJR0lUUykge1xuICAgICAgICAgICAgICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IEVYUE9ORU5UX01BWDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dSb3VuZGluZykge1xuICAgICAgICAgICAgd2hpbGUgKGV4cG9uZW50IDwgRVhQT05FTlRfTUlOIHx8IG5EaWdpdHNTdG9yZWQgPCBuRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3REaWdpdCA9PT0gMCAmJiBzaWduaWZpY2FudERpZ2l0cyA8IG5EaWdpdHNTdG9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NSU47XG4gICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBuRGlnaXRzID0gbkRpZ2l0cyAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RGlnaXQgPSBsYXN0RGlnaXQgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPCBFWFBPTkVOVF9NQVgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWdpdHNTdHJpbmcgPSBkaWdpdHMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWdpdHNTdHJpbmcubWF0Y2goL14wKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NQVg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdERpZ2l0ICsgMSA8IHNpZ25pZmljYW50RGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZE9mU3RyaW5nID0gbkRpZ2l0c1JlYWQ7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1JhZGl4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IGZpcnN0Tm9uWmVybyArIDE7XG4gICAgICAgICAgICAgICAgICAgIGVuZE9mU3RyaW5nID0gZW5kT2ZTdHJpbmcgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2F3U2lnbikge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8gPSBmaXJzdE5vblplcm8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbmRPZlN0cmluZyA9IGVuZE9mU3RyaW5nICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91bmREaWdpdCA9IHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2ZpcnN0Tm9uWmVybyArIGxhc3REaWdpdCArIDFdLCAxMCk7XG4gICAgICAgICAgICAgICAgbGV0IHJvdW5kQml0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocm91bmREaWdpdCA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdW5kQml0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdW5kRGlnaXQgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kQml0ID0gZGlnaXRzW2xhc3REaWdpdF0gJSAyID09PSAxID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZmlyc3ROb25aZXJvICsgbGFzdERpZ2l0ICsgMjsgaSA8IGVuZE9mU3RyaW5nOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQocmVwcmVzZW50YXRpb25baV0sIDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZEJpdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm91bmRCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRJZHggPSBsYXN0RGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBkSWR4ID49IDA7IGRJZHgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrZGlnaXRzW2RJZHhdID4gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0c1tkSWR4XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRJZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50IDwgRVhQT05FTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0c1tkSWR4XSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoaXNOZWdhdGl2ZSA/IElORl9ORUdBVElWRV9CVUZGRVIgOiBJTkZfUE9TSVRJVkVfQlVGRkVSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGV4cG9uZW50IDwgRVhQT05FTlRfTUlOIHx8IG5EaWdpdHNTdG9yZWQgPCBuRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3REaWdpdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUlOO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2V4cG9uZW50IHVuZGVyZmxvdycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkRpZ2l0c1N0b3JlZCA8IG5EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW25EaWdpdHMgLSAxICsgTnVtYmVyKHNhd1NpZ24pICsgTnVtYmVyKHNhd1JhZGl4KV0gIT09ICcwJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdpbmV4YWN0IHJvdW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbkRpZ2l0cyA9IG5EaWdpdHMgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZ2l0c1tsYXN0RGlnaXRdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnaW5leGFjdCByb3VuZGluZycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3REaWdpdCA9IGxhc3REaWdpdCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA8IEVYUE9ORU5UX01BWCkge1xuICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdvdmVyZmxvdycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgKyAxIDwgc2lnbmlmaWNhbnREaWdpdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2F3UmFkaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNhd1NpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91bmREaWdpdCA9IHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2ZpcnN0Tm9uWmVybyArIGxhc3REaWdpdCArIDFdLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kRGlnaXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2luZXhhY3Qgcm91bmRpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgICAgICBzaWduaWZpY2FuZExvdyA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICAgICAgaWYgKHNpZ25pZmljYW50RGlnaXRzID09PSAwKSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZEhpZ2ggPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXN0RGlnaXQgPCAxNykge1xuICAgICAgICAgICAgbGV0IGRJZHggPSAwO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHgrK10pO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gbmV3IExvbmcoMCwgMCk7XG4gICAgICAgICAgICBmb3IgKDsgZElkeCA8PSBsYXN0RGlnaXQ7IGRJZHgrKykge1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cubXVsdGlwbHkoTG9uZy5mcm9tTnVtYmVyKDEwKSk7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBzaWduaWZpY2FuZExvdy5hZGQoTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRJZHggPSAwO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4KytdKTtcbiAgICAgICAgICAgIGZvciAoOyBkSWR4IDw9IGxhc3REaWdpdCAtIDE3OyBkSWR4KyspIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZEhpZ2ggPSBzaWduaWZpY2FuZEhpZ2gubXVsdGlwbHkoTG9uZy5mcm9tTnVtYmVyKDEwKSk7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gc2lnbmlmaWNhbmRIaWdoLmFkZChMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHhdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeCsrXSk7XG4gICAgICAgICAgICBmb3IgKDsgZElkeCA8PSBsYXN0RGlnaXQ7IGRJZHgrKykge1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cubXVsdGlwbHkoTG9uZy5mcm9tTnVtYmVyKDEwKSk7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBzaWduaWZpY2FuZExvdy5hZGQoTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25pZmljYW5kID0gbXVsdGlwbHk2NHgyKHNpZ25pZmljYW5kSGlnaCwgTG9uZy5mcm9tU3RyaW5nKCcxMDAwMDAwMDAwMDAwMDAwMDAnKSk7XG4gICAgICAgIHNpZ25pZmljYW5kLmxvdyA9IHNpZ25pZmljYW5kLmxvdy5hZGQoc2lnbmlmaWNhbmRMb3cpO1xuICAgICAgICBpZiAobGVzc1RoYW4oc2lnbmlmaWNhbmQubG93LCBzaWduaWZpY2FuZExvdykpIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kLmhpZ2ggPSBzaWduaWZpY2FuZC5oaWdoLmFkZChMb25nLmZyb21OdW1iZXIoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGJpYXNlZEV4cG9uZW50ID0gZXhwb25lbnQgKyBFWFBPTkVOVF9CSUFTO1xuICAgICAgICBjb25zdCBkZWMgPSB7IGxvdzogTG9uZy5mcm9tTnVtYmVyKDApLCBoaWdoOiBMb25nLmZyb21OdW1iZXIoMCkgfTtcbiAgICAgICAgaWYgKHNpZ25pZmljYW5kLmhpZ2guc2hpZnRSaWdodFVuc2lnbmVkKDQ5KS5hbmQoTG9uZy5mcm9tTnVtYmVyKDEpKS5lcXVhbHMoTG9uZy5mcm9tTnVtYmVyKDEpKSkge1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihMb25nLmZyb21OdW1iZXIoMHgzKS5zaGlmdExlZnQoNjEpKTtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3IoTG9uZy5mcm9tTnVtYmVyKGJpYXNlZEV4cG9uZW50KS5hbmQoTG9uZy5mcm9tTnVtYmVyKDB4M2ZmZikuc2hpZnRMZWZ0KDQ3KSkpO1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihzaWduaWZpY2FuZC5oaWdoLmFuZChMb25nLmZyb21OdW1iZXIoMHg3ZmZmZmZmZmZmZmYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKExvbmcuZnJvbU51bWJlcihiaWFzZWRFeHBvbmVudCAmIDB4M2ZmZikuc2hpZnRMZWZ0KDQ5KSk7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKHNpZ25pZmljYW5kLmhpZ2guYW5kKExvbmcuZnJvbU51bWJlcigweDFmZmZmZmZmZmZmZmYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjLmxvdyA9IHNpZ25pZmljYW5kLmxvdztcbiAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3IoTG9uZy5mcm9tU3RyaW5nKCc5MjIzMzcyMDM2ODU0Nzc1ODA4JykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZSgxNik7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gZGVjLmxvdy5sb3cgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5sb3cgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5sb3cgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cubG93ID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGRlYy5sb3cuaGlnaCAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmhpZ2ggPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5oaWdoID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmhpZ2ggPj4gMjQpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gZGVjLmhpZ2gubG93ICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmxvdyA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5sb3cgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmxvdyA+PiAyNCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBkZWMuaGlnaC5oaWdoICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmhpZ2ggPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2guaGlnaCA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2guaGlnaCA+PiAyNCkgJiAweGZmO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoYnVmZmVyKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBiaWFzZWRfZXhwb25lbnQ7XG4gICAgICAgIGxldCBzaWduaWZpY2FuZF9kaWdpdHMgPSAwO1xuICAgICAgICBjb25zdCBzaWduaWZpY2FuZCA9IG5ldyBBcnJheSgzNik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmlmaWNhbmQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaWduaWZpY2FuZFtpXSA9IDA7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBpc196ZXJvID0gZmFsc2U7XG4gICAgICAgIGxldCBzaWduaWZpY2FuZF9tc2I7XG4gICAgICAgIGxldCBzaWduaWZpY2FuZDEyOCA9IHsgcGFydHM6IFswLCAwLCAwLCAwXSB9O1xuICAgICAgICBsZXQgaiwgaztcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gW107XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5ieXRlcztcbiAgICAgICAgY29uc3QgbG93ID0gYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgIGNvbnN0IG1pZGwgPSBidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgY29uc3QgbWlkaCA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICBjb25zdCBoaWdoID0gYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgZGVjID0ge1xuICAgICAgICAgICAgbG93OiBuZXcgTG9uZyhsb3csIG1pZGwpLFxuICAgICAgICAgICAgaGlnaDogbmV3IExvbmcobWlkaCwgaGlnaClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlYy5oaWdoLmxlc3NUaGFuKExvbmcuWkVSTykpIHtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tYmluYXRpb24gPSAoaGlnaCA+PiAyNikgJiBDT01CSU5BVElPTl9NQVNLO1xuICAgICAgICBpZiAoY29tYmluYXRpb24gPj4gMyA9PT0gMykge1xuICAgICAgICAgICAgaWYgKGNvbWJpbmF0aW9uID09PSBDT01CSU5BVElPTl9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuam9pbignJykgKyAnSW5maW5pdHknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tYmluYXRpb24gPT09IENPTUJJTkFUSU9OX05BTikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTmFOJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpYXNlZF9leHBvbmVudCA9IChoaWdoID4+IDE1KSAmIEVYUE9ORU5UX01BU0s7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRfbXNiID0gMHgwOCArICgoaGlnaCA+PiAxNCkgJiAweDAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kX21zYiA9IChoaWdoID4+IDE0KSAmIDB4MDc7XG4gICAgICAgICAgICBiaWFzZWRfZXhwb25lbnQgPSAoaGlnaCA+PiAxNykgJiBFWFBPTkVOVF9NQVNLO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cG9uZW50ID0gYmlhc2VkX2V4cG9uZW50IC0gRVhQT05FTlRfQklBUztcbiAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbMF0gPSAoaGlnaCAmIDB4M2ZmZikgKyAoKHNpZ25pZmljYW5kX21zYiAmIDB4ZikgPDwgMTQpO1xuICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1sxXSA9IG1pZGg7XG4gICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzJdID0gbWlkbDtcbiAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbM10gPSBsb3c7XG4gICAgICAgIGlmIChzaWduaWZpY2FuZDEyOC5wYXJ0c1swXSA9PT0gMCAmJlxuICAgICAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbMV0gPT09IDAgJiZcbiAgICAgICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzJdID09PSAwICYmXG4gICAgICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1szXSA9PT0gMCkge1xuICAgICAgICAgICAgaXNfemVybyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAzOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgICAgIGxldCBsZWFzdF9kaWdpdHMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRpdmlkZXUxMjgoc2lnbmlmaWNhbmQxMjgpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kMTI4ID0gcmVzdWx0LnF1b3RpZW50O1xuICAgICAgICAgICAgICAgIGxlYXN0X2RpZ2l0cyA9IHJlc3VsdC5yZW0ubG93O1xuICAgICAgICAgICAgICAgIGlmICghbGVhc3RfZGlnaXRzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSA4OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FuZFtrICogOSArIGpdID0gbGVhc3RfZGlnaXRzICUgMTA7XG4gICAgICAgICAgICAgICAgICAgIGxlYXN0X2RpZ2l0cyA9IE1hdGguZmxvb3IobGVhc3RfZGlnaXRzIC8gMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfemVybykge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRfZGlnaXRzID0gMTtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kW2luZGV4XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZF9kaWdpdHMgPSAzNjtcbiAgICAgICAgICAgIHdoaWxlICghc2lnbmlmaWNhbmRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRfZGlnaXRzID0gc2lnbmlmaWNhbmRfZGlnaXRzIC0gMTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2llbnRpZmljX2V4cG9uZW50ID0gc2lnbmlmaWNhbmRfZGlnaXRzIC0gMSArIGV4cG9uZW50O1xuICAgICAgICBpZiAoc2NpZW50aWZpY19leHBvbmVudCA+PSAzNCB8fCBzY2llbnRpZmljX2V4cG9uZW50IDw9IC03IHx8IGV4cG9uZW50ID4gMCkge1xuICAgICAgICAgICAgaWYgKHNpZ25pZmljYW5kX2RpZ2l0cyA+IDM0KSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7MH1gKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPiAwKVxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgRSske2V4cG9uZW50fWApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4cG9uZW50IDwgMClcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYEUke2V4cG9uZW50fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IHNpZ25pZmljYW5kX2RpZ2l0cyAtIDE7XG4gICAgICAgICAgICBpZiAoc2lnbmlmaWNhbmRfZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmlmaWNhbmRfZGlnaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZy5wdXNoKCdFJyk7XG4gICAgICAgICAgICBpZiAoc2NpZW50aWZpY19leHBvbmVudCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgKyR7c2NpZW50aWZpY19leHBvbmVudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NjaWVudGlmaWNfZXhwb25lbnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXhwb25lbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmlmaWNhbmRfZGlnaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhZGl4X3Bvc2l0aW9uID0gc2lnbmlmaWNhbmRfZGlnaXRzICsgZXhwb25lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJhZGl4X3Bvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhZGl4X3Bvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NpZ25pZmljYW5kW2luZGV4KytdfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaCgnLicpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYWRpeF9wb3NpdGlvbisrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kX2RpZ2l0cyAtIE1hdGgubWF4KHJhZGl4X3Bvc2l0aW9uIC0gMSwgMCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKCcnKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyAkbnVtYmVyRGVjaW1hbDogdGhpcy50b1N0cmluZygpIH07XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkbnVtYmVyRGVjaW1hbDogdGhpcy50b1N0cmluZygpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICByZXR1cm4gRGVjaW1hbDEyOC5mcm9tU3RyaW5nKGRvYy4kbnVtYmVyRGVjaW1hbCk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIGNvbnN0IGQxMjhzdHJpbmcgPSBpbnNwZWN0KHRoaXMudG9TdHJpbmcoKSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBgbmV3IERlY2ltYWwxMjgoJHtkMTI4c3RyaW5nfSlgO1xuICAgIH1cbn1cblxuY2xhc3MgRG91YmxlIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0RvdWJsZSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9ICt2YWx1ZTtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5sZWdhY3kgfHwgKG9wdGlvbnMucmVsYXhlZCAmJiBpc0Zpbml0ZSh0aGlzLnZhbHVlKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmlzKE1hdGguc2lnbih0aGlzLnZhbHVlKSwgLTApKSB7XG4gICAgICAgICAgICByZXR1cm4geyAkbnVtYmVyRG91YmxlOiAnLTAuMCcgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJG51bWJlckRvdWJsZTogTnVtYmVyLmlzSW50ZWdlcih0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUudG9GaXhlZCgxKSA6IHRoaXMudmFsdWUudG9TdHJpbmcoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZG91YmxlVmFsdWUgPSBwYXJzZUZsb2F0KGRvYy4kbnVtYmVyRG91YmxlKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5yZWxheGVkID8gZG91YmxlVmFsdWUgOiBuZXcgRG91YmxlKGRvdWJsZVZhbHVlKTtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgcmV0dXJuIGBuZXcgRG91YmxlKCR7aW5zcGVjdCh0aGlzLnZhbHVlLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5cbmNsYXNzIEludDMyIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0ludDMyJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gK3ZhbHVlIHwgMDtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5yZWxheGVkIHx8IG9wdGlvbnMubGVnYWN5KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyAkbnVtYmVySW50OiB0aGlzLnZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZCA/IHBhcnNlSW50KGRvYy4kbnVtYmVySW50LCAxMCkgOiBuZXcgSW50MzIoZG9jLiRudW1iZXJJbnQpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICByZXR1cm4gYG5ldyBJbnQzMigke2luc3BlY3QodGhpcy52YWx1ZSwgb3B0aW9ucyl9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBNYXhLZXkgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnTWF4S2V5JztcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICRtYXhLZXk6IDEgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF4S2V5KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiAnbmV3IE1heEtleSgpJztcbiAgICB9XG59XG5cbmNsYXNzIE1pbktleSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdNaW5LZXknO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG1pbktleTogMSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNaW5LZXkoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuICduZXcgTWluS2V5KCknO1xuICAgIH1cbn1cblxuY29uc3QgY2hlY2tGb3JIZXhSZWdFeHAgPSBuZXcgUmVnRXhwKCdeWzAtOWEtZkEtRl17MjR9JCcpO1xubGV0IFBST0NFU1NfVU5JUVVFID0gbnVsbDtcbmNvbnN0IGtJZCA9IFN5bWJvbCgnaWQnKTtcbmNsYXNzIE9iamVjdElkIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ09iamVjdElkJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXRJZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBsZXQgd29ya2luZ0lkO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0SWQgPT09ICdvYmplY3QnICYmIGlucHV0SWQgJiYgJ2lkJyBpbiBpbnB1dElkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0SWQuaWQgIT09ICdzdHJpbmcnICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXRJZC5pZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdBcmd1bWVudCBwYXNzZWQgaW4gbXVzdCBoYXZlIGFuIGlkIHRoYXQgaXMgb2YgdHlwZSBzdHJpbmcgb3IgQnVmZmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3RvSGV4U3RyaW5nJyBpbiBpbnB1dElkICYmIHR5cGVvZiBpbnB1dElkLnRvSGV4U3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgd29ya2luZ0lkID0gQnl0ZVV0aWxzLmZyb21IZXgoaW5wdXRJZC50b0hleFN0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdvcmtpbmdJZCA9IGlucHV0SWQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3b3JraW5nSWQgPSBpbnB1dElkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JraW5nSWQgPT0gbnVsbCB8fCB0eXBlb2Ygd29ya2luZ0lkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpc1trSWRdID0gT2JqZWN0SWQuZ2VuZXJhdGUodHlwZW9mIHdvcmtpbmdJZCA9PT0gJ251bWJlcicgPyB3b3JraW5nSWQgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh3b3JraW5nSWQpICYmIHdvcmtpbmdJZC5ieXRlTGVuZ3RoID09PSAxMikge1xuICAgICAgICAgICAgdGhpc1trSWRdID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKHdvcmtpbmdJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdvcmtpbmdJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh3b3JraW5nSWQubGVuZ3RoID09PSAyNCAmJiBjaGVja0ZvckhleFJlZ0V4cC50ZXN0KHdvcmtpbmdJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tJZF0gPSBCeXRlVXRpbHMuZnJvbUhleCh3b3JraW5nSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaW5wdXQgbXVzdCBiZSBhIDI0IGNoYXJhY3RlciBoZXggc3RyaW5nLCAxMiBieXRlIFVpbnQ4QXJyYXksIG9yIGFuIGludGVnZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0FyZ3VtZW50IHBhc3NlZCBpbiBkb2VzIG5vdCBtYXRjaCB0aGUgYWNjZXB0ZWQgdHlwZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX19pZCA9IEJ5dGVVdGlscy50b0hleCh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tJZF07XG4gICAgfVxuICAgIHNldCBpZCh2YWx1ZSkge1xuICAgICAgICB0aGlzW2tJZF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9faWQgPSBCeXRlVXRpbHMudG9IZXgodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSGV4U3RyaW5nKCkge1xuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcgJiYgdGhpcy5fX2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2lkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleFN0cmluZyA9IEJ5dGVVdGlscy50b0hleCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nICYmICF0aGlzLl9faWQpIHtcbiAgICAgICAgICAgIHRoaXMuX19pZCA9IGhleFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4U3RyaW5nO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW5jKCkge1xuICAgICAgICByZXR1cm4gKE9iamVjdElkLmluZGV4ID0gKE9iamVjdElkLmluZGV4ICsgMSkgJSAweGZmZmZmZik7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZSh0aW1lKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmMgPSBPYmplY3RJZC5nZXRJbmMoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKDEyKTtcbiAgICAgICAgQlNPTkRhdGFWaWV3LmZyb21VaW50OEFycmF5KGJ1ZmZlcikuc2V0VWludDMyKDAsIHRpbWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKFBST0NFU1NfVU5JUVVFID09PSBudWxsKSB7XG4gICAgICAgICAgICBQUk9DRVNTX1VOSVFVRSA9IEJ5dGVVdGlscy5yYW5kb21CeXRlcyg1KTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJbNF0gPSBQUk9DRVNTX1VOSVFVRVswXTtcbiAgICAgICAgYnVmZmVyWzVdID0gUFJPQ0VTU19VTklRVUVbMV07XG4gICAgICAgIGJ1ZmZlcls2XSA9IFBST0NFU1NfVU5JUVVFWzJdO1xuICAgICAgICBidWZmZXJbN10gPSBQUk9DRVNTX1VOSVFVRVszXTtcbiAgICAgICAgYnVmZmVyWzhdID0gUFJPQ0VTU19VTklRVUVbNF07XG4gICAgICAgIGJ1ZmZlclsxMV0gPSBpbmMgJiAweGZmO1xuICAgICAgICBidWZmZXJbMTBdID0gKGluYyA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcls5XSA9IChpbmMgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgdG9TdHJpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5pZCk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIHN0YXRpYyBpcyh2YXJpYWJsZSkge1xuICAgICAgICByZXR1cm4gKHZhcmlhYmxlICE9IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YXJpYWJsZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICdfYnNvbnR5cGUnIGluIHZhcmlhYmxlICYmXG4gICAgICAgICAgICB2YXJpYWJsZS5fYnNvbnR5cGUgPT09ICdPYmplY3RJZCcpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJJZCkge1xuICAgICAgICBpZiAob3RoZXJJZCA9PT0gdW5kZWZpbmVkIHx8IG90aGVySWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0SWQuaXMob3RoZXJJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2tJZF1bMTFdID09PSBvdGhlcklkW2tJZF1bMTFdICYmIEJ5dGVVdGlscy5lcXVhbHModGhpc1trSWRdLCBvdGhlcklkW2tJZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RoZXJJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcklkLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90aGVySWQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvdGhlcklkLnRvSGV4U3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcklkU3RyaW5nID0gb3RoZXJJZC50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdGhpc0lkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlcklkU3RyaW5nID09PSAnc3RyaW5nJyAmJiBvdGhlcklkU3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IHRoaXNJZFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFRpbWVzdGFtcCgpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdGltZSA9IEJTT05EYXRhVmlldy5mcm9tVWludDhBcnJheSh0aGlzLmlkKS5nZXRVaW50MzIoMCwgZmFsc2UpO1xuICAgICAgICB0aW1lc3RhbXAuc2V0VGltZShNYXRoLmZsb29yKHRpbWUpICogMTAwMCk7XG4gICAgICAgIHJldHVybiB0aW1lc3RhbXA7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVQaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbVRpbWUodGltZSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIEJTT05EYXRhVmlldy5mcm9tVWludDhBcnJheShidWZmZXIpLnNldFVpbnQzMigwLCB0aW1lLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoYnVmZmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21IZXhTdHJpbmcoaGV4U3RyaW5nKSB7XG4gICAgICAgIGlmIChoZXhTdHJpbmc/Lmxlbmd0aCAhPT0gMjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2hleCBzdHJpbmcgbXVzdCBiZSAyNCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChCeXRlVXRpbHMuZnJvbUhleChoZXhTdHJpbmcpKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIGlmIChiYXNlNjQ/Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2Jhc2U2NCBzdHJpbmcgbXVzdCBiZSAxNiBjaGFyYWN0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChCeXRlVXRpbHMuZnJvbUJhc2U2NChiYXNlNjQpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWQoaWQpIHtcbiAgICAgICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgT2JqZWN0SWQoaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICBpZiAodGhpcy50b0hleFN0cmluZylcbiAgICAgICAgICAgIHJldHVybiB7ICRvaWQ6IHRoaXMudG9IZXhTdHJpbmcoKSB9O1xuICAgICAgICByZXR1cm4geyAkb2lkOiB0aGlzLnRvU3RyaW5nKCdoZXgnKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChkb2MuJG9pZCk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIHJldHVybiBgbmV3IE9iamVjdElkKCR7aW5zcGVjdCh0aGlzLnRvSGV4U3RyaW5nKCksIG9wdGlvbnMpfSlgO1xuICAgIH1cbn1cbk9iamVjdElkLmluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYpO1xuXG5mdW5jdGlvbiBpbnRlcm5hbENhbGN1bGF0ZU9iamVjdFNpemUob2JqZWN0LCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkge1xuICAgIGxldCB0b3RhbExlbmd0aCA9IDQgKyAxO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNhbGN1bGF0ZUVsZW1lbnQoaS50b1N0cmluZygpLCBvYmplY3RbaV0sIHNlcmlhbGl6ZUZ1bmN0aW9ucywgdHJ1ZSwgaWdub3JlVW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Q/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnRvQlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNhbGN1bGF0ZUVsZW1lbnQoa2V5LCBvYmplY3Rba2V5XSwgc2VyaWFsaXplRnVuY3Rpb25zLCBmYWxzZSwgaWdub3JlVW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWxMZW5ndGg7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVFbGVtZW50KG5hbWUsIHZhbHVlLCBzZXJpYWxpemVGdW5jdGlvbnMgPSBmYWxzZSwgaXNBcnJheSA9IGZhbHNlLCBpZ25vcmVVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvQlNPTigpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIDEgKyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxICsgNCArIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZSkgKyAxO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIHZhbHVlID49IEpTX0lOVF9NSU4gJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA8PSBKU19JTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IEJTT05fSU5UMzJfTUlOICYmIHZhbHVlIDw9IEJTT05fSU5UMzJfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICBpZiAoaXNBcnJheSB8fCAhaWdub3JlVW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDEgKyAxKTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLl9ic29udHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDEyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoMSArIDQgKyAxKSArIHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuX2Jzb250eXBlID09PSAnVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RlY2ltYWwxMjgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoMTYgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnNjb3BlICE9IG51bGwgJiYgT2JqZWN0LmtleXModmFsdWUuc2NvcGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5jb2RlLnRvU3RyaW5nKCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKHZhbHVlLnNjb3BlLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUuY29kZS50b1N0cmluZygpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmFyeS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmFyeS5wb3NpdGlvbiArIDEgKyA0ICsgMSArIDQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArIChiaW5hcnkucG9zaXRpb24gKyAxICsgNCArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdTeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgIDQgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkX3ZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAkcmVmOiB2YWx1ZS5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAkaWQ6IHZhbHVlLm9pZFxuICAgICAgICAgICAgICAgIH0sIHZhbHVlLmZpZWxkcyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRiICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZF92YWx1ZXNbJyRkYiddID0gdmFsdWUuZGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbENhbGN1bGF0ZU9iamVjdFNpemUob3JkZXJlZF92YWx1ZXMsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLmdsb2JhbCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5pZ25vcmVDYXNlID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLm11bHRpbGluZSA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnBhdHRlcm4pICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5vcHRpb25zKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKHZhbHVlLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkgK1xuICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnRvU3RyaW5nKCkpICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhbHBoYWJldGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcnKS5zb3J0KCkuam9pbignJyk7XG59XG5jbGFzcyBCU09OUmVnRXhwIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05SZWdFeHAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGFscGhhYmV0aXplKG9wdGlvbnMgPz8gJycpO1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmluZGV4T2YoJ1xceDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCU09OIFJlZ2V4IHBhdHRlcm5zIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMucGF0dGVybil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmRleE9mKCdcXHgwMCcpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQlNPTiBSZWdleCBvcHRpb25zIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMub3B0aW9uc1tpXSA9PT0gJ2knIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAnbScgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICd4JyB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9PT0gJ2wnIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAncycgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICd1JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBUaGUgcmVndWxhciBleHByZXNzaW9uIG9wdGlvbiBbJHt0aGlzLm9wdGlvbnNbaV19XSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zID8gb3B0aW9ucy5zcGxpdCgnJykuc29ydCgpLmpvaW4oJycpIDogJyc7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJHJlZ2V4OiB0aGlzLnBhdHRlcm4sICRvcHRpb25zOiB0aGlzLm9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAkcmVndWxhckV4cHJlc3Npb246IHsgcGF0dGVybjogdGhpcy5wYXR0ZXJuLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgaWYgKCckcmVnZXgnIGluIGRvYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2MuJHJlZ2V4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChkb2MuJHJlZ2V4Ll9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCU09OUmVnRXhwKGRvYy4kcmVnZXgsIEJTT05SZWdFeHAucGFyc2VPcHRpb25zKGRvYy4kb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgnJHJlZ3VsYXJFeHByZXNzaW9uJyBpbiBkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQlNPTlJlZ0V4cChkb2MuJHJlZ3VsYXJFeHByZXNzaW9uLnBhdHRlcm4sIEJTT05SZWdFeHAucGFyc2VPcHRpb25zKGRvYy4kcmVndWxhckV4cHJlc3Npb24ub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVuZXhwZWN0ZWQgQlNPTlJlZ0V4cCBFSlNPTiBvYmplY3QgZm9ybTogJHtKU09OLnN0cmluZ2lmeShkb2MpfWApO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGNvbnN0IHN0eWxpemUgPSBnZXRTdHlsaXplRnVuY3Rpb24ob3B0aW9ucykgPz8gKHYgPT4gdik7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gc3R5bGl6ZShpbnNwZWN0KHRoaXMucGF0dGVybiksICdyZWdleHAnKTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBzdHlsaXplKGluc3BlY3QodGhpcy5vcHRpb25zKSwgJ3JlZ2V4cCcpO1xuICAgICAgICByZXR1cm4gYG5ldyBCU09OUmVnRXhwKCR7cGF0dGVybn0sICR7ZmxhZ3N9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBCU09OU3ltYm9sIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05TeW1ib2wnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkc3ltYm9sOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IEJTT05TeW1ib2woZG9jLiRzeW1ib2wpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICByZXR1cm4gYG5ldyBCU09OU3ltYm9sKCR7aW5zcGVjdCh0aGlzLnZhbHVlLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5cbmNvbnN0IExvbmdXaXRob3V0T3ZlcnJpZGVzQ2xhc3MgPSBMb25nO1xuY2xhc3MgVGltZXN0YW1wIGV4dGVuZHMgTG9uZ1dpdGhvdXRPdmVycmlkZXNDbGFzcyB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdUaW1lc3RhbXAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihsb3cpIHtcbiAgICAgICAgaWYgKGxvdyA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdXBlcigwLCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgc3VwZXIobG93LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChMb25nLmlzTG9uZyhsb3cpKSB7XG4gICAgICAgICAgICBzdXBlcihsb3cubG93LCBsb3cuaGlnaCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvdyA9PT0gJ29iamVjdCcgJiYgJ3QnIGluIGxvdyAmJiAnaScgaW4gbG93KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvdy50ICE9PSAnbnVtYmVyJyAmJiAodHlwZW9mIGxvdy50ICE9PSAnb2JqZWN0JyB8fCBsb3cudC5fYnNvbnR5cGUgIT09ICdJbnQzMicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIHQgYXMgYSBudW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG93LmkgIT09ICdudW1iZXInICYmICh0eXBlb2YgbG93LmkgIT09ICdvYmplY3QnIHx8IGxvdy5pLl9ic29udHlwZSAhPT0gJ0ludDMyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgaSBhcyBhIG51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9IE51bWJlcihsb3cudCk7XG4gICAgICAgICAgICBjb25zdCBpID0gTnVtYmVyKGxvdy5pKTtcbiAgICAgICAgICAgIGlmICh0IDwgMCB8fCBOdW1iZXIuaXNOYU4odCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgYSBwb3NpdGl2ZSB0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgTnVtYmVyLmlzTmFOKGkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIGEgcG9zaXRpdmUgaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIHQgZXF1YWwgb3IgbGVzcyB0aGFuIHVpbnQzMiBtYXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSBpIGVxdWFsIG9yIGxlc3MgdGhhbiB1aW50MzIgbWF4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXBlcihpLCB0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0EgVGltZXN0YW1wIGNhbiBvbmx5IGJlIGNvbnN0cnVjdGVkIHdpdGg6IGJpZ2ludCwgTG9uZywgb3IgeyB0OiBudW1iZXI7IGk6IG51bWJlciB9Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJHRpbWVzdGFtcDogdGhpcy50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKExvbmcuZnJvbUludCh2YWx1ZSwgdHJ1ZSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChMb25nLmZyb21OdW1iZXIodmFsdWUsIHRydWUpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHsgaTogbG93Qml0cywgdDogaGlnaEJpdHMgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0ciwgb3B0UmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoTG9uZy5mcm9tU3RyaW5nKHN0ciwgdHJ1ZSwgb3B0UmFkaXgpKTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICR0aW1lc3RhbXA6IHsgdDogdGhpcy5oaWdoID4+PiAwLCBpOiB0aGlzLmxvdyA+Pj4gMCB9IH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICBjb25zdCBpID0gTG9uZy5pc0xvbmcoZG9jLiR0aW1lc3RhbXAuaSlcbiAgICAgICAgICAgID8gZG9jLiR0aW1lc3RhbXAuaS5nZXRMb3dCaXRzVW5zaWduZWQoKVxuICAgICAgICAgICAgOiBkb2MuJHRpbWVzdGFtcC5pO1xuICAgICAgICBjb25zdCB0ID0gTG9uZy5pc0xvbmcoZG9jLiR0aW1lc3RhbXAudClcbiAgICAgICAgICAgID8gZG9jLiR0aW1lc3RhbXAudC5nZXRMb3dCaXRzVW5zaWduZWQoKVxuICAgICAgICAgICAgOiBkb2MuJHRpbWVzdGFtcC50O1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7IHQsIGkgfSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIGNvbnN0IHQgPSBpbnNwZWN0KHRoaXMuaGlnaCA+Pj4gMCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGkgPSBpbnNwZWN0KHRoaXMubG93ID4+PiAwLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGBuZXcgVGltZXN0YW1wKHsgdDogJHt0fSwgaTogJHtpfSB9KWA7XG4gICAgfVxufVxuVGltZXN0YW1wLk1BWF9WQUxVRSA9IExvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFO1xuXG5jb25zdCBGSVJTVF9CSVQgPSAweDgwO1xuY29uc3QgRklSU1RfVFdPX0JJVFMgPSAweGMwO1xuY29uc3QgRklSU1RfVEhSRUVfQklUUyA9IDB4ZTA7XG5jb25zdCBGSVJTVF9GT1VSX0JJVFMgPSAweGYwO1xuY29uc3QgRklSU1RfRklWRV9CSVRTID0gMHhmODtcbmNvbnN0IFRXT19CSVRfQ0hBUiA9IDB4YzA7XG5jb25zdCBUSFJFRV9CSVRfQ0hBUiA9IDB4ZTA7XG5jb25zdCBGT1VSX0JJVF9DSEFSID0gMHhmMDtcbmNvbnN0IENPTlRJTlVJTkdfQ0hBUiA9IDB4ODA7XG5mdW5jdGlvbiB2YWxpZGF0ZVV0ZjgoYnl0ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgY29udGludWF0aW9uID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBieXRlID0gYnl0ZXNbaV07XG4gICAgICAgIGlmIChjb250aW51YXRpb24pIHtcbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIEZJUlNUX1RXT19CSVRTKSAhPT0gQ09OVElOVUlOR19DSEFSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWF0aW9uIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZSAmIEZJUlNUX0JJVCkge1xuICAgICAgICAgICAgaWYgKChieXRlICYgRklSU1RfVEhSRUVfQklUUykgPT09IFRXT19CSVRfQ0hBUikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVhdGlvbiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoYnl0ZSAmIEZJUlNUX0ZPVVJfQklUUykgPT09IFRIUkVFX0JJVF9DSEFSKSB7XG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChieXRlICYgRklSU1RfRklWRV9CSVRTKSA9PT0gRk9VUl9CSVRfQ0hBUikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVhdGlvbiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFjb250aW51YXRpb247XG59XG5cbmNvbnN0IEpTX0lOVF9NQVhfTE9ORyA9IExvbmcuZnJvbU51bWJlcihKU19JTlRfTUFYKTtcbmNvbnN0IEpTX0lOVF9NSU5fTE9ORyA9IExvbmcuZnJvbU51bWJlcihKU19JTlRfTUlOKTtcbmZ1bmN0aW9uIGludGVybmFsRGVzZXJpYWxpemUoYnVmZmVyLCBvcHRpb25zLCBpc0FycmF5KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPT0gbnVsbCA/IHt9IDogb3B0aW9ucztcbiAgICBjb25zdCBpbmRleCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmRleCA/IG9wdGlvbnMuaW5kZXggOiAwO1xuICAgIGNvbnN0IHNpemUgPSBidWZmZXJbaW5kZXhdIHxcbiAgICAgICAgKGJ1ZmZlcltpbmRleCArIDFdIDw8IDgpIHxcbiAgICAgICAgKGJ1ZmZlcltpbmRleCArIDJdIDw8IDE2KSB8XG4gICAgICAgIChidWZmZXJbaW5kZXggKyAzXSA8PCAyNCk7XG4gICAgaWYgKHNpemUgPCA1KSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYGJzb24gc2l6ZSBtdXN0IGJlID49IDUsIGlzICR7c2l6ZX1gKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dPYmplY3RTbWFsbGVyVGhhbkJ1ZmZlclNpemUgJiYgYnVmZmVyLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgYnVmZmVyIGxlbmd0aCAke2J1ZmZlci5sZW5ndGh9IG11c3QgYmUgPj0gYnNvbiBzaXplICR7c2l6ZX1gKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmFsbG93T2JqZWN0U21hbGxlclRoYW5CdWZmZXJTaXplICYmIGJ1ZmZlci5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgYnVmZmVyIGxlbmd0aCAke2J1ZmZlci5sZW5ndGh9IG11c3QgPT09IGJzb24gc2l6ZSAke3NpemV9YCk7XG4gICAgfVxuICAgIGlmIChzaXplICsgaW5kZXggPiBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGAoYnNvbiBzaXplICR7c2l6ZX0gKyBvcHRpb25zLmluZGV4ICR7aW5kZXh9IG11c3QgYmUgPD0gYnVmZmVyIGxlbmd0aCAke2J1ZmZlci5ieXRlTGVuZ3RofSlgKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlcltpbmRleCArIHNpemUgLSAxXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKFwiT25lIG9iamVjdCwgc2l6ZWQgY29ycmVjdGx5LCB3aXRoIGEgc3BvdCBmb3IgYW4gRU9PLCBidXQgdGhlIEVPTyBpc24ndCAweDAwXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBpbmRleCwgb3B0aW9ucywgaXNBcnJheSk7XG59XG5jb25zdCBhbGxvd2VkREJSZWZLZXlzID0gL15cXCRyZWYkfF5cXCRpZCR8XlxcJGRiJC87XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGluZGV4LCBvcHRpb25zLCBpc0FycmF5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBmaWVsZHNBc1JhdyA9IG9wdGlvbnNbJ2ZpZWxkc0FzUmF3J10gPT0gbnVsbCA/IG51bGwgOiBvcHRpb25zWydmaWVsZHNBc1JhdyddO1xuICAgIGNvbnN0IHJhdyA9IG9wdGlvbnNbJ3JhdyddID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnNbJ3JhdyddO1xuICAgIGNvbnN0IGJzb25SZWdFeHAgPSB0eXBlb2Ygb3B0aW9uc1snYnNvblJlZ0V4cCddID09PSAnYm9vbGVhbicgPyBvcHRpb25zWydic29uUmVnRXhwJ10gOiBmYWxzZTtcbiAgICBjb25zdCBwcm9tb3RlQnVmZmVycyA9IG9wdGlvbnMucHJvbW90ZUJ1ZmZlcnMgPz8gZmFsc2U7XG4gICAgY29uc3QgcHJvbW90ZUxvbmdzID0gb3B0aW9ucy5wcm9tb3RlTG9uZ3MgPz8gdHJ1ZTtcbiAgICBjb25zdCBwcm9tb3RlVmFsdWVzID0gb3B0aW9ucy5wcm9tb3RlVmFsdWVzID8/IHRydWU7XG4gICAgY29uc3QgdXNlQmlnSW50NjQgPSBvcHRpb25zLnVzZUJpZ0ludDY0ID8/IGZhbHNlO1xuICAgIGlmICh1c2VCaWdJbnQ2NCAmJiAhcHJvbW90ZVZhbHVlcykge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdNdXN0IGVpdGhlciByZXF1ZXN0IGJpZ2ludCBvciBMb25nIGZvciBpbnQ2NCBkZXNlcmlhbGl6YXRpb24nKTtcbiAgICB9XG4gICAgaWYgKHVzZUJpZ0ludDY0ICYmICFwcm9tb3RlTG9uZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignTXVzdCBlaXRoZXIgcmVxdWVzdCBiaWdpbnQgb3IgTG9uZyBmb3IgaW50NjQgZGVzZXJpYWxpemF0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSBvcHRpb25zLnZhbGlkYXRpb24gPT0gbnVsbCA/IHsgdXRmODogdHJ1ZSB9IDogb3B0aW9ucy52YWxpZGF0aW9uO1xuICAgIGxldCBnbG9iYWxVVEZWYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICBsZXQgdmFsaWRhdGlvblNldHRpbmc7XG4gICAgY29uc3QgdXRmOEtleXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdXRmOFZhbGlkYXRlZEtleXMgPSB2YWxpZGF0aW9uLnV0Zjg7XG4gICAgaWYgKHR5cGVvZiB1dGY4VmFsaWRhdGVkS2V5cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhbGlkYXRpb25TZXR0aW5nID0gdXRmOFZhbGlkYXRlZEtleXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxVVEZWYWxpZGF0aW9uID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHV0ZjhWYWxpZGF0aW9uVmFsdWVzID0gT2JqZWN0LmtleXModXRmOFZhbGlkYXRlZEtleXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRmOFZhbGlkYXRlZEtleXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1dGY4VmFsaWRhdGlvblZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1VURi04IHZhbGlkYXRpb24gc2V0dGluZyBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHV0ZjhWYWxpZGF0aW9uVmFsdWVzWzBdICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVVRGLTggdmFsaWRhdGlvbiBvcHRpb24sIG11c3Qgc3BlY2lmeSBib29sZWFuIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRpb25TZXR0aW5nID0gdXRmOFZhbGlkYXRpb25WYWx1ZXNbMF07XG4gICAgICAgIGlmICghdXRmOFZhbGlkYXRpb25WYWx1ZXMuZXZlcnkoaXRlbSA9PiBpdGVtID09PSB2YWxpZGF0aW9uU2V0dGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVVRGLTggdmFsaWRhdGlvbiBvcHRpb24gLSBrZXlzIG11c3QgYmUgYWxsIHRydWUgb3IgYWxsIGZhbHNlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFnbG9iYWxVVEZWYWxpZGF0aW9uKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHV0ZjhWYWxpZGF0ZWRLZXlzKSkge1xuICAgICAgICAgICAgdXRmOEtleXNTZXQuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgNSlcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29ycnVwdCBic29uIG1lc3NhZ2UgPCA1IGJ5dGVzIGxvbmcnKTtcbiAgICBjb25zdCBzaXplID0gYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgaWYgKHNpemUgPCA1IHx8IHNpemUgPiBidWZmZXIubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0IGJzb24gbWVzc2FnZScpO1xuICAgIGNvbnN0IG9iamVjdCA9IGlzQXJyYXkgPyBbXSA6IHt9O1xuICAgIGxldCBhcnJheUluZGV4ID0gMDtcbiAgICBjb25zdCBkb25lID0gZmFsc2U7XG4gICAgbGV0IGlzUG9zc2libGVEQlJlZiA9IGlzQXJyYXkgPyBmYWxzZSA6IG51bGw7XG4gICAgY29uc3QgZGF0YXZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFR5cGUgPSBidWZmZXJbaW5kZXgrK107XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgaSA9IGluZGV4O1xuICAgICAgICB3aGlsZSAoYnVmZmVyW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCYWQgQlNPTiBEb2N1bWVudDogaWxsZWdhbCBDU3RyaW5nJyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpc0FycmF5ID8gYXJyYXlJbmRleCsrIDogQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpKTtcbiAgICAgICAgbGV0IHNob3VsZFZhbGlkYXRlS2V5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGdsb2JhbFVURlZhbGlkYXRpb24gfHwgdXRmOEtleXNTZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBzaG91bGRWYWxpZGF0ZUtleSA9IHZhbGlkYXRpb25TZXR0aW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2hvdWxkVmFsaWRhdGVLZXkgPSAhdmFsaWRhdGlvblNldHRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUG9zc2libGVEQlJlZiAhPT0gZmFsc2UgJiYgbmFtZVswXSA9PT0gJyQnKSB7XG4gICAgICAgICAgICBpc1Bvc3NpYmxlREJSZWYgPSBhbGxvd2VkREJSZWZLZXlzLnRlc3QobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpbmRleCA9IGkgKyAxO1xuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9TVFJJTkcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBnZXRWYWxpZGF0ZWRTdHJpbmcoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgc2hvdWxkVmFsaWRhdGVLZXkpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9PSUQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9pZCA9IEJ5dGVVdGlscy5hbGxvY2F0ZSgxMik7XG4gICAgICAgICAgICBvaWQuc2V0KGJ1ZmZlci5zdWJhcnJheShpbmRleCwgaW5kZXggKyAxMikpO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgT2JqZWN0SWQob2lkKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0lOVCAmJiBwcm9tb3RlVmFsdWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgSW50MzIoYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfSU5UKSB7XG4gICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9OVU1CRVIgJiYgcHJvbW90ZVZhbHVlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERvdWJsZShkYXRhdmlldy5nZXRGbG9hdDY0KGluZGV4LCB0cnVlKSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX05VTUJFUikge1xuICAgICAgICAgICAgdmFsdWUgPSBkYXRhdmlldy5nZXRGbG9hdDY0KGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfREFURSkge1xuICAgICAgICAgICAgY29uc3QgbG93Qml0cyA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgY29uc3QgaGlnaEJpdHMgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUobmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMpLnRvTnVtYmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQk9PTEVBTikge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpbmRleF0gIT09IDAgJiYgYnVmZmVyW2luZGV4XSAhPT0gMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdpbGxlZ2FsIGJvb2xlYW4gdHlwZSB2YWx1ZScpO1xuICAgICAgICAgICAgdmFsdWUgPSBidWZmZXJbaW5kZXgrK10gPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9PQkpFQ1QpIHtcbiAgICAgICAgICAgIGNvbnN0IF9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0U2l6ZSA9IGJ1ZmZlcltpbmRleF0gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCArIDJdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCArIDNdIDw8IDI0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3RTaXplIDw9IDAgfHwgb2JqZWN0U2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgZW1iZWRkZWQgZG9jdW1lbnQgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyBvYmplY3RTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBvYmplY3RPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbFVURlZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0T3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdmFsaWRhdGlvbjogeyB1dGY4OiBzaG91bGRWYWxpZGF0ZUtleSB9IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBfaW5kZXgsIG9iamVjdE9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBvYmplY3RTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQVJSQVkpIHtcbiAgICAgICAgICAgIGNvbnN0IF9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0U2l6ZSA9IGJ1ZmZlcltpbmRleF0gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCArIDJdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCArIDNdIDw8IDI0KTtcbiAgICAgICAgICAgIGxldCBhcnJheU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3Qgc3RvcEluZGV4ID0gaW5kZXggKyBvYmplY3RTaXplO1xuICAgICAgICAgICAgaWYgKGZpZWxkc0FzUmF3ICYmIGZpZWxkc0FzUmF3W25hbWVdKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlPcHRpb25zID0geyAuLi5vcHRpb25zLCByYXc6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZ2xvYmFsVVRGVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgIGFycmF5T3B0aW9ucyA9IHsgLi4uYXJyYXlPcHRpb25zLCB2YWxpZGF0aW9uOiB7IHV0Zjg6IHNob3VsZFZhbGlkYXRlS2V5IH0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gZGVzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBfaW5kZXgsIGFycmF5T3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcbiAgICAgICAgICAgIGlmIChidWZmZXJbaW5kZXggLSAxXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdpbnZhbGlkIGFycmF5IHRlcm1pbmF0b3IgYnl0ZScpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBzdG9wSW5kZXgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29ycnVwdGVkIGFycmF5IGJzb24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1VOREVGSU5FRCkge1xuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9OVUxMKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9MT05HKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhdmlldyA9IEJTT05EYXRhVmlldy5mcm9tVWludDhBcnJheShidWZmZXIuc3ViYXJyYXkoaW5kZXgsIGluZGV4ICsgOCkpO1xuICAgICAgICAgICAgY29uc3QgbG93Qml0cyA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgY29uc3QgaGlnaEJpdHMgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvbmcgPSBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cyk7XG4gICAgICAgICAgICBpZiAodXNlQmlnSW50NjQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGF2aWV3LmdldEJpZ0ludDY0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvbW90ZUxvbmdzICYmIHByb21vdGVWYWx1ZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIGxvbmcubGVzc1RoYW5PckVxdWFsKEpTX0lOVF9NQVhfTE9ORykgJiYgbG9uZy5ncmVhdGVyVGhhbk9yRXF1YWwoSlNfSU5UX01JTl9MT05HKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBsb25nLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbG9uZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbG9uZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0RFQ0lNQUwxMjgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gQnl0ZVV0aWxzLmFsbG9jYXRlKDE2KTtcbiAgICAgICAgICAgIGJ5dGVzLnNldChidWZmZXIuc3ViYXJyYXkoaW5kZXgsIGluZGV4ICsgMTYpLCAwKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxNjtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERlY2ltYWwxMjgoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQklOQVJZKSB7XG4gICAgICAgICAgICBsZXQgYmluYXJ5U2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgY29uc3QgdG90YWxCaW5hcnlTaXplID0gYmluYXJ5U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IHN1YlR5cGUgPSBidWZmZXJbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignTmVnYXRpdmUgYmluYXJ5IHR5cGUgZWxlbWVudCBzaXplIGZvdW5kJyk7XG4gICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA+IGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSB0eXBlIHNpemUgbGFyZ2VyIHRoYW4gZG9jdW1lbnQgc2l6ZScpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclsnc2xpY2UnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YlR5cGUgPT09IEJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2l6ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignTmVnYXRpdmUgYmluYXJ5IHR5cGUgZWxlbWVudCBzaXplIGZvdW5kIGZvciBzdWJ0eXBlIDB4MDInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPiB0b3RhbEJpbmFyeVNpemUgLSA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IHR5cGUgd2l0aCBzdWJ0eXBlIDB4MDIgY29udGFpbnMgdG9vIGxvbmcgYmluYXJ5IHNpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPCB0b3RhbEJpbmFyeVNpemUgLSA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IHR5cGUgd2l0aCBzdWJ0eXBlIDB4MDIgY29udGFpbnMgdG9vIHNob3J0IGJpbmFyeSBzaXplJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9tb3RlQnVmZmVycyAmJiBwcm9tb3RlVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyBiaW5hcnlTaXplKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBCaW5hcnkoYnVmZmVyLnNsaWNlKGluZGV4LCBpbmRleCArIGJpbmFyeVNpemUpLCBzdWJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YlR5cGUgPT09IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgJiYgVVVJRC5pc1ZhbGlkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1VVSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9idWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoYmluYXJ5U2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YlR5cGUgPT09IEJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2l6ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignTmVnYXRpdmUgYmluYXJ5IHR5cGUgZWxlbWVudCBzaXplIGZvdW5kIGZvciBzdWJ0eXBlIDB4MDInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPiB0b3RhbEJpbmFyeVNpemUgLSA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IHR5cGUgd2l0aCBzdWJ0eXBlIDB4MDIgY29udGFpbnMgdG9vIGxvbmcgYmluYXJ5IHNpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPCB0b3RhbEJpbmFyeVNpemUgLSA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IHR5cGUgd2l0aCBzdWJ0eXBlIDB4MDIgY29udGFpbnMgdG9vIHNob3J0IGJpbmFyeSBzaXplJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiaW5hcnlTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2J1ZmZlcltpXSA9IGJ1ZmZlcltpbmRleCArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvbW90ZUJ1ZmZlcnMgJiYgcHJvbW90ZVZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9idWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBCaW5hcnkoYnVmZmVyLnNsaWNlKGluZGV4LCBpbmRleCArIGJpbmFyeVNpemUpLCBzdWJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YlR5cGUgPT09IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgJiYgVVVJRC5pc1ZhbGlkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1VVSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBiaW5hcnlTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfUkVHRVhQICYmIGJzb25SZWdFeHAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpID0gaW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVyW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCYWQgQlNPTiBEb2N1bWVudDogaWxsZWdhbCBDU3RyaW5nJyk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGkpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ0V4cE9wdGlvbnMgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGkpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNBcnJheSA9IG5ldyBBcnJheShyZWdFeHBPcHRpb25zLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVnRXhwT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVnRXhwT3B0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNBcnJheVtpXSA9ICdtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNBcnJheVtpXSA9ICdnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNBcnJheVtpXSA9ICdpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cChzb3VyY2UsIG9wdGlvbnNBcnJheS5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9SRUdFWFAgJiYgYnNvblJlZ0V4cCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaSA9IGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMHgwMCAmJiBpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpKTtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICBpID0gaW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVyW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCYWQgQlNPTiBEb2N1bWVudDogaWxsZWdhbCBDU3RyaW5nJyk7XG4gICAgICAgICAgICBjb25zdCByZWdFeHBPcHRpb25zID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpKTtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBCU09OUmVnRXhwKHNvdXJjZSwgcmVnRXhwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9TWU1CT0wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gZ2V0VmFsaWRhdGVkU3RyaW5nKGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEsIHNob3VsZFZhbGlkYXRlS2V5KTtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvbW90ZVZhbHVlcyA/IHN5bWJvbCA6IG5ldyBCU09OU3ltYm9sKHN5bWJvbCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgc3RyaW5nU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1RJTUVTVEFNUCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGJ1ZmZlcltpbmRleCsrXSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgOCkgK1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSAqICgxIDw8IDE2KSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgMjQpO1xuICAgICAgICAgICAgY29uc3QgdCA9IGJ1ZmZlcltpbmRleCsrXSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgOCkgK1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSAqICgxIDw8IDE2KSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgMjQpO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgVGltZXN0YW1wKHsgaSwgdCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX01JTl9LRVkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IE1pbktleSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTUFYX0tFWSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTWF4S2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9DT0RFKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdTaXplID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nU2l6ZSA8PSAwIHx8XG4gICAgICAgICAgICAgICAgc3RyaW5nU2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleCB8fFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIHN0cmluZ1NpemUgLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gZ2V0VmFsaWRhdGVkU3RyaW5nKGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEsIHNob3VsZFZhbGlkYXRlS2V5KTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IENvZGUoZnVuY3Rpb25TdHJpbmcpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9DT0RFX1dfU0NPUEUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgaWYgKHRvdGFsU2l6ZSA8IDQgKyA0ICsgNCArIDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb2RlX3dfc2NvcGUgdG90YWwgc2l6ZSBzaG9ydGVyIG1pbmltdW0gZXhwZWN0ZWQgbGVuZ3RoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdTaXplID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nU2l6ZSA8PSAwIHx8XG4gICAgICAgICAgICAgICAgc3RyaW5nU2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleCB8fFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIHN0cmluZ1NpemUgLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gZ2V0VmFsaWRhdGVkU3RyaW5nKGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEsIHNob3VsZFZhbGlkYXRlS2V5KTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICAgICAgY29uc3QgX2luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RTaXplID0gYnVmZmVyW2luZGV4XSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgMl0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgM10gPDwgMjQpO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVPYmplY3QgPSBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIsIF9pbmRleCwgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIG9iamVjdFNpemU7XG4gICAgICAgICAgICBpZiAodG90YWxTaXplIDwgNCArIDQgKyBvYmplY3RTaXplICsgc3RyaW5nU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvZGVfd19zY29wZSB0b3RhbCBzaXplIGlzIHRvbyBzaG9ydCwgdHJ1bmNhdGluZyBzY29wZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvdGFsU2l6ZSA+IDQgKyA0ICsgb2JqZWN0U2l6ZSArIHN0cmluZ1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb2RlX3dfc2NvcGUgdG90YWwgc2l6ZSBpcyB0b28gbG9uZywgY2xpcHMgb3V0ZXIgZG9jdW1lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbmV3IENvZGUoZnVuY3Rpb25TdHJpbmcsIHNjb3BlT2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0RCUE9JTlRFUikge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb24gIT0gbnVsbCAmJiB2YWxpZGF0aW9uLnV0ZjgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlVXRmOChidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdJbnZhbGlkIFVURi04IHN0cmluZyBpbiBCU09OIGRvY3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICAgICAgY29uc3Qgb2lkQnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKDEyKTtcbiAgICAgICAgICAgIG9pZEJ1ZmZlci5zZXQoYnVmZmVyLnN1YmFycmF5KGluZGV4LCBpbmRleCArIDEyKSwgMCk7XG4gICAgICAgICAgICBjb25zdCBvaWQgPSBuZXcgT2JqZWN0SWQob2lkQnVmZmVyKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxMjtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERCUmVmKG5hbWVzcGFjZSwgb2lkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYERldGVjdGVkIHVua25vd24gQlNPTiB0eXBlICR7ZWxlbWVudFR5cGUudG9TdHJpbmcoMTYpfSBmb3IgZmllbGRuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNpemUgIT09IGluZGV4IC0gc3RhcnRJbmRleCkge1xuICAgICAgICBpZiAoaXNBcnJheSlcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHQgYXJyYXkgYnNvbicpO1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0IG9iamVjdCBic29uJyk7XG4gICAgfVxuICAgIGlmICghaXNQb3NzaWJsZURCUmVmKVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIGlmIChpc0RCUmVmTGlrZShvYmplY3QpKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QpO1xuICAgICAgICBkZWxldGUgY29weS4kcmVmO1xuICAgICAgICBkZWxldGUgY29weS4kaWQ7XG4gICAgICAgIGRlbGV0ZSBjb3B5LiRkYjtcbiAgICAgICAgcmV0dXJuIG5ldyBEQlJlZihvYmplY3QuJHJlZiwgb2JqZWN0LiRpZCwgb2JqZWN0LiRkYiwgY29weSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZWRTdHJpbmcoYnVmZmVyLCBzdGFydCwgZW5kLCBzaG91bGRWYWxpZGF0ZVV0ZjgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBzdGFydCwgZW5kKTtcbiAgICBpZiAoc2hvdWxkVmFsaWRhdGVVdGY4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5jaGFyQ29kZUF0KGkpID09PSAweGZmZmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlVXRmOChidWZmZXIsIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVVRGLTggc3RyaW5nIGluIEJTT04gZG9jdW1lbnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5jb25zdCByZWdleHAgPSAvXFx4MDAvO1xuY29uc3QgaWdub3JlS2V5cyA9IG5ldyBTZXQoWyckZGInLCAnJHJlZicsICckaWQnLCAnJGNsdXN0ZXJUaW1lJ10pO1xuZnVuY3Rpb24gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfU1RSSU5HO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzICsgMTtcbiAgICBidWZmZXJbaW5kZXggLSAxXSA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIHZhbHVlLCBpbmRleCArIDQpO1xuICAgIGJ1ZmZlcltpbmRleCArIDNdID0gKChzaXplICsgMSkgPj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAyXSA9ICgoc2l6ZSArIDEpID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4ICsgMV0gPSAoKHNpemUgKyAxKSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4XSA9IChzaXplICsgMSkgJiAweGZmO1xuICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmNvbnN0IE5VTUJFUl9TUEFDRSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCksIDAsIDgpO1xuY29uc3QgRk9VUl9CWVRFX1ZJRVdfT05fTlVNQkVSID0gbmV3IFVpbnQ4QXJyYXkoTlVNQkVSX1NQQUNFLmJ1ZmZlciwgMCwgNCk7XG5jb25zdCBFSUdIVF9CWVRFX1ZJRVdfT05fTlVNQkVSID0gbmV3IFVpbnQ4QXJyYXkoTlVNQkVSX1NQQUNFLmJ1ZmZlciwgMCwgOCk7XG5mdW5jdGlvbiBzZXJpYWxpemVOdW1iZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGNvbnN0IGlzTmVnYXRpdmVaZXJvID0gT2JqZWN0LmlzKHZhbHVlLCAtMCk7XG4gICAgY29uc3QgdHlwZSA9ICFpc05lZ2F0aXZlWmVybyAmJlxuICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUgPD0gQlNPTl9JTlQzMl9NQVggJiZcbiAgICAgICAgdmFsdWUgPj0gQlNPTl9JTlQzMl9NSU5cbiAgICAgICAgPyBCU09OX0RBVEFfSU5UXG4gICAgICAgIDogQlNPTl9EQVRBX05VTUJFUjtcbiAgICBpZiAodHlwZSA9PT0gQlNPTl9EQVRBX0lOVCkge1xuICAgICAgICBOVU1CRVJfU1BBQ0Uuc2V0SW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgTlVNQkVSX1NQQUNFLnNldEZsb2F0NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IHR5cGUgPT09IEJTT05fREFUQV9JTlQgPyBGT1VSX0JZVEVfVklFV19PTl9OVU1CRVIgOiBFSUdIVF9CWVRFX1ZJRVdfT05fTlVNQkVSO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHR5cGU7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBidWZmZXIuc2V0KGJ5dGVzLCBpbmRleCk7XG4gICAgaW5kZXggKz0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCaWdJbnQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9MT05HO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggKz0gbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBOVU1CRVJfU1BBQ0Uuc2V0QmlnSW50NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgIGJ1ZmZlci5zZXQoRUlHSFRfQllURV9WSUVXX09OX05VTUJFUiwgaW5kZXgpO1xuICAgIGluZGV4ICs9IEVJR0hUX0JZVEVfVklFV19PTl9OVU1CRVIuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCBfLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9OVUxMO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQm9vbGVhbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0JPT0xFQU47XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBidWZmZXJbaW5kZXgrK10gPSB2YWx1ZSA/IDEgOiAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9EQVRFO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3QgZGF0ZUluTWlsaXMgPSBMb25nLmZyb21OdW1iZXIodmFsdWUuZ2V0VGltZSgpKTtcbiAgICBjb25zdCBsb3dCaXRzID0gZGF0ZUluTWlsaXMuZ2V0TG93Qml0cygpO1xuICAgIGNvbnN0IGhpZ2hCaXRzID0gZGF0ZUluTWlsaXMuZ2V0SGlnaEJpdHMoKTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBsb3dCaXRzICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGxvd0JpdHMgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IGhpZ2hCaXRzICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoaGlnaEJpdHMgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiAyNCkgJiAweGZmO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX1JFR0VYUDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGlmICh2YWx1ZS5zb3VyY2UgJiYgdmFsdWUuc291cmNlLm1hdGNoKHJlZ2V4cCkgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCd2YWx1ZSAnICsgdmFsdWUuc291cmNlICsgJyBtdXN0IG5vdCBjb250YWluIG51bGwgYnl0ZXMnKTtcbiAgICB9XG4gICAgaW5kZXggPSBpbmRleCArIEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIHZhbHVlLnNvdXJjZSwgaW5kZXgpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgaWYgKHZhbHVlLmlnbm9yZUNhc2UpXG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4Njk7XG4gICAgaWYgKHZhbHVlLmdsb2JhbClcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMHg3MztcbiAgICBpZiAodmFsdWUubXVsdGlsaW5lKVxuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAweDZkO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQlNPTlJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX1JFR0VYUDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGlmICh2YWx1ZS5wYXR0ZXJuLm1hdGNoKHJlZ2V4cCkgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdwYXR0ZXJuICcgKyB2YWx1ZS5wYXR0ZXJuICsgJyBtdXN0IG5vdCBjb250YWluIG51bGwgYnl0ZXMnKTtcbiAgICB9XG4gICAgaW5kZXggPSBpbmRleCArIEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIHZhbHVlLnBhdHRlcm4sIGluZGV4KTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAweDAwO1xuICAgIGNvbnN0IHNvcnRlZE9wdGlvbnMgPSB2YWx1ZS5vcHRpb25zLnNwbGl0KCcnKS5zb3J0KCkuam9pbignJyk7XG4gICAgaW5kZXggPSBpbmRleCArIEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIHNvcnRlZE9wdGlvbnMsIGluZGV4KTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAweDAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU1pbk1heChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9OVUxMO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdNaW5LZXknKSB7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9NSU5fS0VZO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX01BWF9LRVk7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0SWQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9PSUQ7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBjb25zdCBpZFZhbHVlID0gdmFsdWUuaWQ7XG4gICAgaWYgKGlzVWludDhBcnJheShpZFZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGlkVmFsdWVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ29iamVjdCBbJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICddIGlzIG5vdCBhIHZhbGlkIE9iamVjdElkJyk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0JJTkFSWTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IHNpemUgPSB2YWx1ZS5sZW5ndGg7XG4gICAgYnVmZmVyW2luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQ7XG4gICAgYnVmZmVyLnNldCh2YWx1ZSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBzaXplO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCkge1xuICAgIGlmIChwYXRoLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQ2Fubm90IGNvbnZlcnQgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEJTT04nKTtcbiAgICB9XG4gICAgcGF0aC5hZGQodmFsdWUpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gQlNPTl9EQVRBX0FSUkFZIDogQlNPTl9EQVRBX09CSkVDVDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIHZhbHVlLCBjaGVja0tleXMsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICBwYXRoLmRlbGV0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGVuZEluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0RFQ0lNQUwxMjg7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBidWZmZXIuc2V0KHZhbHVlLmJ5dGVzLnN1YmFycmF5KDAsIDE2KSwgaW5kZXgpO1xuICAgIHJldHVybiBpbmRleCArIDE2O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTG9uZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID1cbiAgICAgICAgdmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgPyBCU09OX0RBVEFfTE9ORyA6IEJTT05fREFUQV9USU1FU1RBTVA7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBjb25zdCBsb3dCaXRzID0gdmFsdWUuZ2V0TG93Qml0cygpO1xuICAgIGNvbnN0IGhpZ2hCaXRzID0gdmFsdWUuZ2V0SGlnaEJpdHMoKTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBsb3dCaXRzICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGxvd0JpdHMgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IGhpZ2hCaXRzICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoaGlnaEJpdHMgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiAyNCkgJiAweGZmO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUludDMyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfSU5UO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgYnVmZmVyW2luZGV4KytdID0gdmFsdWUgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9ICh2YWx1ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHZhbHVlID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHZhbHVlID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTlVNQkVSO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgTlVNQkVSX1NQQUNFLnNldEZsb2F0NjQoMCwgdmFsdWUudmFsdWUsIHRydWUpO1xuICAgIGJ1ZmZlci5zZXQoRUlHSFRfQllURV9WSUVXX09OX05VTUJFUiwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyA4O1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgIGJ1ZmZlcltpbmRleF0gPSBzaXplICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAxXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAyXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4ICsgM10gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZSAtIDE7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVDb2RlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cyA9IGZhbHNlLCBkZXB0aCA9IDAsIHNlcmlhbGl6ZUZ1bmN0aW9ucyA9IGZhbHNlLCBpZ25vcmVVbmRlZmluZWQgPSB0cnVlLCBwYXRoKSB7XG4gICAgaWYgKHZhbHVlLnNjb3BlICYmIHR5cGVvZiB2YWx1ZS5zY29wZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0NPREVfV19TQ09QRTtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IHZhbHVlLmNvZGU7XG4gICAgICAgIGluZGV4ID0gaW5kZXggKyA0O1xuICAgICAgICBjb25zdCBjb2RlU2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGZ1bmN0aW9uU3RyaW5nLCBpbmRleCArIDQpICsgMTtcbiAgICAgICAgYnVmZmVyW2luZGV4XSA9IGNvZGVTaXplICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4ICsgMV0gPSAoY29kZVNpemUgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAyXSA9IChjb2RlU2l6ZSA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAzXSA9IChjb2RlU2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyA0ICsgY29kZVNpemUgLSAxXSA9IDA7XG4gICAgICAgIGluZGV4ID0gaW5kZXggKyBjb2RlU2l6ZSArIDQ7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIHZhbHVlLnNjb3BlLCBjaGVja0tleXMsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgaW5kZXggPSBlbmRJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IGVuZEluZGV4IC0gc3RhcnRJbmRleDtcbiAgICAgICAgYnVmZmVyW3N0YXJ0SW5kZXgrK10gPSB0b3RhbFNpemUgJiAweGZmO1xuICAgICAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9ICh0b3RhbFNpemUgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9ICh0b3RhbFNpemUgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW3N0YXJ0SW5kZXgrK10gPSAodG90YWxTaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERTtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IHZhbHVlLmNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGZ1bmN0aW9uU3RyaW5nLCBpbmRleCArIDQpICsgMTtcbiAgICAgICAgYnVmZmVyW2luZGV4XSA9IHNpemUgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAxXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4ICsgMl0gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAzXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZSAtIDE7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJpbmFyeShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0JJTkFSWTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGRhdGEgPSB2YWx1ZS5idWZmZXI7XG4gICAgbGV0IHNpemUgPSB2YWx1ZS5wb3NpdGlvbjtcbiAgICBpZiAodmFsdWUuc3ViX3R5cGUgPT09IEJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkpXG4gICAgICAgIHNpemUgPSBzaXplICsgNDtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBzaXplICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHZhbHVlLnN1Yl90eXBlO1xuICAgIGlmICh2YWx1ZS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuICAgICAgICBzaXplID0gc2l6ZSAtIDQ7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IHNpemUgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgfVxuICAgIGJ1ZmZlci5zZXQoZGF0YSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyB2YWx1ZS5wb3NpdGlvbjtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTeW1ib2woYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9TWU1CT0w7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUudmFsdWUsIGluZGV4ICsgNCkgKyAxO1xuICAgIGJ1ZmZlcltpbmRleF0gPSBzaXplICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAxXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAyXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4ICsgM10gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZSAtIDE7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEQlJlZihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBwYXRoKSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX09CSkVDVDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgbGV0IG91dHB1dCA9IHtcbiAgICAgICAgJHJlZjogdmFsdWUuY29sbGVjdGlvbiB8fCB2YWx1ZS5uYW1lc3BhY2UsXG4gICAgICAgICRpZDogdmFsdWUub2lkXG4gICAgfTtcbiAgICBpZiAodmFsdWUuZGIgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQuJGRiID0gdmFsdWUuZGI7XG4gICAgfVxuICAgIG91dHB1dCA9IE9iamVjdC5hc3NpZ24ob3V0cHV0LCB2YWx1ZS5maWVsZHMpO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIG91dHB1dCwgZmFsc2UsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgdHJ1ZSwgcGF0aCk7XG4gICAgY29uc3Qgc2l6ZSA9IGVuZEluZGV4IC0gc3RhcnRJbmRleDtcbiAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGVuZEluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSW50byhidWZmZXIsIG9iamVjdCwgY2hlY2tLZXlzLCBzdGFydGluZ0luZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnVmZmVyWzBdID0gMHgwNTtcbiAgICAgICAgICAgIGJ1ZmZlclsxXSA9IDB4MDA7XG4gICAgICAgICAgICBidWZmZXJbMl0gPSAweDAwO1xuICAgICAgICAgICAgYnVmZmVyWzNdID0gMHgwMDtcbiAgICAgICAgICAgIGJ1ZmZlcls0XSA9IDB4MDA7XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdzZXJpYWxpemUgZG9lcyBub3Qgc3VwcG9ydCBhbiBhcnJheSBhcyB0aGUgcm9vdCBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignc2VyaWFsaXplIGRvZXMgbm90IHN1cHBvcnQgbm9uLW9iamVjdCBhcyB0aGUgcm9vdCBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdfYnNvbnR5cGUnIGluIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0Ll9ic29udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYEJTT04gdHlwZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYXMgYSBkb2N1bWVudGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZShvYmplY3QpIHx8XG4gICAgICAgICAgICBpc1JlZ0V4cChvYmplY3QpIHx8XG4gICAgICAgICAgICBpc1VpbnQ4QXJyYXkob2JqZWN0KSB8fFxuICAgICAgICAgICAgaXNBbnlBcnJheUJ1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBkYXRlLCByZWdleHAsIHR5cGVkYXJyYXksIGFuZCBhcnJheWJ1ZmZlciBjYW5ub3QgYmUgQlNPTiBkb2N1bWVudHNgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBwYXRoLmFkZChvYmplY3QpO1xuICAgIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXggKyA0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2l9YDtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmlnSW50KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJ1ZmZlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdPYmplY3RJZCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdElkKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnRGVjaW1hbDEyOCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURlY2ltYWwxMjgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdUaW1lc3RhbXAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnRG91YmxlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRnVuY3Rpb24oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdDb2RlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQ29kZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaW5hcnkoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OU3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3ltYm9sKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnREJSZWYnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEQlJlZihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnSW50MzInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVJbnQzMihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlLl9ic29udHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICR7U3RyaW5nKHZhbHVlLl9ic29udHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwIHx8IGlzTWFwKG9iamVjdCkpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBvYmplY3QuZW50cmllcygpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgZG9uZSA9ICEhZW50cnkuZG9uZTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZW50cnkudmFsdWVbMF07XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRyeS52YWx1ZVsxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICFpZ25vcmVLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5tYXRjaChyZWdleHApICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnJCcgPT09IGtleVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBzdGFydCB3aXRoICckJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh+a2V5LmluZGV4T2YoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBjb250YWluICcuJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaWdJbnQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBudWxsIHx8ICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGlnbm9yZVVuZGVmaW5lZCA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVSZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdPYmplY3RJZCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdElkKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2Jzb250eXBlID09PSAnRGVjaW1hbDEyOCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURlY2ltYWwxMjgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdUaW1lc3RhbXAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnRG91YmxlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQ29kZScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUNvZGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRnVuY3Rpb24oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaW5hcnkoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OU3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3ltYm9sKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnREJSZWYnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEQlJlZihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnSW50MzInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVJbnQzMihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlLl9ic29udHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICR7U3RyaW5nKHZhbHVlLl9ic29udHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Py50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC50b0JTT04oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3RvQlNPTiBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICFpZ25vcmVLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5tYXRjaChyZWdleHApICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnJCcgPT09IGtleVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBzdGFydCB3aXRoICckJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh+a2V5LmluZGV4T2YoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBjb250YWluICcuJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaWdJbnQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlVW5kZWZpbmVkID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCdWZmZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlW1N5bWJvbC5mb3IoJ0BAbWRiLmJzb24udmVyc2lvbicpXSAhPT0gQlNPTl9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05WZXJzaW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0SWQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT09ICdEZWNpbWFsMTI4Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0xvbmcnIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ1RpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUxvbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdDb2RlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQ29kZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgc2VyaWFsaXplRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVGdW5jdGlvbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpbmFyeShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05TeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTeW1ib2woYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJTT05SZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdJbnQzMicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUludDMyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTWluS2V5JyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdNYXhLZXknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVNaW5NYXgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuX2Jzb250eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVucmVjb2duaXplZCBvciBpbnZhbGlkIF9ic29udHlwZTogJHtTdHJpbmcodmFsdWUuX2Jzb250eXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRoLmRlbGV0ZShvYmplY3QpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgY29uc3Qgc2l6ZSA9IGluZGV4IC0gc3RhcnRpbmdJbmRleDtcbiAgICBidWZmZXJbc3RhcnRpbmdJbmRleCsrXSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydGluZ0luZGV4KytdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydGluZ0luZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbc3RhcnRpbmdJbmRleCsrXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBpc0JTT05UeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ19ic29udHlwZScgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLl9ic29udHlwZSA9PT0gJ3N0cmluZycpO1xufVxuY29uc3Qga2V5c1RvQ29kZWNzID0ge1xuICAgICRvaWQ6IE9iamVjdElkLFxuICAgICRiaW5hcnk6IEJpbmFyeSxcbiAgICAkdXVpZDogQmluYXJ5LFxuICAgICRzeW1ib2w6IEJTT05TeW1ib2wsXG4gICAgJG51bWJlckludDogSW50MzIsXG4gICAgJG51bWJlckRlY2ltYWw6IERlY2ltYWwxMjgsXG4gICAgJG51bWJlckRvdWJsZTogRG91YmxlLFxuICAgICRudW1iZXJMb25nOiBMb25nLFxuICAgICRtaW5LZXk6IE1pbktleSxcbiAgICAkbWF4S2V5OiBNYXhLZXksXG4gICAgJHJlZ2V4OiBCU09OUmVnRXhwLFxuICAgICRyZWd1bGFyRXhwcmVzc2lvbjogQlNPTlJlZ0V4cCxcbiAgICAkdGltZXN0YW1wOiBUaW1lc3RhbXBcbn07XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBpbjMyQml0UmFuZ2UgPSB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCAmJiB2YWx1ZSA+PSBCU09OX0lOVDMyX01JTjtcbiAgICAgICAgY29uc3QgaW42NEJpdFJhbmdlID0gdmFsdWUgPD0gQlNPTl9JTlQ2NF9NQVggJiYgdmFsdWUgPj0gQlNPTl9JTlQ2NF9NSU47XG4gICAgICAgIGlmIChvcHRpb25zLnJlbGF4ZWQgfHwgb3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIU9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICAgICAgICBpZiAoaW4zMkJpdFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW42NEJpdFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlQmlnSW50NjQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRG91YmxlKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZS4kdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnJCcpICYmIHZhbHVlW2tdICE9IG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0ga2V5c1RvQ29kZWNzW2tleXNbaV1dO1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICAgIHJldHVybiBjLmZyb21FeHRlbmRlZEpTT04odmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUuJGRhdGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkID0gdmFsdWUuJGRhdGU7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShEYXRlLnBhcnNlKGQpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkID09PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoTnVtYmVyKGQpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlJ1bnRpbWVFcnJvcihgVW5yZWNvZ25pemVkIHR5cGUgZm9yIEVKU09OIGRhdGU6ICR7dHlwZW9mIGR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShEYXRlLnBhcnNlKGQpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKExvbmcuaXNMb25nKGQpKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInICYmIG9wdGlvbnMucmVsYXhlZClcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKE51bWJlcihkKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05SdW50aW1lRXJyb3IoYFVucmVjb2duaXplZCB0eXBlIGZvciBFSlNPTiBkYXRlOiAke3R5cGVvZiBkfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBpZiAodmFsdWUuJGNvZGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUuJHNjb3BlKSB7XG4gICAgICAgICAgICBjb3B5LiRzY29wZSA9IGRlc2VyaWFsaXplVmFsdWUodmFsdWUuJHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29kZS5mcm9tRXh0ZW5kZWRKU09OKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzREJSZWZMaWtlKHZhbHVlKSB8fCB2YWx1ZS4kZGJQb2ludGVyKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZS4kcmVmID8gdmFsdWUgOiB2YWx1ZS4kZGJQb2ludGVyO1xuICAgICAgICBpZiAodiBpbnN0YW5jZW9mIERCUmVmKVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNvbnN0IGRvbGxhcktleXMgPSBPYmplY3Qua2V5cyh2KS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoJyQnKSk7XG4gICAgICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgICAgIGRvbGxhcktleXMuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmIChbJyRyZWYnLCAnJGlkJywgJyRkYiddLmluZGV4T2YoaykgPT09IC0xKVxuICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsaWQpXG4gICAgICAgICAgICByZXR1cm4gREJSZWYuZnJvbUV4dGVuZGVkSlNPTih2KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkoYXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXJyYXkubWFwKCh2LCBpbmRleCkgPT4ge1xuICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzLnB1c2goeyBwcm9wZXJ0eU5hbWU6IGBpbmRleCAke2luZGV4fWAsIG9iajogbnVsbCB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVWYWx1ZSh2LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2Vlbk9iamVjdHMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldElTT1N0cmluZyhkYXRlKSB7XG4gICAgY29uc3QgaXNvU3RyID0gZGF0ZS50b0lTT1N0cmluZygpO1xuICAgIHJldHVybiBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpICE9PSAwID8gaXNvU3RyIDogaXNvU3RyLnNsaWNlKDAsIC01KSArICdaJztcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0NhbiBvbmx5IHNlcmlhbGl6ZSBtYXBzIHdpdGggc3RyaW5nIGtleXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtrXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVZhbHVlKG9iaiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gb3B0aW9ucy5zZWVuT2JqZWN0cy5maW5kSW5kZXgoZW50cnkgPT4gZW50cnkub2JqID09PSB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gb3B0aW9ucy5zZWVuT2JqZWN0cy5tYXAoZW50cnkgPT4gZW50cnkucHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdQYXJ0ID0gcHJvcHNcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgICAgLm1hcChwcm9wID0+IGAke3Byb3B9IC0+IGApXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICAgICAgY29uc3QgYWxyZWFkeVNlZW4gPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBjaXJjdWxhclBhcnQgPSAnIC0+ICcgK1xuICAgICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleCArIDEsIHByb3BzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAocHJvcCA9PiBgJHtwcm9wfSAtPiBgKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcHJvcHNbcHJvcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nU3BhY2UgPSAnICcucmVwZWF0KGxlYWRpbmdQYXJ0Lmxlbmd0aCArIGFscmVhZHlTZWVuLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgY29uc3QgZGFzaGVzID0gJy0nLnJlcGVhdChjaXJjdWxhclBhcnQubGVuZ3RoICsgKGFscmVhZHlTZWVuLmxlbmd0aCArIGN1cnJlbnQubGVuZ3RoKSAvIDIgLSAxKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEVKU09OOlxcbicgK1xuICAgICAgICAgICAgICAgIGAgICAgJHtsZWFkaW5nUGFydH0ke2FscmVhZHlTZWVufSR7Y2lyY3VsYXJQYXJ0fSR7Y3VycmVudH1cXG5gICtcbiAgICAgICAgICAgICAgICBgICAgICR7bGVhZGluZ1NwYWNlfVxcXFwke2Rhc2hlc30vYCk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0c1tvcHRpb25zLnNlZW5PYmplY3RzLmxlbmd0aCAtIDFdLm9iaiA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVBcnJheSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBkYXRlTnVtID0gdmFsdWUuZ2V0VGltZSgpLCBpblJhbmdlID0gZGF0ZU51bSA+IC0xICYmIGRhdGVOdW0gPCAyNTM0MDIzMTg4MDAwMDA7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVsYXhlZCAmJiBpblJhbmdlXG4gICAgICAgICAgICAgICAgPyB7ICRkYXRlOiB2YWx1ZS5nZXRUaW1lKCkgfVxuICAgICAgICAgICAgICAgIDogeyAkZGF0ZTogZ2V0SVNPU3RyaW5nKHZhbHVlKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLnJlbGF4ZWQgJiYgaW5SYW5nZVxuICAgICAgICAgICAgPyB7ICRkYXRlOiBnZXRJU09TdHJpbmcodmFsdWUpIH1cbiAgICAgICAgICAgIDogeyAkZGF0ZTogeyAkbnVtYmVyTG9uZzogdmFsdWUuZ2V0VGltZSgpLnRvU3RyaW5nKCkgfSB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoIW9wdGlvbnMucmVsYXhlZCB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIU9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gQlNPTl9JTlQzMl9NSU4gJiYgdmFsdWUgPD0gQlNPTl9JTlQzMl9NQVgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAkbnVtYmVySW50OiB2YWx1ZS50b1N0cmluZygpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gQlNPTl9JTlQ2NF9NSU4gJiYgdmFsdWUgPD0gQlNPTl9JTlQ2NF9NQVgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAkbnVtYmVyTG9uZzogdmFsdWUudG9TdHJpbmcoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJEb3VibGU6IE9iamVjdC5pcyh2YWx1ZSwgLTApID8gJy0wLjAnIDogdmFsdWUudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICBpZiAoIW9wdGlvbnMucmVsYXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckxvbmc6IEJpZ0ludC5hc0ludE4oNjQsIHZhbHVlKS50b1N0cmluZygpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcihCaWdJbnQuYXNJbnROKDY0LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgIGxldCBmbGFncyA9IHZhbHVlLmZsYWdzO1xuICAgICAgICBpZiAoZmxhZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS50b1N0cmluZygpLm1hdGNoKC9bZ2ltdXldKiQvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGZsYWdzID0gbWF0Y2hbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnggPSBuZXcgQlNPTlJlZ0V4cCh2YWx1ZS5zb3VyY2UsIGZsYWdzKTtcbiAgICAgICAgcmV0dXJuIHJ4LnRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplRG9jdW1lbnQodmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEJTT05fVFlQRV9NQVBQSU5HUyA9IHtcbiAgICBCaW5hcnk6IChvKSA9PiBuZXcgQmluYXJ5KG8udmFsdWUoKSwgby5zdWJfdHlwZSksXG4gICAgQ29kZTogKG8pID0+IG5ldyBDb2RlKG8uY29kZSwgby5zY29wZSksXG4gICAgREJSZWY6IChvKSA9PiBuZXcgREJSZWYoby5jb2xsZWN0aW9uIHx8IG8ubmFtZXNwYWNlLCBvLm9pZCwgby5kYiwgby5maWVsZHMpLFxuICAgIERlY2ltYWwxMjg6IChvKSA9PiBuZXcgRGVjaW1hbDEyOChvLmJ5dGVzKSxcbiAgICBEb3VibGU6IChvKSA9PiBuZXcgRG91YmxlKG8udmFsdWUpLFxuICAgIEludDMyOiAobykgPT4gbmV3IEludDMyKG8udmFsdWUpLFxuICAgIExvbmc6IChvKSA9PiBMb25nLmZyb21CaXRzKG8ubG93ICE9IG51bGwgPyBvLmxvdyA6IG8ubG93Xywgby5sb3cgIT0gbnVsbCA/IG8uaGlnaCA6IG8uaGlnaF8sIG8ubG93ICE9IG51bGwgPyBvLnVuc2lnbmVkIDogby51bnNpZ25lZF8pLFxuICAgIE1heEtleTogKCkgPT4gbmV3IE1heEtleSgpLFxuICAgIE1pbktleTogKCkgPT4gbmV3IE1pbktleSgpLFxuICAgIE9iamVjdElkOiAobykgPT4gbmV3IE9iamVjdElkKG8pLFxuICAgIEJTT05SZWdFeHA6IChvKSA9PiBuZXcgQlNPTlJlZ0V4cChvLnBhdHRlcm4sIG8ub3B0aW9ucyksXG4gICAgQlNPTlN5bWJvbDogKG8pID0+IG5ldyBCU09OU3ltYm9sKG8udmFsdWUpLFxuICAgIFRpbWVzdGFtcDogKG8pID0+IFRpbWVzdGFtcC5mcm9tQml0cyhvLmxvdywgby5oaWdoKVxufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGlmIChkb2MgPT0gbnVsbCB8fCB0eXBlb2YgZG9jICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignbm90IGFuIG9iamVjdCBpbnN0YW5jZScpO1xuICAgIGNvbnN0IGJzb250eXBlID0gZG9jLl9ic29udHlwZTtcbiAgICBpZiAodHlwZW9mIGJzb250eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBfZG9jID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkb2MpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzLnB1c2goeyBwcm9wZXJ0eU5hbWU6IG5hbWUsIG9iajogbnVsbCB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemVWYWx1ZShkb2NbbmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2RvYywgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZG9jW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RvYztcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGRvYyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIGRvYy5fYnNvbnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGRvY1tTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JTT05UeXBlKGRvYykpIHtcbiAgICAgICAgbGV0IG91dERvYyA9IGRvYztcbiAgICAgICAgaWYgKHR5cGVvZiBvdXREb2MudG9FeHRlbmRlZEpTT04gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlciA9IEJTT05fVFlQRV9NQVBQSU5HU1tkb2MuX2Jzb250eXBlXTtcbiAgICAgICAgICAgIGlmICghbWFwcGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVW5yZWNvZ25pemVkIG9yIGludmFsaWQgX2Jzb250eXBlOiAnICsgZG9jLl9ic29udHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXREb2MgPSBtYXBwZXIob3V0RG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnNvbnR5cGUgPT09ICdDb2RlJyAmJiBvdXREb2Muc2NvcGUpIHtcbiAgICAgICAgICAgIG91dERvYyA9IG5ldyBDb2RlKG91dERvYy5jb2RlLCBzZXJpYWxpemVWYWx1ZShvdXREb2Muc2NvcGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChic29udHlwZSA9PT0gJ0RCUmVmJyAmJiBvdXREb2Mub2lkKSB7XG4gICAgICAgICAgICBvdXREb2MgPSBuZXcgREJSZWYoc2VyaWFsaXplVmFsdWUob3V0RG9jLmNvbGxlY3Rpb24sIG9wdGlvbnMpLCBzZXJpYWxpemVWYWx1ZShvdXREb2Mub2lkLCBvcHRpb25zKSwgc2VyaWFsaXplVmFsdWUob3V0RG9jLmRiLCBvcHRpb25zKSwgc2VyaWFsaXplVmFsdWUob3V0RG9jLmZpZWxkcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXREb2MudG9FeHRlbmRlZEpTT04ob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdfYnNvbnR5cGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHdhczogJyArIHR5cGVvZiBic29udHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2UodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVqc29uT3B0aW9ucyA9IHtcbiAgICAgICAgdXNlQmlnSW50NjQ6IG9wdGlvbnM/LnVzZUJpZ0ludDY0ID8/IGZhbHNlLFxuICAgICAgICByZWxheGVkOiBvcHRpb25zPy5yZWxheGVkID8/IHRydWUsXG4gICAgICAgIGxlZ2FjeTogb3B0aW9ucz8ubGVnYWN5ID8/IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0LCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ1xceDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCU09OIERvY3VtZW50IGZpZWxkIG5hbWVzIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KGtleSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplVmFsdWUodmFsdWUsIGVqc29uT3B0aW9ucyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgb3B0aW9ucykge1xuICAgIGlmIChzcGFjZSAhPSBudWxsICYmIHR5cGVvZiBzcGFjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNwYWNlO1xuICAgICAgICBzcGFjZSA9IDA7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlciAhPSBudWxsICYmIHR5cGVvZiByZXBsYWNlciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNwYWNlID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyByZWxheGVkOiB0cnVlLCBsZWdhY3k6IGZhbHNlIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgc2Vlbk9iamVjdHM6IFt7IHByb3BlcnR5TmFtZTogJyhyb290KScsIG9iajogbnVsbCB9XVxuICAgIH0pO1xuICAgIGNvbnN0IGRvYyA9IHNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBzZXJpYWxpemVPcHRpb25zKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZG9jLCByZXBsYWNlciwgc3BhY2UpO1xufVxuZnVuY3Rpb24gRUpTT05zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIEVKU09OZGVzZXJpYWxpemUoZWpzb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gcGFyc2UoSlNPTi5zdHJpbmdpZnkoZWpzb24pLCBvcHRpb25zKTtcbn1cbmNvbnN0IEVKU09OID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbkVKU09OLnBhcnNlID0gcGFyc2U7XG5FSlNPTi5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5FSlNPTi5zZXJpYWxpemUgPSBFSlNPTnNlcmlhbGl6ZTtcbkVKU09OLmRlc2VyaWFsaXplID0gRUpTT05kZXNlcmlhbGl6ZTtcbk9iamVjdC5mcmVlemUoRUpTT04pO1xuXG5jb25zdCBNQVhTSVpFID0gMTAyNCAqIDEwMjQgKiAxNztcbmxldCBidWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoTUFYU0laRSk7XG5mdW5jdGlvbiBzZXRJbnRlcm5hbEJ1ZmZlclNpemUoc2l6ZSkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBidWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoc2l6ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VyaWFsaXplKG9iamVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tLZXlzID0gdHlwZW9mIG9wdGlvbnMuY2hlY2tLZXlzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNoZWNrS2V5cyA6IGZhbHNlO1xuICAgIGNvbnN0IHNlcmlhbGl6ZUZ1bmN0aW9ucyA9IHR5cGVvZiBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgOiBmYWxzZTtcbiAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSB0eXBlb2Ygb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkIDogdHJ1ZTtcbiAgICBjb25zdCBtaW5JbnRlcm5hbEJ1ZmZlclNpemUgPSB0eXBlb2Ygb3B0aW9ucy5taW5JbnRlcm5hbEJ1ZmZlclNpemUgPT09ICdudW1iZXInID8gb3B0aW9ucy5taW5JbnRlcm5hbEJ1ZmZlclNpemUgOiBNQVhTSVpFO1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgbWluSW50ZXJuYWxCdWZmZXJTaXplKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShtaW5JbnRlcm5hbEJ1ZmZlclNpemUpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemF0aW9uSW5kZXggPSBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgb2JqZWN0LCBjaGVja0tleXMsIDAsIDAsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBudWxsKTtcbiAgICBjb25zdCBmaW5pc2hlZEJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShzZXJpYWxpemF0aW9uSW5kZXgpO1xuICAgIGZpbmlzaGVkQnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkoMCwgc2VyaWFsaXphdGlvbkluZGV4KSwgMCk7XG4gICAgcmV0dXJuIGZpbmlzaGVkQnVmZmVyO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4KG9iamVjdCwgZmluYWxCdWZmZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrS2V5cyA9IHR5cGVvZiBvcHRpb25zLmNoZWNrS2V5cyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5jaGVja0tleXMgOiBmYWxzZTtcbiAgICBjb25zdCBzZXJpYWxpemVGdW5jdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zIDogZmFsc2U7XG4gICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gdHlwZW9mIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA6IHRydWU7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHR5cGVvZiBvcHRpb25zLmluZGV4ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuaW5kZXggOiAwO1xuICAgIGNvbnN0IHNlcmlhbGl6YXRpb25JbmRleCA9IHNlcmlhbGl6ZUludG8oYnVmZmVyLCBvYmplY3QsIGNoZWNrS2V5cywgMCwgMCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIG51bGwpO1xuICAgIGZpbmFsQnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkoMCwgc2VyaWFsaXphdGlvbkluZGV4KSwgc3RhcnRJbmRleCk7XG4gICAgcmV0dXJuIHN0YXJ0SW5kZXggKyBzZXJpYWxpemF0aW9uSW5kZXggLSAxO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoYnVmZmVyLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gaW50ZXJuYWxEZXNlcmlhbGl6ZShCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVPYmplY3RTaXplKG9iamVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc2VyaWFsaXplRnVuY3Rpb25zID0gdHlwZW9mIG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA6IGZhbHNlO1xuICAgIGNvbnN0IGlnbm9yZVVuZGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgOiB0cnVlO1xuICAgIHJldHVybiBpbnRlcm5hbENhbGN1bGF0ZU9iamVjdFNpemUob2JqZWN0LCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN0cmVhbShkYXRhLCBzdGFydEluZGV4LCBudW1iZXJPZkRvY3VtZW50cywgZG9jdW1lbnRzLCBkb2NTdGFydEluZGV4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW50ZXJuYWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGFsbG93T2JqZWN0U21hbGxlclRoYW5CdWZmZXJTaXplOiB0cnVlLCBpbmRleDogMCB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBidWZmZXJEYXRhID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGRhdGEpO1xuICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRvY3VtZW50czsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBidWZmZXJEYXRhW2luZGV4XSB8XG4gICAgICAgICAgICAoYnVmZmVyRGF0YVtpbmRleCArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgIChidWZmZXJEYXRhW2luZGV4ICsgMl0gPDwgMTYpIHxcbiAgICAgICAgICAgIChidWZmZXJEYXRhW2luZGV4ICsgM10gPDwgMjQpO1xuICAgICAgICBpbnRlcm5hbE9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZG9jdW1lbnRzW2RvY1N0YXJ0SW5kZXggKyBpXSA9IGludGVybmFsRGVzZXJpYWxpemUoYnVmZmVyRGF0YSwgaW50ZXJuYWxPcHRpb25zKTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIHNpemU7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cblxudmFyIGJzb24gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEJTT05FcnJvcjogQlNPTkVycm9yLFxuICAgIEJTT05SZWdFeHA6IEJTT05SZWdFeHAsXG4gICAgQlNPTlJ1bnRpbWVFcnJvcjogQlNPTlJ1bnRpbWVFcnJvcixcbiAgICBCU09OU3ltYm9sOiBCU09OU3ltYm9sLFxuICAgIEJTT05UeXBlOiBCU09OVHlwZSxcbiAgICBCU09OVmFsdWU6IEJTT05WYWx1ZSxcbiAgICBCU09OVmVyc2lvbkVycm9yOiBCU09OVmVyc2lvbkVycm9yLFxuICAgIEJpbmFyeTogQmluYXJ5LFxuICAgIENvZGU6IENvZGUsXG4gICAgREJSZWY6IERCUmVmLFxuICAgIERlY2ltYWwxMjg6IERlY2ltYWwxMjgsXG4gICAgRG91YmxlOiBEb3VibGUsXG4gICAgRUpTT046IEVKU09OLFxuICAgIEludDMyOiBJbnQzMixcbiAgICBMb25nOiBMb25nLFxuICAgIE1heEtleTogTWF4S2V5LFxuICAgIE1pbktleTogTWluS2V5LFxuICAgIE9iamVjdElkOiBPYmplY3RJZCxcbiAgICBUaW1lc3RhbXA6IFRpbWVzdGFtcCxcbiAgICBVVUlEOiBVVUlELFxuICAgIGNhbGN1bGF0ZU9iamVjdFNpemU6IGNhbGN1bGF0ZU9iamVjdFNpemUsXG4gICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgIGRlc2VyaWFsaXplU3RyZWFtOiBkZXNlcmlhbGl6ZVN0cmVhbSxcbiAgICBzZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXg6IHNlcmlhbGl6ZVdpdGhCdWZmZXJBbmRJbmRleCxcbiAgICBzZXRJbnRlcm5hbEJ1ZmZlclNpemU6IHNldEludGVybmFsQnVmZmVyU2l6ZVxufSk7XG5cbmV4cG9ydHMuQlNPTiA9IGJzb247XG5leHBvcnRzLkJTT05FcnJvciA9IEJTT05FcnJvcjtcbmV4cG9ydHMuQlNPTlJlZ0V4cCA9IEJTT05SZWdFeHA7XG5leHBvcnRzLkJTT05SdW50aW1lRXJyb3IgPSBCU09OUnVudGltZUVycm9yO1xuZXhwb3J0cy5CU09OU3ltYm9sID0gQlNPTlN5bWJvbDtcbmV4cG9ydHMuQlNPTlR5cGUgPSBCU09OVHlwZTtcbmV4cG9ydHMuQlNPTlZhbHVlID0gQlNPTlZhbHVlO1xuZXhwb3J0cy5CU09OVmVyc2lvbkVycm9yID0gQlNPTlZlcnNpb25FcnJvcjtcbmV4cG9ydHMuQmluYXJ5ID0gQmluYXJ5O1xuZXhwb3J0cy5Db2RlID0gQ29kZTtcbmV4cG9ydHMuREJSZWYgPSBEQlJlZjtcbmV4cG9ydHMuRGVjaW1hbDEyOCA9IERlY2ltYWwxMjg7XG5leHBvcnRzLkRvdWJsZSA9IERvdWJsZTtcbmV4cG9ydHMuRUpTT04gPSBFSlNPTjtcbmV4cG9ydHMuSW50MzIgPSBJbnQzMjtcbmV4cG9ydHMuTG9uZyA9IExvbmc7XG5leHBvcnRzLk1heEtleSA9IE1heEtleTtcbmV4cG9ydHMuTWluS2V5ID0gTWluS2V5O1xuZXhwb3J0cy5PYmplY3RJZCA9IE9iamVjdElkO1xuZXhwb3J0cy5UaW1lc3RhbXAgPSBUaW1lc3RhbXA7XG5leHBvcnRzLlVVSUQgPSBVVUlEO1xuZXhwb3J0cy5jYWxjdWxhdGVPYmplY3RTaXplID0gY2FsY3VsYXRlT2JqZWN0U2l6ZTtcbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbmV4cG9ydHMuZGVzZXJpYWxpemVTdHJlYW0gPSBkZXNlcmlhbGl6ZVN0cmVhbTtcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZXhwb3J0cy5zZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXggPSBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXg7XG5leHBvcnRzLnNldEludGVybmFsQnVmZmVyU2l6ZSA9IHNldEludGVybmFsQnVmZmVyU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJzb24uY2pzLm1hcFxuIl0sIm5hbWVzIjpbImlzQW55QXJyYXlCdWZmZXIiLCJ2YWx1ZSIsImluY2x1ZGVzIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNVaW50OEFycmF5IiwiaXNSZWdFeHAiLCJkIiwiaXNNYXAiLCJpc0RhdGUiLCJkZWZhdWx0SW5zcGVjdCIsIngiLCJfb3B0aW9ucyIsIkpTT04iLCJzdHJpbmdpZnkiLCJrIiwidiIsIiRudW1iZXJMb25nIiwiZnJvbUVudHJpZXMiLCJnZXRTdHlsaXplRnVuY3Rpb24iLCJvcHRpb25zIiwic3R5bGl6ZUV4aXN0cyIsInN0eWxpemUiLCJCU09OX01BSk9SX1ZFUlNJT04iLCJCU09OX0lOVDMyX01BWCIsIkJTT05fSU5UMzJfTUlOIiwiQlNPTl9JTlQ2NF9NQVgiLCJNYXRoIiwicG93IiwiQlNPTl9JTlQ2NF9NSU4iLCJKU19JTlRfTUFYIiwiSlNfSU5UX01JTiIsIkJTT05fREFUQV9OVU1CRVIiLCJCU09OX0RBVEFfU1RSSU5HIiwiQlNPTl9EQVRBX09CSkVDVCIsIkJTT05fREFUQV9BUlJBWSIsIkJTT05fREFUQV9CSU5BUlkiLCJCU09OX0RBVEFfVU5ERUZJTkVEIiwiQlNPTl9EQVRBX09JRCIsIkJTT05fREFUQV9CT09MRUFOIiwiQlNPTl9EQVRBX0RBVEUiLCJCU09OX0RBVEFfTlVMTCIsIkJTT05fREFUQV9SRUdFWFAiLCJCU09OX0RBVEFfREJQT0lOVEVSIiwiQlNPTl9EQVRBX0NPREUiLCJCU09OX0RBVEFfU1lNQk9MIiwiQlNPTl9EQVRBX0NPREVfV19TQ09QRSIsIkJTT05fREFUQV9JTlQiLCJCU09OX0RBVEFfVElNRVNUQU1QIiwiQlNPTl9EQVRBX0xPTkciLCJCU09OX0RBVEFfREVDSU1BTDEyOCIsIkJTT05fREFUQV9NSU5fS0VZIiwiQlNPTl9EQVRBX01BWF9LRVkiLCJCU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQiLCJCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXIiwiQlNPTlR5cGUiLCJmcmVlemUiLCJkb3VibGUiLCJzdHJpbmciLCJvYmplY3QiLCJhcnJheSIsImJpbkRhdGEiLCJ1bmRlZmluZWQiLCJvYmplY3RJZCIsImJvb2wiLCJkYXRlIiwibnVsbCIsInJlZ2V4IiwiZGJQb2ludGVyIiwiamF2YXNjcmlwdCIsInN5bWJvbCIsImphdmFzY3JpcHRXaXRoU2NvcGUiLCJpbnQiLCJ0aW1lc3RhbXAiLCJsb25nIiwiZGVjaW1hbCIsIm1pbktleSIsIm1heEtleSIsIkJTT05FcnJvciIsIkVycm9yIiwiYnNvbkVycm9yIiwibmFtZSIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImlzQlNPTkVycm9yIiwiQlNPTlZlcnNpb25FcnJvciIsIkJTT05SdW50aW1lRXJyb3IiLCJub2RlanNNYXRoUmFuZG9tQnl0ZXMiLCJieXRlTGVuZ3RoIiwibm9kZUpzQnl0ZVV0aWxzIiwiZnJvbU51bWJlckFycmF5IiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiZmxvb3IiLCJyYW5kb20iLCJub2RlanNSYW5kb21CeXRlcyIsInJlcXVpcmUiLCJyYW5kb21CeXRlcyIsInRvTG9jYWxCdWZmZXJUeXBlIiwicG90ZW50aWFsQnVmZmVyIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJzdHJpbmdUYWciLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIlN0cmluZyIsImFsbG9jYXRlIiwic2l6ZSIsImFsbG9jIiwiZXF1YWxzIiwiYSIsImIiLCJmcm9tQmFzZTY0IiwiYmFzZTY0IiwidG9CYXNlNjQiLCJmcm9tSVNPODg1OTEiLCJjb2RlUG9pbnRzIiwidG9JU084ODU5MSIsImZyb21IZXgiLCJoZXgiLCJ0b0hleCIsImZyb21VVEY4IiwidGV4dCIsInRvVVRGOCIsInN0YXJ0IiwiZW5kIiwidXRmOEJ5dGVMZW5ndGgiLCJpbnB1dCIsImVuY29kZVVURjhJbnRvIiwic291cmNlIiwid3JpdGUiLCJpc1JlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwiZ2xvYmFsVGhpcyIsInByb2R1Y3QiLCJ3ZWJNYXRoUmFuZG9tQnl0ZXMiLCJSYW5nZUVycm9yIiwid2ViQnl0ZVV0aWxzIiwid2ViUmFuZG9tQnl0ZXMiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJjb25zb2xlIiwid2FybiIsIkhFWF9ESUdJVCIsInBvdGVudGlhbFVpbnQ4YXJyYXkiLCJVaW50OEFycmF5Iiwic2xpY2UiLCJUeXBlRXJyb3IiLCJpIiwiYXRvYiIsImMiLCJjaGFyQ29kZUF0IiwidWludDhhcnJheSIsImJ0b2EiLCJVaW50MTZBcnJheSIsImZyb21DaGFyQ29kZSIsImpvaW4iLCJldmVuTGVuZ3RoSGV4IiwiZmlyc3REaWdpdCIsInNlY29uZERpZ2l0IiwidGVzdCIsImhleERpZ2l0IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJwdXNoIiwiYnl0ZSIsInBhZFN0YXJ0IiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJUZXh0RGVjb2RlciIsImZhdGFsIiwiZGVjb2RlIiwiYnl0ZXMiLCJzZXQiLCJoYXNHbG9iYWxCdWZmZXIiLCJfaXNCdWZmZXIiLCJCeXRlVXRpbHMiLCJCU09ORGF0YVZpZXciLCJEYXRhVmlldyIsImZyb21VaW50OEFycmF5IiwiQlNPTlZhbHVlIiwiZm9yIiwiZGVwdGgiLCJpbnNwZWN0IiwiQmluYXJ5IiwiX2Jzb250eXBlIiwic3ViVHlwZSIsImlzQXJyYXkiLCJzdWJfdHlwZSIsIkJVRkZFUl9TSVpFIiwicG9zaXRpb24iLCJwdXQiLCJieXRlVmFsdWUiLCJkZWNvZGVkQnl0ZSIsIm5ld1NwYWNlIiwic2VxdWVuY2UiLCJvZmZzZXQiLCJyZWFkIiwic3ViYXJyYXkiLCJ0b0pTT04iLCJlbmNvZGluZyIsInRvRXh0ZW5kZWRKU09OIiwiYmFzZTY0U3RyaW5nIiwibGVnYWN5IiwiJGJpbmFyeSIsIiR0eXBlIiwidG9VVUlEIiwiU1VCVFlQRV9VVUlEIiwiVVVJRCIsImNyZWF0ZUZyb21IZXhTdHJpbmciLCJjcmVhdGVGcm9tQmFzZTY0IiwiZnJvbUV4dGVuZGVkSlNPTiIsImRvYyIsImRhdGEiLCJ0eXBlIiwiYnl0ZXNGcm9tU3RyaW5nIiwiJHV1aWQiLCJiYXNlNjRBcmciLCJzdWJUeXBlQXJnIiwiU1VCVFlQRV9ERUZBVUxUIiwiU1VCVFlQRV9GVU5DVElPTiIsIlNVQlRZUEVfQllURV9BUlJBWSIsIlNVQlRZUEVfVVVJRF9PTEQiLCJTVUJUWVBFX01ENSIsIlNVQlRZUEVfRU5DUllQVEVEIiwiU1VCVFlQRV9DT0xVTU4iLCJTVUJUWVBFX1VTRVJfREVGSU5FRCIsIlVVSURfQllURV9MRU5HVEgiLCJVVUlEX1dJVEhPVVRfREFTSEVTIiwiVVVJRF9XSVRIX0RBU0hFUyIsImdlbmVyYXRlIiwiaWQiLCJ0b0hleFN0cmluZyIsImluY2x1ZGVEYXNoZXMiLCJvdGhlcklkIiwidG9CaW5hcnkiLCJpc1ZhbGlkIiwiaXNWYWxpZFVVSURTdHJpbmciLCJoZXhTdHJpbmciLCJyZXByZXNlbnRhdGlvbiIsInJlcGxhY2UiLCJDb2RlIiwiY29kZSIsInNjb3BlIiwiJGNvZGUiLCIkc2NvcGUiLCJwYXJhbWV0ZXJzU3RyaW5nIiwibXVsdGlMaW5lRm4iLCJlbmRpbmdOZXdsaW5lIiwiaXNEQlJlZkxpa2UiLCIkaWQiLCIkcmVmIiwiJGRiIiwiREJSZWYiLCJjb2xsZWN0aW9uIiwib2lkIiwiZGIiLCJmaWVsZHMiLCJwYXJ0cyIsInNwbGl0Iiwic2hpZnQiLCJuYW1lc3BhY2UiLCJvIiwiYXNzaWduIiwiY29weSIsImFyZ3MiLCJrZXlzIiwid2FzbSIsIldlYkFzc2VtYmx5IiwiSW5zdGFuY2UiLCJNb2R1bGUiLCJleHBvcnRzIiwiVFdPX1BXUl8xNl9EQkwiLCJUV09fUFdSXzI0X0RCTCIsIlRXT19QV1JfMzJfREJMIiwiVFdPX1BXUl82NF9EQkwiLCJUV09fUFdSXzYzX0RCTCIsIklOVF9DQUNIRSIsIlVJTlRfQ0FDSEUiLCJNQVhfSU5UNjRfU1RSSU5HX0xFTkdUSCIsIkRFQ0lNQUxfUkVHX0VYIiwiTG9uZyIsIl9faXNMb25nX18iLCJsb3ciLCJoaWdoIiwidW5zaWduZWQiLCJmcm9tQmlnSW50IiwiZnJvbVN0cmluZyIsImZyb21CaXRzIiwibG93Qml0cyIsImhpZ2hCaXRzIiwiZnJvbUludCIsIm9iaiIsImNhY2hlZE9iaiIsImNhY2hlIiwiZnJvbU51bWJlciIsImlzTmFOIiwiVVpFUk8iLCJaRVJPIiwiTUFYX1VOU0lHTkVEX1ZBTFVFIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwibmVnIiwic3RyIiwicmFkaXgiLCJwIiwiaW5kZXhPZiIsInN1YnN0cmluZyIsInJhZGl4VG9Qb3dlciIsInJlc3VsdCIsIm1pbiIsInBvd2VyIiwibXVsIiwiYWRkIiwiZnJvbUJ5dGVzIiwibGUiLCJmcm9tQnl0ZXNMRSIsImZyb21CeXRlc0JFIiwiaXNMb25nIiwiZnJvbVZhbHVlIiwidmFsIiwiYWRkZW5kIiwiYTQ4IiwiYTMyIiwiYTE2IiwiYTAwIiwiYjQ4IiwiYjMyIiwiYjE2IiwiYjAwIiwiYzQ4IiwiYzMyIiwiYzE2IiwiYzAwIiwiYW5kIiwib3RoZXIiLCJjb21wYXJlIiwiZXEiLCJ0aGlzTmVnIiwiaXNOZWdhdGl2ZSIsIm90aGVyTmVnIiwic3ViIiwiY29tcCIsImRpdmlkZSIsImRpdmlzb3IiLCJpc1plcm8iLCJkaXZfdSIsImRpdl9zIiwiZ2V0X2hpZ2giLCJhcHByb3giLCJyZW0iLCJyZXMiLCJPTkUiLCJORUdfT05FIiwiaGFsZlRoaXMiLCJzaHIiLCJkaXYiLCJzaGwiLCJ0b1Vuc2lnbmVkIiwiZ3QiLCJzaHJ1IiwiVU9ORSIsImd0ZSIsIm1heCIsInRvTnVtYmVyIiwibG9nMiIsImNlaWwiLCJsb2ciLCJMTjIiLCJkZWx0YSIsImFwcHJveFJlcyIsImFwcHJveFJlbSIsImdldEhpZ2hCaXRzIiwiZ2V0SGlnaEJpdHNVbnNpZ25lZCIsImdldExvd0JpdHMiLCJnZXRMb3dCaXRzVW5zaWduZWQiLCJnZXROdW1CaXRzQWJzIiwiYml0IiwiZ3JlYXRlclRoYW4iLCJncmVhdGVyVGhhbk9yRXF1YWwiLCJnZSIsImlzRXZlbiIsImlzT2RkIiwiaXNQb3NpdGl2ZSIsImxlc3NUaGFuIiwibHQiLCJsZXNzVGhhbk9yRXF1YWwiLCJsdGUiLCJtb2R1bG8iLCJyZW1fdSIsInJlbV9zIiwibW9kIiwibXVsdGlwbHkiLCJtdWx0aXBsaWVyIiwiVFdPX1BXUl8yNCIsIm5lZ2F0ZSIsIm5vdCIsIm5vdEVxdWFscyIsIm5lcSIsIm5lIiwib3IiLCJzaGlmdExlZnQiLCJudW1CaXRzIiwidG9JbnQiLCJzaGlmdFJpZ2h0Iiwic2hpZnRSaWdodFVuc2lnbmVkIiwic2hyX3UiLCJzdWJ0cmFjdCIsInN1YnRyYWhlbmQiLCJ0b0JpZ0ludCIsIkJpZ0ludCIsInRvQnl0ZXMiLCJ0b0J5dGVzTEUiLCJ0b0J5dGVzQkUiLCJoaSIsImxvIiwidG9TaWduZWQiLCJyYWRpeExvbmciLCJyZW0xIiwicmVtRGl2IiwiaW50dmFsIiwiZGlnaXRzIiwieG9yIiwiZXF6IiwicmVsYXhlZCIsInVzZUJpZ0ludDY0IiwiYmlnSW50UmVzdWx0IiwiYXNJbnROIiwibG9uZ1Jlc3VsdCIsImxvbmdWYWwiLCJ1bnNpZ25lZFZhbCIsIlBBUlNFX1NUUklOR19SRUdFWFAiLCJQQVJTRV9JTkZfUkVHRVhQIiwiUEFSU0VfTkFOX1JFR0VYUCIsIkVYUE9ORU5UX01BWCIsIkVYUE9ORU5UX01JTiIsIkVYUE9ORU5UX0JJQVMiLCJNQVhfRElHSVRTIiwiTkFOX0JVRkZFUiIsInJldmVyc2UiLCJJTkZfTkVHQVRJVkVfQlVGRkVSIiwiSU5GX1BPU0lUSVZFX0JVRkZFUiIsIkVYUE9ORU5UX1JFR0VYIiwiQ09NQklOQVRJT05fTUFTSyIsIkVYUE9ORU5UX01BU0siLCJDT01CSU5BVElPTl9JTkZJTklUWSIsIkNPTUJJTkFUSU9OX05BTiIsImlzRGlnaXQiLCJkaXZpZGV1MTI4IiwiRElWSVNPUiIsIl9yZW0iLCJxdW90aWVudCIsIm11bHRpcGx5NjR4MiIsImxlZnQiLCJyaWdodCIsImxlZnRIaWdoIiwibGVmdExvdyIsInJpZ2h0SGlnaCIsInJpZ2h0TG93IiwicHJvZHVjdEhpZ2giLCJwcm9kdWN0TWlkIiwicHJvZHVjdE1pZDIiLCJwcm9kdWN0TG93IiwidWhsZWZ0IiwidWhyaWdodCIsInVsbGVmdCIsInVscmlnaHQiLCJpbnZhbGlkRXJyIiwiRGVjaW1hbDEyOCIsIl9mcm9tU3RyaW5nIiwiYWxsb3dSb3VuZGluZyIsImZyb21TdHJpbmdXaXRoUm91bmRpbmciLCJzYXdTaWduIiwic2F3UmFkaXgiLCJmb3VuZE5vblplcm8iLCJzaWduaWZpY2FudERpZ2l0cyIsIm5EaWdpdHNSZWFkIiwibkRpZ2l0cyIsInJhZGl4UG9zaXRpb24iLCJmaXJzdE5vblplcm8iLCJuRGlnaXRzU3RvcmVkIiwiZGlnaXRzSW5zZXJ0IiwibGFzdERpZ2l0IiwiZXhwb25lbnQiLCJzaWduaWZpY2FuZEhpZ2giLCJzaWduaWZpY2FuZExvdyIsImJpYXNlZEV4cG9uZW50IiwiaW5kZXgiLCJzdHJpbmdNYXRjaCIsIm1hdGNoIiwiaW5mTWF0Y2giLCJuYW5NYXRjaCIsInVuc2lnbmVkTnVtYmVyIiwiZSIsImV4cFNpZ24iLCJleHBOdW1iZXIiLCJzdWJzdHIiLCJkaWdpdHNTdHJpbmciLCJlbmRPZlN0cmluZyIsInJvdW5kRGlnaXQiLCJyb3VuZEJpdCIsImRJZHgiLCJzaWduaWZpY2FuZCIsImRlYyIsImJpYXNlZF9leHBvbmVudCIsInNpZ25pZmljYW5kX2RpZ2l0cyIsImlzX3plcm8iLCJzaWduaWZpY2FuZF9tc2IiLCJzaWduaWZpY2FuZDEyOCIsImoiLCJtaWRsIiwibWlkaCIsImNvbWJpbmF0aW9uIiwibGVhc3RfZGlnaXRzIiwic2NpZW50aWZpY19leHBvbmVudCIsInJhZGl4X3Bvc2l0aW9uIiwiJG51bWJlckRlY2ltYWwiLCJkMTI4c3RyaW5nIiwiRG91YmxlIiwidmFsdWVPZiIsImlzRmluaXRlIiwiaXMiLCJzaWduIiwiJG51bWJlckRvdWJsZSIsImlzSW50ZWdlciIsInRvRml4ZWQiLCJkb3VibGVWYWx1ZSIsInBhcnNlRmxvYXQiLCJJbnQzMiIsIiRudW1iZXJJbnQiLCJNYXhLZXkiLCIkbWF4S2V5IiwiTWluS2V5IiwiJG1pbktleSIsImNoZWNrRm9ySGV4UmVnRXhwIiwiUmVnRXhwIiwiUFJPQ0VTU19VTklRVUUiLCJrSWQiLCJPYmplY3RJZCIsImlucHV0SWQiLCJ3b3JraW5nSWQiLCJjYWNoZUhleFN0cmluZyIsIl9faWQiLCJnZXRJbmMiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsImluYyIsInNldFVpbnQzMiIsInZhcmlhYmxlIiwidG9Mb3dlckNhc2UiLCJvdGhlcklkU3RyaW5nIiwidGhpc0lkU3RyaW5nIiwiZ2V0VGltZXN0YW1wIiwiZ2V0VWludDMyIiwic2V0VGltZSIsImNyZWF0ZVBrIiwiY3JlYXRlRnJvbVRpbWUiLCIkb2lkIiwiaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplIiwic2VyaWFsaXplRnVuY3Rpb25zIiwiaWdub3JlVW5kZWZpbmVkIiwidG90YWxMZW5ndGgiLCJjYWxjdWxhdGVFbGVtZW50IiwidG9CU09OIiwia2V5IiwiYmluYXJ5Iiwib3JkZXJlZF92YWx1ZXMiLCJnbG9iYWwiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwicGF0dGVybiIsImFscGhhYmV0aXplIiwic29ydCIsIkJTT05SZWdFeHAiLCJwYXJzZU9wdGlvbnMiLCIkcmVnZXgiLCIkb3B0aW9ucyIsIiRyZWd1bGFyRXhwcmVzc2lvbiIsImZsYWdzIiwiQlNPTlN5bWJvbCIsIiRzeW1ib2wiLCJMb25nV2l0aG91dE92ZXJyaWRlc0NsYXNzIiwiVGltZXN0YW1wIiwidCIsIiR0aW1lc3RhbXAiLCJvcHRSYWRpeCIsIkZJUlNUX0JJVCIsIkZJUlNUX1RXT19CSVRTIiwiRklSU1RfVEhSRUVfQklUUyIsIkZJUlNUX0ZPVVJfQklUUyIsIkZJUlNUX0ZJVkVfQklUUyIsIlRXT19CSVRfQ0hBUiIsIlRIUkVFX0JJVF9DSEFSIiwiRk9VUl9CSVRfQ0hBUiIsIkNPTlRJTlVJTkdfQ0hBUiIsInZhbGlkYXRlVXRmOCIsImNvbnRpbnVhdGlvbiIsIkpTX0lOVF9NQVhfTE9ORyIsIkpTX0lOVF9NSU5fTE9ORyIsImludGVybmFsRGVzZXJpYWxpemUiLCJhbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSIsImRlc2VyaWFsaXplT2JqZWN0IiwiYWxsb3dlZERCUmVmS2V5cyIsImZpZWxkc0FzUmF3IiwicmF3IiwiYnNvblJlZ0V4cCIsInByb21vdGVCdWZmZXJzIiwicHJvbW90ZUxvbmdzIiwicHJvbW90ZVZhbHVlcyIsInZhbGlkYXRpb24iLCJ1dGY4IiwiZ2xvYmFsVVRGVmFsaWRhdGlvbiIsInZhbGlkYXRpb25TZXR0aW5nIiwidXRmOEtleXNTZXQiLCJTZXQiLCJ1dGY4VmFsaWRhdGVkS2V5cyIsInV0ZjhWYWxpZGF0aW9uVmFsdWVzIiwibWFwIiwiZXZlcnkiLCJpdGVtIiwic3RhcnRJbmRleCIsImFycmF5SW5kZXgiLCJkb25lIiwiaXNQb3NzaWJsZURCUmVmIiwiZGF0YXZpZXciLCJlbGVtZW50VHlwZSIsInNob3VsZFZhbGlkYXRlS2V5IiwiaGFzIiwic3RyaW5nU2l6ZSIsImdldFZhbGlkYXRlZFN0cmluZyIsImdldEZsb2F0NjQiLCJfaW5kZXgiLCJvYmplY3RTaXplIiwib2JqZWN0T3B0aW9ucyIsImFycmF5T3B0aW9ucyIsInN0b3BJbmRleCIsImdldEJpZ0ludDY0IiwiYmluYXJ5U2l6ZSIsInRvdGFsQmluYXJ5U2l6ZSIsIl9idWZmZXIiLCJyZWdFeHBPcHRpb25zIiwib3B0aW9uc0FycmF5IiwiZnVuY3Rpb25TdHJpbmciLCJ0b3RhbFNpemUiLCJzY29wZU9iamVjdCIsIm9pZEJ1ZmZlciIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwic2hvdWxkVmFsaWRhdGVVdGY4IiwicmVnZXhwIiwiaWdub3JlS2V5cyIsInNlcmlhbGl6ZVN0cmluZyIsIm51bWJlck9mV3JpdHRlbkJ5dGVzIiwiTlVNQkVSX1NQQUNFIiwiRk9VUl9CWVRFX1ZJRVdfT05fTlVNQkVSIiwiRUlHSFRfQllURV9WSUVXX09OX05VTUJFUiIsInNlcmlhbGl6ZU51bWJlciIsImlzTmVnYXRpdmVaZXJvIiwiaXNTYWZlSW50ZWdlciIsInNldEludDMyIiwic2V0RmxvYXQ2NCIsInNlcmlhbGl6ZUJpZ0ludCIsInNldEJpZ0ludDY0Iiwic2VyaWFsaXplTnVsbCIsIl8iLCJzZXJpYWxpemVCb29sZWFuIiwic2VyaWFsaXplRGF0ZSIsImRhdGVJbk1pbGlzIiwiZ2V0VGltZSIsInNlcmlhbGl6ZVJlZ0V4cCIsInNlcmlhbGl6ZUJTT05SZWdFeHAiLCJzb3J0ZWRPcHRpb25zIiwic2VyaWFsaXplTWluTWF4Iiwic2VyaWFsaXplT2JqZWN0SWQiLCJpZFZhbHVlIiwic2VyaWFsaXplQnVmZmVyIiwic2VyaWFsaXplT2JqZWN0IiwiY2hlY2tLZXlzIiwicGF0aCIsImVuZEluZGV4Iiwic2VyaWFsaXplSW50byIsImRlbGV0ZSIsInNlcmlhbGl6ZURlY2ltYWwxMjgiLCJzZXJpYWxpemVMb25nIiwic2VyaWFsaXplSW50MzIiLCJzZXJpYWxpemVEb3VibGUiLCJzZXJpYWxpemVGdW5jdGlvbiIsInNlcmlhbGl6ZUNvZGUiLCJjb2RlU2l6ZSIsInNlcmlhbGl6ZUJpbmFyeSIsInNlcmlhbGl6ZVN5bWJvbCIsInNlcmlhbGl6ZURCUmVmIiwib3V0cHV0Iiwic3RhcnRpbmdJbmRleCIsIk1hcCIsIml0ZXJhdG9yIiwiZW50cmllcyIsImVudHJ5IiwibmV4dCIsImlzQlNPTlR5cGUiLCJrZXlzVG9Db2RlY3MiLCJkZXNlcmlhbGl6ZVZhbHVlIiwiaW4zMkJpdFJhbmdlIiwiaW42NEJpdFJhbmdlIiwiJHVuZGVmaW5lZCIsImZpbHRlciIsInN0YXJ0c1dpdGgiLCIkZGF0ZSIsInBhcnNlIiwiJGRiUG9pbnRlciIsImRvbGxhcktleXMiLCJ2YWxpZCIsImZvckVhY2giLCJzZXJpYWxpemVBcnJheSIsInNlZW5PYmplY3RzIiwicHJvcGVydHlOYW1lIiwic2VyaWFsaXplVmFsdWUiLCJwb3AiLCJnZXRJU09TdHJpbmciLCJpc29TdHIiLCJ0b0lTT1N0cmluZyIsImdldFVUQ01pbGxpc2Vjb25kcyIsImNyZWF0ZSIsImZpbmRJbmRleCIsInByb3BzIiwibGVhZGluZ1BhcnQiLCJwcm9wIiwiYWxyZWFkeVNlZW4iLCJjaXJjdWxhclBhcnQiLCJjdXJyZW50IiwibGVhZGluZ1NwYWNlIiwicmVwZWF0IiwiZGFzaGVzIiwiZGF0ZU51bSIsImluUmFuZ2UiLCJyeCIsInNlcmlhbGl6ZURvY3VtZW50IiwiQlNPTl9UWVBFX01BUFBJTkdTIiwibG93XyIsImhpZ2hfIiwidW5zaWduZWRfIiwiYnNvbnR5cGUiLCJfZG9jIiwib3V0RG9jIiwibWFwcGVyIiwiZWpzb25PcHRpb25zIiwicmVwbGFjZXIiLCJzcGFjZSIsInNlcmlhbGl6ZU9wdGlvbnMiLCJFSlNPTnNlcmlhbGl6ZSIsIkVKU09OZGVzZXJpYWxpemUiLCJlanNvbiIsIkVKU09OIiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJNQVhTSVpFIiwic2V0SW50ZXJuYWxCdWZmZXJTaXplIiwibWluSW50ZXJuYWxCdWZmZXJTaXplIiwic2VyaWFsaXphdGlvbkluZGV4IiwiZmluaXNoZWRCdWZmZXIiLCJzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgiLCJmaW5hbEJ1ZmZlciIsImNhbGN1bGF0ZU9iamVjdFNpemUiLCJkZXNlcmlhbGl6ZVN0cmVhbSIsIm51bWJlck9mRG9jdW1lbnRzIiwiZG9jdW1lbnRzIiwiZG9jU3RhcnRJbmRleCIsImludGVybmFsT3B0aW9ucyIsImJ1ZmZlckRhdGEiLCJic29uIiwiX19wcm90b19fIiwiQlNPTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bson/lib/bson.cjs\n");

/***/ })

};
;