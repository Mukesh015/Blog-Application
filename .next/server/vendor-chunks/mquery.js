"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mquery";
exports.ids = ["vendor-chunks/mquery"];
exports.modules = {

/***/ "(ssr)/./node_modules/mquery/lib/collection/collection.js":
/*!**********************************************************!*\
  !*** ./node_modules/mquery/lib/collection/collection.js ***!
  \**********************************************************/
/***/ ((module, exports) => {

eval("\n/**\n * methods a collection must implement\n */ const methods = [\n    \"find\",\n    \"findOne\",\n    \"updateMany\",\n    \"updateOne\",\n    \"replaceOne\",\n    \"count\",\n    \"distinct\",\n    \"findOneAndDelete\",\n    \"findOneAndUpdate\",\n    \"aggregate\",\n    \"findCursor\",\n    \"deleteOne\",\n    \"deleteMany\"\n];\n/**\n * Collection base class from which implementations inherit\n */ function Collection() {}\nfor(let i = 0, len = methods.length; i < len; ++i){\n    const method = methods[i];\n    Collection.prototype[method] = notImplemented(method);\n}\nmodule.exports = exports = Collection;\nCollection.methods = methods;\n/**\n * creates a function which throws an implementation error\n */ function notImplemented(method) {\n    return function() {\n        throw new Error(\"collection.\" + method + \" not implemented\");\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Q0FFQyxHQUVELE1BQU1BLFVBQVU7SUFDZDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQ7O0NBRUMsR0FFRCxTQUFTQyxjQUFjO0FBRXZCLElBQUssSUFBSUMsSUFBSSxHQUFHQyxNQUFNSCxRQUFRSSxNQUFNLEVBQUVGLElBQUlDLEtBQUssRUFBRUQsRUFBRztJQUNsRCxNQUFNRyxTQUFTTCxPQUFPLENBQUNFLEVBQUU7SUFDekJELFdBQVdLLFNBQVMsQ0FBQ0QsT0FBTyxHQUFHRSxlQUFlRjtBQUNoRDtBQUVBRyxPQUFPQyxPQUFPLEdBQUdBLFVBQVVSO0FBQzNCQSxXQUFXRCxPQUFPLEdBQUdBO0FBRXJCOztDQUVDLEdBRUQsU0FBU08sZUFBZUYsTUFBTTtJQUM1QixPQUFPO1FBQ0wsTUFBTSxJQUFJSyxNQUFNLGdCQUFnQkwsU0FBUztJQUMzQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmxvZy1hcHBsaWNhdGlvbi8uL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL2NvbGxlY3Rpb24vY29sbGVjdGlvbi5qcz82NTZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBtZXRob2RzIGEgY29sbGVjdGlvbiBtdXN0IGltcGxlbWVudFxuICovXG5cbmNvbnN0IG1ldGhvZHMgPSBbXG4gICdmaW5kJyxcbiAgJ2ZpbmRPbmUnLFxuICAndXBkYXRlTWFueScsXG4gICd1cGRhdGVPbmUnLFxuICAncmVwbGFjZU9uZScsXG4gICdjb3VudCcsXG4gICdkaXN0aW5jdCcsXG4gICdmaW5kT25lQW5kRGVsZXRlJyxcbiAgJ2ZpbmRPbmVBbmRVcGRhdGUnLFxuICAnYWdncmVnYXRlJyxcbiAgJ2ZpbmRDdXJzb3InLFxuICAnZGVsZXRlT25lJyxcbiAgJ2RlbGV0ZU1hbnknXG5dO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gYmFzZSBjbGFzcyBmcm9tIHdoaWNoIGltcGxlbWVudGF0aW9ucyBpbmhlcml0XG4gKi9cblxuZnVuY3Rpb24gQ29sbGVjdGlvbigpIHt9XG5cbmZvciAobGV0IGkgPSAwLCBsZW4gPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGNvbnN0IG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gIENvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBub3RJbXBsZW1lbnRlZChtZXRob2QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDb2xsZWN0aW9uO1xuQ29sbGVjdGlvbi5tZXRob2RzID0gbWV0aG9kcztcblxuLyoqXG4gKiBjcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGltcGxlbWVudGF0aW9uIGVycm9yXG4gKi9cblxuZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbGxlY3Rpb24uJyArIG1ldGhvZCArICcgbm90IGltcGxlbWVudGVkJyk7XG4gIH07XG59XG4iXSwibmFtZXMiOlsibWV0aG9kcyIsIkNvbGxlY3Rpb24iLCJpIiwibGVuIiwibGVuZ3RoIiwibWV0aG9kIiwicHJvdG90eXBlIiwibm90SW1wbGVtZW50ZWQiLCJtb2R1bGUiLCJleHBvcnRzIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/collection/collection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/collection/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mquery/lib/collection/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst env = __webpack_require__(/*! ../env */ \"(ssr)/./node_modules/mquery/lib/env.js\");\nif (\"unknown\" == env.type) {\n    throw new Error(\"Unknown environment\");\n}\nmodule.exports = env.isNode ? __webpack_require__(/*! ./node */ \"(ssr)/./node_modules/mquery/lib/collection/node.js\") : env.isMongo ? __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\") : __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFFcEIsSUFBSSxhQUFhRCxJQUFJRSxJQUFJLEVBQUU7SUFDekIsTUFBTSxJQUFJQyxNQUFNO0FBQ2xCO0FBRUFDLE9BQU9DLE9BQU8sR0FDWkwsSUFBSU0sTUFBTSxHQUFHTCxtQkFBT0EsQ0FBQyxzRUFDbkJELElBQUlPLE9BQU8sR0FBR04sbUJBQU9BLENBQUMsa0ZBQ3BCQSxtQkFBT0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Jsb2ctYXBwbGljYXRpb24vLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL2luZGV4LmpzPzdiZTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBlbnYgPSByZXF1aXJlKCcuLi9lbnYnKTtcblxuaWYgKCd1bmtub3duJyA9PSBlbnYudHlwZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW52aXJvbm1lbnQnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuICBlbnYuaXNOb2RlID8gcmVxdWlyZSgnLi9ub2RlJykgOlxuICAgIGVudi5pc01vbmdvID8gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJykgOlxuICAgICAgcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbiJdLCJuYW1lcyI6WyJlbnYiLCJyZXF1aXJlIiwidHlwZSIsIkVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsImlzTm9kZSIsImlzTW9uZ28iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/collection/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/collection/node.js":
/*!****************************************************!*\
  !*** ./node_modules/mquery/lib/collection/node.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n/**\n * Module dependencies\n */ const Collection = __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\");\nclass NodeCollection extends Collection {\n    constructor(col){\n        super();\n        this.collection = col;\n        this.collectionName = col.collectionName;\n    }\n    /**\n   * find(match, options)\n   */ async find(match, options) {\n        const cursor = this.collection.find(match, options);\n        return cursor.toArray();\n    }\n    /**\n   * findOne(match, options)\n   */ async findOne(match, options) {\n        return this.collection.findOne(match, options);\n    }\n    /**\n   * count(match, options)\n   */ async count(match, options) {\n        return this.collection.count(match, options);\n    }\n    /**\n   * distinct(prop, match, options)\n   */ async distinct(prop, match, options) {\n        return this.collection.distinct(prop, match, options);\n    }\n    /**\n   * updateMany(match, update, options)\n   */ async updateMany(match, update, options) {\n        return this.collection.updateMany(match, update, options);\n    }\n    /**\n   * updateOne(match, update, options)\n   */ async updateOne(match, update, options) {\n        return this.collection.updateOne(match, update, options);\n    }\n    /**\n   * replaceOne(match, update, options)\n   */ async replaceOne(match, update, options) {\n        return this.collection.replaceOne(match, update, options);\n    }\n    /**\n   * deleteOne(match, options)\n   */ async deleteOne(match, options) {\n        return this.collection.deleteOne(match, options);\n    }\n    /**\n   * deleteMany(match, options)\n   */ async deleteMany(match, options) {\n        return this.collection.deleteMany(match, options);\n    }\n    /**\n   * findOneAndDelete(match, options, function(err[, result])\n   */ async findOneAndDelete(match, options) {\n        return this.collection.findOneAndDelete(match, options);\n    }\n    /**\n   * findOneAndUpdate(match, update, options)\n   */ async findOneAndUpdate(match, update, options) {\n        return this.collection.findOneAndUpdate(match, update, options);\n    }\n    /**\n   * var cursor = findCursor(match, options)\n   */ findCursor(match, options) {\n        return this.collection.find(match, options);\n    }\n}\n/**\n * Expose\n */ module.exports = exports = NodeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9jb2xsZWN0aW9uL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Q0FFQyxHQUVELE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDO0FBRTNCLE1BQU1DLHVCQUF1QkY7SUFDM0JHLFlBQVlDLEdBQUcsQ0FBRTtRQUNmLEtBQUs7UUFFTCxJQUFJLENBQUNDLFVBQVUsR0FBR0Q7UUFDbEIsSUFBSSxDQUFDRSxjQUFjLEdBQUdGLElBQUlFLGNBQWM7SUFDMUM7SUFFQTs7R0FFQyxHQUNELE1BQU1DLEtBQUtDLEtBQUssRUFBRUMsT0FBTyxFQUFFO1FBQ3pCLE1BQU1DLFNBQVMsSUFBSSxDQUFDTCxVQUFVLENBQUNFLElBQUksQ0FBQ0MsT0FBT0M7UUFFM0MsT0FBT0MsT0FBT0MsT0FBTztJQUN2QjtJQUVBOztHQUVDLEdBQ0QsTUFBTUMsUUFBUUosS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDNUIsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ08sT0FBTyxDQUFDSixPQUFPQztJQUN4QztJQUVBOztHQUVDLEdBQ0QsTUFBTUksTUFBTUwsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ1EsS0FBSyxDQUFDTCxPQUFPQztJQUN0QztJQUVBOztHQUVDLEdBQ0QsTUFBTUssU0FBU0MsSUFBSSxFQUFFUCxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNuQyxPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDUyxRQUFRLENBQUNDLE1BQU1QLE9BQU9DO0lBQy9DO0lBRUE7O0dBRUMsR0FDRCxNQUFNTyxXQUFXUixLQUFLLEVBQUVTLE1BQU0sRUFBRVIsT0FBTyxFQUFFO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDSixVQUFVLENBQUNXLFVBQVUsQ0FBQ1IsT0FBT1MsUUFBUVI7SUFDbkQ7SUFFQTs7R0FFQyxHQUNELE1BQU1TLFVBQVVWLEtBQUssRUFBRVMsTUFBTSxFQUFFUixPQUFPLEVBQUU7UUFDdEMsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ2EsU0FBUyxDQUFDVixPQUFPUyxRQUFRUjtJQUNsRDtJQUVBOztHQUVDLEdBQ0QsTUFBTVUsV0FBV1gsS0FBSyxFQUFFUyxNQUFNLEVBQUVSLE9BQU8sRUFBRTtRQUN2QyxPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDYyxVQUFVLENBQUNYLE9BQU9TLFFBQVFSO0lBQ25EO0lBRUE7O0dBRUMsR0FDRCxNQUFNVyxVQUFVWixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUM5QixPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDZSxTQUFTLENBQUNaLE9BQU9DO0lBQzFDO0lBRUE7O0dBRUMsR0FDRCxNQUFNWSxXQUFXYixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUMvQixPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDZ0IsVUFBVSxDQUFDYixPQUFPQztJQUMzQztJQUVBOztHQUVDLEdBQ0QsTUFBTWEsaUJBQWlCZCxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDaUIsZ0JBQWdCLENBQUNkLE9BQU9DO0lBQ2pEO0lBRUE7O0dBRUMsR0FDRCxNQUFNYyxpQkFBaUJmLEtBQUssRUFBRVMsTUFBTSxFQUFFUixPQUFPLEVBQUU7UUFDN0MsT0FBTyxJQUFJLENBQUNKLFVBQVUsQ0FBQ2tCLGdCQUFnQixDQUFDZixPQUFPUyxRQUFRUjtJQUN6RDtJQUVBOztHQUVDLEdBQ0RlLFdBQVdoQixLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUN6QixPQUFPLElBQUksQ0FBQ0osVUFBVSxDQUFDRSxJQUFJLENBQUNDLE9BQU9DO0lBQ3JDO0FBTUY7QUFHQTs7Q0FFQyxHQUVEZ0IsT0FBT0MsT0FBTyxHQUFHQSxVQUFVeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9nLWFwcGxpY2F0aW9uLy4vbm9kZV9tb2R1bGVzL21xdWVyeS9saWIvY29sbGVjdGlvbi9ub2RlLmpzPzQzMzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG5jb25zdCBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbmNsYXNzIE5vZGVDb2xsZWN0aW9uIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2w7XG4gICAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbC5jb2xsZWN0aW9uTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kKG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZmluZChtYXRjaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuY29sbGVjdGlvbi5maW5kKG1hdGNoLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBjdXJzb3IudG9BcnJheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmRPbmUobWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBmaW5kT25lKG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5maW5kT25lKG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb3VudChtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGNvdW50KG1hdGNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5jb3VudChtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZGlzdGluY3QocHJvcCwgbWF0Y2gsIG9wdGlvbnMpXG4gICAqL1xuICBhc3luYyBkaXN0aW5jdChwcm9wLCBtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZGlzdGluY3QocHJvcCwgbWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZU1hbnkobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIHVwZGF0ZU1hbnkobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24udXBkYXRlTWFueShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB1cGRhdGVPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIHVwZGF0ZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi51cGRhdGVPbmUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogcmVwbGFjZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgcmVwbGFjZU9uZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbi5yZXBsYWNlT25lKG1hdGNoLCB1cGRhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlbGV0ZU9uZShtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGRlbGV0ZU9uZShtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZGVsZXRlT25lKG1hdGNoLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWxldGVNYW55KG1hdGNoLCBvcHRpb25zKVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlTWFueShtYXRjaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZGVsZXRlTWFueShtYXRjaCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogZmluZE9uZUFuZERlbGV0ZShtYXRjaCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyWywgcmVzdWx0XSlcbiAgICovXG4gIGFzeW5jIGZpbmRPbmVBbmREZWxldGUobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmZpbmRPbmVBbmREZWxldGUobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGZpbmRPbmVBbmRVcGRhdGUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucylcbiAgICovXG4gIGFzeW5jIGZpbmRPbmVBbmRVcGRhdGUobWF0Y2gsIHVwZGF0ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZmluZE9uZUFuZFVwZGF0ZShtYXRjaCwgdXBkYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB2YXIgY3Vyc29yID0gZmluZEN1cnNvcihtYXRjaCwgb3B0aW9ucylcbiAgICovXG4gIGZpbmRDdXJzb3IobWF0Y2gsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmZpbmQobWF0Y2gsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGFnZ3JlZ2F0aW9uKG9wZXJhdG9ycy4uLilcbiAgICogVE9ET1xuICAgKi9cbn1cblxuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IE5vZGVDb2xsZWN0aW9uO1xuIl0sIm5hbWVzIjpbIkNvbGxlY3Rpb24iLCJyZXF1aXJlIiwiTm9kZUNvbGxlY3Rpb24iLCJjb25zdHJ1Y3RvciIsImNvbCIsImNvbGxlY3Rpb24iLCJjb2xsZWN0aW9uTmFtZSIsImZpbmQiLCJtYXRjaCIsIm9wdGlvbnMiLCJjdXJzb3IiLCJ0b0FycmF5IiwiZmluZE9uZSIsImNvdW50IiwiZGlzdGluY3QiLCJwcm9wIiwidXBkYXRlTWFueSIsInVwZGF0ZSIsInVwZGF0ZU9uZSIsInJlcGxhY2VPbmUiLCJkZWxldGVPbmUiLCJkZWxldGVNYW55IiwiZmluZE9uZUFuZERlbGV0ZSIsImZpbmRPbmVBbmRVcGRhdGUiLCJmaW5kQ3Vyc29yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/collection/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/env.js":
/*!****************************************!*\
  !*** ./node_modules/mquery/lib/env.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.isNode = \"undefined\" != typeof process && \"object\" == \"object\" && \"object\" == typeof global && \"function\" == typeof Buffer && process.argv;\nexports.isMongo = !exports.isNode && \"function\" == typeof printjson && \"function\" == typeof ObjectId && \"function\" == typeof rs && \"function\" == typeof sh;\nexports.isBrowser = !exports.isNode && !exports.isMongo && \"undefined\" != \"undefined\";\nexports.type = exports.isNode ? \"node\" : exports.isMongo ? \"mongo\" : exports.isBrowser ? \"browser\" : \"unknown\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9lbnYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsY0FBYyxHQUFHLGVBQWUsT0FBT0UsV0FDekIsWUFBWSxRQUFhQyxJQUN6QixZQUFZLE9BQU9DLFVBQ25CLGNBQWMsT0FBT0MsVUFDckJILFFBQVFJLElBQUk7QUFFMUJOLGVBQWUsR0FBRyxDQUFDQSxRQUFRQyxNQUFNLElBQ25CLGNBQWMsT0FBT08sYUFDckIsY0FBYyxPQUFPQyxZQUNyQixjQUFjLE9BQU9DLE1BQ3JCLGNBQWMsT0FBT0M7QUFFbkNYLGlCQUFpQixHQUFHLENBQUNBLFFBQVFDLE1BQU0sSUFDZixDQUFDRCxRQUFRTyxPQUFPLElBQ2hCLGVBQWU7QUFFbkNQLFlBQVksR0FBR0EsUUFBUUMsTUFBTSxHQUFHLFNBQzVCRCxRQUFRTyxPQUFPLEdBQUcsVUFDaEJQLFFBQVFZLFNBQVMsR0FBRyxZQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Jsb2ctYXBwbGljYXRpb24vLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9lbnYuanM/MWVlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuaXNOb2RlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIHByb2Nlc3NcbiAgICAgICAgICAgJiYgJ29iamVjdCcgPT0gdHlwZW9mIG1vZHVsZVxuICAgICAgICAgICAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZ2xvYmFsXG4gICAgICAgICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIEJ1ZmZlclxuICAgICAgICAgICAmJiBwcm9jZXNzLmFyZ3Y7XG5cbmV4cG9ydHMuaXNNb25nbyA9ICFleHBvcnRzLmlzTm9kZVxuICAgICAgICAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBwcmludGpzb25cbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgT2JqZWN0SWRcbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgcnNcbiAgICAgICAgICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc2g7XG5cbmV4cG9ydHMuaXNCcm93c2VyID0gIWV4cG9ydHMuaXNOb2RlXG4gICAgICAgICAgICAgICAgICYmICFleHBvcnRzLmlzTW9uZ29cbiAgICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIHdpbmRvdztcblxuZXhwb3J0cy50eXBlID0gZXhwb3J0cy5pc05vZGUgPyAnbm9kZSdcbiAgOiBleHBvcnRzLmlzTW9uZ28gPyAnbW9uZ28nXG4gICAgOiBleHBvcnRzLmlzQnJvd3NlciA/ICdicm93c2VyJ1xuICAgICAgOiAndW5rbm93bic7XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsImlzTm9kZSIsInByb2Nlc3MiLCJtb2R1bGUiLCJnbG9iYWwiLCJCdWZmZXIiLCJhcmd2IiwiaXNNb25nbyIsInByaW50anNvbiIsIk9iamVjdElkIiwicnMiLCJzaCIsImlzQnJvd3NlciIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/mquery.js":
/*!*******************************************!*\
  !*** ./node_modules/mquery/lib/mquery.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n/**\n * Dependencies\n */ const assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mquery/lib/utils.js\");\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")(\"mquery\");\n/**\n * Query constructor used for building queries.\n *\n * #### Example:\n *\n *     var query = new Query({ name: 'mquery' });\n *     query.setOptions({ collection: moduleCollection })\n *     await query.where('age').gte(21).exec();\n *\n * @param {Object} [criteria] criteria for the query OR the collection instance to use\n * @param {Object} [options]\n * @api public\n */ function Query(criteria, options) {\n    if (!(this instanceof Query)) return new Query(criteria, options);\n    const proto = this.constructor.prototype;\n    this.op = proto.op || undefined;\n    this.options = Object.assign({}, proto.options);\n    this._conditions = proto._conditions ? utils.clone(proto._conditions) : {};\n    this._fields = proto._fields ? utils.clone(proto._fields) : undefined;\n    this._updateDoc = proto._updateDoc ? utils.clone(proto._updateDoc) : undefined;\n    this._path = proto._path || undefined;\n    this._distinctDoc = proto._distinctDoc || undefined;\n    this._collection = proto._collection || undefined;\n    this._traceFunction = proto._traceFunction || undefined;\n    if (options) {\n        this.setOptions(options);\n    }\n    if (criteria) {\n        this.find(criteria);\n    }\n}\n/**\n * This is a parameter that the user can set which determines if mquery\n * uses $within or $geoWithin for queries. It defaults to true which\n * means $geoWithin will be used. If using MongoDB < 2.4 you should\n * set this to false.\n *\n * @api public\n * @property use$geoWithin\n */ let $withinCmd = \"$geoWithin\";\nObject.defineProperty(Query, \"use$geoWithin\", {\n    get: function() {\n        return $withinCmd == \"$geoWithin\";\n    },\n    set: function(v) {\n        if (true === v) {\n            // mongodb >= 2.4\n            $withinCmd = \"$geoWithin\";\n        } else {\n            $withinCmd = \"$within\";\n        }\n    }\n});\n/**\n * Converts this query to a constructor function with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query that will read documents with a \"video\" category from\n *     // `aCollection` on the primary node in the replica-set unless it is down,\n *     // in which case we'll read from a secondary node.\n *     var query = mquery({ category: 'video' })\n *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });\n *\n *     // create a constructor based off these settings\n *     var Video = query.toConstructor();\n *\n *     // Video is now a subclass of mquery() and works the same way but with the\n *     // default query parameters and options set.\n *\n *     // run a query with the previous settings but filter for movies with names\n *     // that start with \"Life\".\n *     Video().where({ name: /^Life/ }).exec(cb);\n *\n * @return {Query} new Query\n * @api public\n */ Query.prototype.toConstructor = function toConstructor() {\n    function CustomQuery(criteria, options) {\n        if (!(this instanceof CustomQuery)) return new CustomQuery(criteria, options);\n        Query.call(this, criteria, options);\n    }\n    utils.inherits(CustomQuery, Query);\n    // set inherited defaults\n    const p = CustomQuery.prototype;\n    p.options = {};\n    p.setOptions(this.options);\n    p.op = this.op;\n    p._conditions = utils.clone(this._conditions);\n    p._fields = utils.clone(this._fields);\n    p._updateDoc = utils.clone(this._updateDoc);\n    p._path = this._path;\n    p._distinctDoc = this._distinctDoc;\n    p._collection = this._collection;\n    p._traceFunction = this._traceFunction;\n    return CustomQuery;\n};\n/**\n * Sets query options.\n *\n * #### Options:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D) *\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *\n * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *\n * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *\n * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)\n * - collection the collection to query against\n *\n * _* denotes a query helper method is also available_\n *\n * @param {Object} options\n * @api public\n */ Query.prototype.setOptions = function(options) {\n    if (!(options && utils.isObject(options))) return this;\n    // set arbitrary options\n    const methods = utils.keys(options);\n    let method;\n    for(let i = 0; i < methods.length; ++i){\n        method = methods[i];\n        // use methods if exist (safer option manipulation)\n        if (\"function\" == typeof this[method]) {\n            const args = Array.isArray(options[method]) ? options[method] : [\n                options[method]\n            ];\n            this[method].apply(this, args);\n        } else {\n            this.options[method] = options[method];\n        }\n    }\n    return this;\n};\n/**\n * Sets this Querys collection.\n *\n * @param {Collection} coll\n * @return {Query} this\n */ Query.prototype.collection = function collection(coll) {\n    this._collection = new Query.Collection(coll);\n    return this;\n};\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * #### Example:\n *\n *     query.find().collation({ locale: \"en_US\", strength: 1 })\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */ Query.prototype.collation = function(value) {\n    this.options.collation = value;\n    return this;\n};\n/**\n * Specifies a `$where` condition\n *\n * Use `$where` when you need to select documents using a JavaScript expression.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length > 10 || this.name.length > 5')\n *\n *     query.$where(function () {\n *       return this.comments.length > 10 || this.name.length > 5;\n *     })\n *\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @method $where\n * @api public\n */ Query.prototype.$where = function(js) {\n    this._conditions.$where = js;\n    return this;\n};\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     await User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     await User\n *       .where('age').gte(21).lte(65)\n *       .where('name', /^vonderful/i)\n *       .where('friends').slice(10)\n *       .exec()\n *\n * @param {String} [path]\n * @param {Object} [val]\n * @return {Query} this\n * @api public\n */ Query.prototype.where = function() {\n    if (!arguments.length) return this;\n    if (!this.op) this.op = \"find\";\n    const type = typeof arguments[0];\n    if (\"string\" == type) {\n        this._path = arguments[0];\n        if (2 === arguments.length) {\n            this._conditions[this._path] = arguments[1];\n        }\n        return this;\n    }\n    if (\"object\" == type && !Array.isArray(arguments[0])) {\n        return this.merge(arguments[0]);\n    }\n    throw new TypeError(\"path must be a string or object\");\n};\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */ Query.prototype.equals = function equals(val) {\n    this._ensurePath(\"equals\");\n    const path = this._path;\n    this._conditions[path] = val;\n    return this;\n};\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n * This is alias of `equals`\n *\n * #### Example:\n *\n *     User.where('age').eq(49);\n *\n *     // is the same as\n *\n *     User.shere('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */ Query.prototype.eq = function eq(val) {\n    this._ensurePath(\"eq\");\n    const path = this._path;\n    this._conditions[path] = val;\n    return this;\n};\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */ Query.prototype.or = function or(array) {\n    const or = this._conditions.$or || (this._conditions.$or = []);\n    if (!Array.isArray(array)) array = [\n        array\n    ];\n    or.push.apply(or, array);\n    return this;\n};\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */ Query.prototype.nor = function nor(array) {\n    const nor = this._conditions.$nor || (this._conditions.$nor = []);\n    if (!Array.isArray(array)) array = [\n        array\n    ];\n    nor.push.apply(nor, array);\n    return this;\n};\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @see $and http://docs.mongodb.org/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */ Query.prototype.and = function and(array) {\n    const and = this._conditions.$and || (this._conditions.$and = []);\n    if (!Array.isArray(array)) array = [\n        array\n    ];\n    and.push.apply(and, array);\n    return this;\n};\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method ne\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method in\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method nin\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method all\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method size\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method regex\n * @memberOf Query\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */ /**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method maxDistance\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */ /*!\n * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance\n *\n *     Thing.where('type').nin(array)\n */ \"gt gte lt lte ne in nin all regex size maxDistance minDistance\".split(\" \").forEach(function($conditional) {\n    Query.prototype[$conditional] = function() {\n        let path, val;\n        if (1 === arguments.length) {\n            this._ensurePath($conditional);\n            val = arguments[0];\n            path = this._path;\n        } else {\n            val = arguments[1];\n            path = arguments[0];\n        }\n        const conds = this._conditions[path] === null || typeof this._conditions[path] === \"object\" ? this._conditions[path] : this._conditions[path] = {};\n        conds[\"$\" + $conditional] = val;\n        return this;\n    };\n});\n/**\n * Specifies a `$mod` condition\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */ Query.prototype.mod = function() {\n    let val, path;\n    if (1 === arguments.length) {\n        this._ensurePath(\"mod\");\n        val = arguments[0];\n        path = this._path;\n    } else if (2 === arguments.length && !Array.isArray(arguments[1])) {\n        this._ensurePath(\"mod\");\n        val = [\n            arguments[0],\n            arguments[1]\n        ];\n        path = this._path;\n    } else if (3 === arguments.length) {\n        val = [\n            arguments[1],\n            arguments[2]\n        ];\n        path = arguments[0];\n    } else {\n        val = arguments[1];\n        path = arguments[0];\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds.$mod = val;\n    return this;\n};\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */ Query.prototype.exists = function() {\n    let path, val;\n    if (0 === arguments.length) {\n        this._ensurePath(\"exists\");\n        path = this._path;\n        val = true;\n    } else if (1 === arguments.length) {\n        if (\"boolean\" === typeof arguments[0]) {\n            this._ensurePath(\"exists\");\n            path = this._path;\n            val = arguments[0];\n        } else {\n            path = arguments[0];\n            val = true;\n        }\n    } else if (2 === arguments.length) {\n        path = arguments[0];\n        val = arguments[1];\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds.$exists = val;\n    return this;\n};\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @api public\n */ Query.prototype.elemMatch = function() {\n    if (null == arguments[0]) throw new TypeError(\"Invalid argument\");\n    let fn, path, criteria;\n    if (\"function\" === typeof arguments[0]) {\n        this._ensurePath(\"elemMatch\");\n        path = this._path;\n        fn = arguments[0];\n    } else if (utils.isObject(arguments[0])) {\n        this._ensurePath(\"elemMatch\");\n        path = this._path;\n        criteria = arguments[0];\n    } else if (\"function\" === typeof arguments[1]) {\n        path = arguments[0];\n        fn = arguments[1];\n    } else if (arguments[1] && utils.isObject(arguments[1])) {\n        path = arguments[0];\n        criteria = arguments[1];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (fn) {\n        criteria = new Query;\n        fn(criteria);\n        criteria = criteria._conditions;\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds.$elemMatch = criteria;\n    return this;\n};\n// Spatial queries\n/**\n * Sugar for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.within().box()\n *     query.within().circle()\n *     query.within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * #### Note:\n *\n * Must be used after `where()`.\n *\n * @memberOf Query\n * @return {Query} this\n * @api public\n */ Query.prototype.within = function within() {\n    // opinionated, must be used after where\n    this._ensurePath(\"within\");\n    this._geoComparison = $withinCmd;\n    if (0 === arguments.length) {\n        return this;\n    }\n    if (2 === arguments.length) {\n        return this.box.apply(this, arguments);\n    } else if (2 < arguments.length) {\n        return this.polygon.apply(this, arguments);\n    }\n    const area = arguments[0];\n    if (!area) throw new TypeError(\"Invalid argument\");\n    if (area.center) return this.circle(area);\n    if (area.box) return this.box.apply(this, area.box);\n    if (area.polygon) return this.polygon.apply(this, area.polygon);\n    if (area.type && area.coordinates) return this.geometry(area);\n    throw new TypeError(\"Invalid argument\");\n};\n/**\n * Specifies a $box condition\n *\n * #### Example:\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box('loc', lowerLeft, upperRight )\n *\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see Query#within #query_Query-within\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @api public\n */ Query.prototype.box = function() {\n    let path, box;\n    if (3 === arguments.length) {\n        // box('loc', [], [])\n        path = arguments[0];\n        box = [\n            arguments[1],\n            arguments[2]\n        ];\n    } else if (2 === arguments.length) {\n        // box([], [])\n        this._ensurePath(\"box\");\n        path = this._path;\n        box = [\n            arguments[0],\n            arguments[1]\n        ];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds[this._geoComparison || $withinCmd] = {\n        $box: box\n    };\n    return this;\n};\n/**\n * Specifies a $polygon condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])\n *     query.polygon('loc', [10,20], [13, 25], [7,15])\n *\n * @param {String|Array} [path]\n * @param {Array|Object} [val]\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */ Query.prototype.polygon = function() {\n    let val, path;\n    if (\"string\" == typeof arguments[0]) {\n        // polygon('loc', [],[],[])\n        val = Array.from(arguments);\n        path = val.shift();\n    } else {\n        // polygon([],[],[])\n        this._ensurePath(\"polygon\");\n        path = this._path;\n        val = Array.from(arguments);\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds[this._geoComparison || $withinCmd] = {\n        $polygon: val\n    };\n    return this;\n};\n/**\n * Specifies a $center or $centerSphere condition.\n *\n * #### Example:\n *\n *     var area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n *     // for spherical calculations\n *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */ Query.prototype.circle = function() {\n    let path, val;\n    if (1 === arguments.length) {\n        this._ensurePath(\"circle\");\n        path = this._path;\n        val = arguments[0];\n    } else if (2 === arguments.length) {\n        path = arguments[0];\n        val = arguments[1];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (!(\"radius\" in val && val.center)) throw new Error(\"center and radius are required\");\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    const type = val.spherical ? \"$centerSphere\" : \"$center\";\n    const wKey = this._geoComparison || $withinCmd;\n    conds[wKey] = {};\n    conds[wKey][type] = [\n        val.center,\n        val.radius\n    ];\n    if (\"unique\" in val) conds[wKey].$uniqueDocs = !!val.unique;\n    return this;\n};\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *     query.near({ center: { type: 'Point', coordinates: [..] }})\n *     query.near().geometry({ type: 'Point', coordinates: [..] })\n *\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */ Query.prototype.near = function near() {\n    let path, val;\n    this._geoComparison = \"$near\";\n    if (0 === arguments.length) {\n        return this;\n    } else if (1 === arguments.length) {\n        this._ensurePath(\"near\");\n        path = this._path;\n        val = arguments[0];\n    } else if (2 === arguments.length) {\n        path = arguments[0];\n        val = arguments[1];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (!val.center) {\n        throw new Error(\"center is required\");\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    const type = val.spherical ? \"$nearSphere\" : \"$near\";\n    // center could be a GeoJSON object or an Array\n    if (Array.isArray(val.center)) {\n        conds[type] = val.center;\n        const radius = \"maxDistance\" in val ? val.maxDistance : null;\n        if (null != radius) {\n            conds.$maxDistance = radius;\n        }\n        if (null != val.minDistance) {\n            conds.$minDistance = val.minDistance;\n        }\n    } else {\n        // GeoJSON?\n        if (val.center.type != \"Point\" || !Array.isArray(val.center.coordinates)) {\n            throw new Error(util.format(\"Invalid GeoJSON specified for %s\", type));\n        }\n        conds[type] = {\n            $geometry: val.center\n        };\n        // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere\n        if (\"maxDistance\" in val) {\n            conds[type][\"$maxDistance\"] = val.maxDistance;\n        }\n        if (\"minDistance\" in val) {\n            conds[type][\"$minDistance\"] = val.minDistance;\n        }\n    }\n    return this;\n};\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n *     query.where('path').intersects({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n * @param {Object} [arg]\n * @return {Query} this\n * @api public\n */ Query.prototype.intersects = function intersects() {\n    // opinionated, must be used after where\n    this._ensurePath(\"intersects\");\n    this._geoComparison = \"$geoIntersects\";\n    if (0 === arguments.length) {\n        return this;\n    }\n    const area = arguments[0];\n    if (null != area && area.type && area.coordinates) return this.geometry(area);\n    throw new TypeError(\"Invalid argument\");\n};\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     var polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     var polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * The most recent path passed to `where()` is used.\n *\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @api public\n */ Query.prototype.geometry = function geometry() {\n    if (!(\"$within\" == this._geoComparison || \"$geoWithin\" == this._geoComparison || \"$near\" == this._geoComparison || \"$geoIntersects\" == this._geoComparison)) {\n        throw new Error(\"geometry() must come after `within()`, `intersects()`, or `near()\");\n    }\n    let val, path;\n    if (1 === arguments.length) {\n        this._ensurePath(\"geometry\");\n        path = this._path;\n        val = arguments[0];\n    } else {\n        throw new TypeError(\"Invalid argument\");\n    }\n    if (!(val.type && Array.isArray(val.coordinates))) {\n        throw new TypeError(\"Invalid argument\");\n    }\n    const conds = this._conditions[path] || (this._conditions[path] = {});\n    conds[this._geoComparison] = {\n        $geometry: val\n    };\n    return this;\n};\n// end spatial\n/**\n * Specifies which document fields to include or exclude\n *\n * #### String syntax\n *\n * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n *\n * #### Example:\n *\n *     // include a and b, exclude c\n *     query.select('a b -c');\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({a: 1, b: 1, c: 0});\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */ Query.prototype.select = function select() {\n    let arg = arguments[0];\n    if (!arg) return this;\n    if (arguments.length !== 1) {\n        throw new Error(\"Invalid select: select only takes 1 argument\");\n    }\n    this._validate(\"select\");\n    const fields = this._fields || (this._fields = {});\n    const type = typeof arg;\n    let i, len;\n    if ((\"string\" == type || utils.isArgumentsObject(arg)) && \"number\" == typeof arg.length || Array.isArray(arg)) {\n        if (\"string\" == type) arg = arg.split(/\\s+/);\n        for(i = 0, len = arg.length; i < len; ++i){\n            let field = arg[i];\n            if (!field) continue;\n            const include = \"-\" == field[0] ? 0 : 1;\n            if (include === 0) field = field.substring(1);\n            fields[field] = include;\n        }\n        return this;\n    }\n    if (utils.isObject(arg)) {\n        const keys = utils.keys(arg);\n        for(i = 0; i < keys.length; ++i){\n            fields[keys[i]] = arg[keys[i]];\n        }\n        return this;\n    }\n    throw new TypeError(\"Invalid select() argument. Must be string or object.\");\n};\n/**\n * Specifies a $slice condition for a `path`\n *\n * #### Example:\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @param {String} [path]\n * @param {Number} val number/range of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @api public\n */ Query.prototype.slice = function() {\n    if (0 === arguments.length) return this;\n    this._validate(\"slice\");\n    let path, val;\n    if (1 === arguments.length) {\n        const arg = arguments[0];\n        if (typeof arg === \"object\" && !Array.isArray(arg)) {\n            const keys = Object.keys(arg);\n            const numKeys = keys.length;\n            for(let i = 0; i < numKeys; ++i){\n                this.slice(keys[i], arg[keys[i]]);\n            }\n            return this;\n        }\n        this._ensurePath(\"slice\");\n        path = this._path;\n        val = arguments[0];\n    } else if (2 === arguments.length) {\n        if (\"number\" === typeof arguments[0]) {\n            this._ensurePath(\"slice\");\n            path = this._path;\n            val = [\n                arguments[0],\n                arguments[1]\n            ];\n        } else {\n            path = arguments[0];\n            val = arguments[1];\n        }\n    } else if (3 === arguments.length) {\n        path = arguments[0];\n        val = [\n            arguments[1],\n            arguments[2]\n        ];\n    }\n    const myFields = this._fields || (this._fields = {});\n    myFields[path] = {\n        $slice: val\n    };\n    return this;\n};\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     query.sort({ field: 'asc', test: -1 });\n *     query.sort('field -test');\n *     query.sort([['field', 1], ['test', -1]]);\n *\n * #### Note:\n *\n *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).\n *  - Cannot be used with `distinct()`\n *\n * @param {Object|String|Array} arg\n * @return {Query} this\n * @api public\n */ Query.prototype.sort = function(arg) {\n    if (!arg) return this;\n    let i, len, field;\n    this._validate(\"sort\");\n    const type = typeof arg;\n    // .sort([['field', 1], ['test', -1]])\n    if (Array.isArray(arg)) {\n        len = arg.length;\n        for(i = 0; i < arg.length; ++i){\n            if (!Array.isArray(arg[i])) {\n                throw new Error(\"Invalid sort() argument, must be array of arrays\");\n            }\n            _pushArr(this.options, arg[i][0], arg[i][1]);\n        }\n        return this;\n    }\n    // .sort('field -test')\n    if (1 === arguments.length && \"string\" == type) {\n        arg = arg.split(/\\s+/);\n        len = arg.length;\n        for(i = 0; i < len; ++i){\n            field = arg[i];\n            if (!field) continue;\n            const ascend = \"-\" == field[0] ? -1 : 1;\n            if (ascend === -1) field = field.substring(1);\n            push(this.options, field, ascend);\n        }\n        return this;\n    }\n    // .sort({ field: 1, test: -1 })\n    if (utils.isObject(arg)) {\n        const keys = utils.keys(arg);\n        for(i = 0; i < keys.length; ++i){\n            field = keys[i];\n            push(this.options, field, arg[field]);\n        }\n        return this;\n    }\n    if (typeof Map !== \"undefined\" && arg instanceof Map) {\n        _pushMap(this.options, arg);\n        return this;\n    }\n    throw new TypeError(\"Invalid sort() argument. Must be a string, object, or array.\");\n};\n/*!\n * @ignore\n */ const _validSortValue = {\n    1: 1,\n    \"-1\": -1,\n    asc: 1,\n    ascending: 1,\n    desc: -1,\n    descending: -1\n};\nfunction push(opts, field, value) {\n    if (Array.isArray(opts.sort)) {\n        throw new TypeError(\"Can't mix sort syntaxes. Use either array or object:\" + \"\\n- `.sort([['field', 1], ['test', -1]])`\" + \"\\n- `.sort({ field: 1, test: -1 })`\");\n    }\n    let s;\n    if (value && value.$meta) {\n        s = opts.sort || (opts.sort = {});\n        s[field] = {\n            $meta: value.$meta\n        };\n        return;\n    }\n    s = opts.sort || (opts.sort = {});\n    let val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError(\"Invalid sort value: { \" + field + \": \" + value + \" }\");\n    s[field] = val;\n}\nfunction _pushArr(opts, field, value) {\n    opts.sort = opts.sort || [];\n    if (!Array.isArray(opts.sort)) {\n        throw new TypeError(\"Can't mix sort syntaxes. Use either array or object:\" + \"\\n- `.sort([['field', 1], ['test', -1]])`\" + \"\\n- `.sort({ field: 1, test: -1 })`\");\n    }\n    let val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError(\"Invalid sort value: [ \" + field + \", \" + value + \" ]\");\n    opts.sort.push([\n        field,\n        val\n    ]);\n}\nfunction _pushMap(opts, map) {\n    opts.sort = opts.sort || new Map();\n    if (!(opts.sort instanceof Map)) {\n        throw new TypeError(\"Can't mix sort syntaxes. Use either array or \" + \"object or map consistently\");\n    }\n    map.forEach(function(value, key) {\n        let val = String(value || 1).toLowerCase();\n        val = _validSortValue[val];\n        if (!val) throw new TypeError(\"Invalid sort value: < \" + key + \": \" + value + \" >\");\n        opts.sort.set(key, val);\n    });\n}\n/**\n * Specifies the limit option.\n *\n * #### Example:\n *\n *     query.limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D\n * @api public\n */ /**\n * Specifies the skip option.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D\n * @api public\n */ /**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D\n * @api public\n */ /**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment\n * @api public\n */ /*!\n * limit, skip, batchSize, comment\n *\n * Sets these associated options.\n *\n *     query.comment('feed query');\n */ [\n    \"limit\",\n    \"skip\",\n    \"batchSize\",\n    \"comment\"\n].forEach(function(method) {\n    Query.prototype[method] = function(v) {\n        this._validate(method);\n        this.options[method] = v;\n        return this;\n    };\n});\n/**\n * Specifies the maxTimeMS option.\n *\n * #### Example:\n *\n *     query.maxTime(100)\n *     query.maxTimeMS(100)\n *\n * @method maxTime\n * @memberOf Query\n * @param {Number} ms\n * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS\n * @api public\n */ Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {\n    this._validate(\"maxTime\");\n    this.options.maxTimeMS = ms;\n    return this;\n};\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1});\n *     query.hint('indexA_1_indexB_1');\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|string} val a hint object or the index name\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint\n * @api public\n */ Query.prototype.hint = function() {\n    if (0 === arguments.length) return this;\n    this._validate(\"hint\");\n    const arg = arguments[0];\n    if (utils.isObject(arg)) {\n        const hint = this.options.hint || (this.options.hint = {});\n        // must keep object keys in order so don't use Object.keys()\n        for(const k in arg){\n            hint[k] = arg[k];\n        }\n        return this;\n    }\n    if (typeof arg === \"string\") {\n        this.options.hint = arg;\n        return this;\n    }\n    throw new TypeError(\"Invalid hint. \" + arg);\n};\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `j` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */ Query.prototype.j = function j(val) {\n    this.options.j = val;\n    return this;\n};\n/**\n * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.\n *\n * #### Example:\n *\n *     query.slaveOk() // true\n *     query.slaveOk(true)\n *     query.slaveOk(false)\n *\n * @deprecated use read() preferences instead if on mongodb >= 2.2\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see read()\n * @return {Query} this\n * @api public\n */ Query.prototype.slaveOk = function(v) {\n    this.options.slaveOk = arguments.length ? !!v : true;\n    return this;\n};\n/**\n * Sets the readPreference option for the query.\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // you can also use mongodb.ReadPreference class to also specify tags\n *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))\n *\n *     new Query().setReadPreference('primary') // alias of .read()\n *\n * #### Preferences:\n *\n *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */ Query.prototype.read = Query.prototype.setReadPreference = function(pref) {\n    if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {\n        console.error(\"Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.\");\n        Query.prototype.read.deprecationWarningIssued = true;\n    }\n    this.options.readPreference = utils.readPref(pref);\n    return this;\n};\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *     new Query().r('s') // r is alias of readConcern\n *\n *\n * #### Read Concern Level:\n *\n *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n *\n * Aliases\n *\n *     l   local\n *     a   available\n *     m   majority\n *     lz  linearizable\n *     s   snapshot\n *\n * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */ Query.prototype.readConcern = Query.prototype.r = function(level) {\n    this.options.readConcern = utils.readConcern(level);\n    return this;\n};\n/**\n * Sets tailable option.\n *\n * #### Example:\n *\n *     query.tailable() <== true\n *     query.tailable(true)\n *     query.tailable(false)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} v defaults to true\n * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors\n * @api public\n */ Query.prototype.tailable = function() {\n    this._validate(\"tailable\");\n    this.options.tailable = arguments.length ? !!arguments[0] : true;\n    return this;\n};\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `w` value if it is specified in writeConcern options\n *\n * #### Example:\n *\n *     mquery().writeConcern(0)\n *     mquery().writeConcern(1)\n *     mquery().writeConcern({ w: 1, j: true, wtimeout: 2000 })\n *     mquery().writeConcern('majority')\n *     mquery().writeConcern('m') // same as majority\n *     mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern({ w: 'm' }) instead\n *     mquery().w(1) // w is alias of writeConcern\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {String|number|object} concern 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */ Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {\n    if (\"object\" === typeof concern) {\n        if (\"undefined\" !== typeof concern.j) this.options.j = concern.j;\n        if (\"undefined\" !== typeof concern.w) this.options.w = concern.w;\n        if (\"undefined\" !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;\n    } else {\n        this.options.w = \"m\" === concern ? \"majority\" : concern;\n    }\n    return this;\n};\n/**\n * Specifies a time limit, in milliseconds, for the write concern.\n * If `ms > 1`, it is maximum amount of time to wait for this write\n * to propagate through the replica set before this operation fails.\n * The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to `wtimeout` value if it is specified in writeConcern\n *\n * #### Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000)\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */ Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {\n    this.options.wtimeout = ms;\n    return this;\n};\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */ Query.prototype.merge = function(source) {\n    if (!source) return this;\n    if (!Query.canMerge(source)) throw new TypeError(\"Invalid argument. Expected instanceof mquery or plain object\");\n    if (source instanceof Query) {\n        // if source has a feature, apply it to ourselves\n        if (source._conditions) {\n            utils.merge(this._conditions, source._conditions);\n        }\n        if (source._fields) {\n            this._fields || (this._fields = {});\n            utils.merge(this._fields, source._fields);\n        }\n        if (source.options) {\n            this.options || (this.options = {});\n            utils.merge(this.options, source.options);\n        }\n        if (source._updateDoc) {\n            this._updateDoc || (this._updateDoc = {});\n            utils.mergeClone(this._updateDoc, source._updateDoc);\n        }\n        if (source._distinctDoc) {\n            this._distinctDoc = source._distinctDoc;\n        }\n        return this;\n    }\n    // plain object\n    utils.merge(this._conditions, source);\n    return this;\n};\n/**\n * Finds documents.\n *\n * #### Example:\n *\n *     query.find()\n *     await query.find()\n *     await query.find({ name: 'Burning Lights' })\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.find = function(criteria) {\n    this.op = \"find\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `find` Query\n * @returns the result\n */ Query.prototype._find = async function _find() {\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"_find\", this._collection.collectionName, conds, options);\n    return this._collection.find(conds, options);\n};\n/**\n * Returns the query cursor\n *\n * #### Examples:\n *\n *     query.find().cursor();\n *     query.cursor({ name: 'Burning Lights' });\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Object} cursor\n * @api public\n */ Query.prototype.cursor = function cursor(criteria) {\n    if (this.op) {\n        if (this.op !== \"find\") {\n            throw new TypeError(\".cursor only support .find method\");\n        }\n    } else {\n        this.find(criteria);\n    }\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"findCursor\", this._collection.collectionName, conds, options);\n    return this._collection.findCursor(conds, options);\n};\n/**\n * Executes the query as a findOne() operation.\n *\n * #### Example:\n *\n *     query.findOne().where('name', /^Burning/);\n *\n *     query.findOne({ name: /^Burning/ })\n *\n *     await query.findOne({ name: /^Burning/ }); // executes\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.findOne = function(criteria) {\n    this.op = \"findOne\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `findOne` Query\n * @returns the results\n */ Query.prototype._findOne = async function _findOne() {\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"findOne\", this._collection.collectionName, conds, options);\n    return this._collection.findOne(conds, options);\n};\n/**\n * Exectues the query as a count() operation.\n *\n * #### Example:\n *\n *     query.count().where('color', 'black').exec();\n *\n *     query.count({ color: 'black' })\n *\n *     await query.count({ color: 'black' });\n *\n *     const doc = await query.where('color', 'black').count();\n *     console.log('there are %d kittens', count);\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count\n * @api public\n */ Query.prototype.count = function(criteria) {\n    this.op = \"count\";\n    this._validate();\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `count` Query\n * @returns the results\n */ Query.prototype._count = async function _count() {\n    const conds = this._conditions, options = this._optionsForExec();\n    debug(\"count\", this._collection.collectionName, conds, options);\n    return this._collection.count(conds, options);\n};\n/**\n * Declares or executes a distinct() operation.\n *\n * #### Example:\n *\n *     await distinct(criteria, field)\n *     distinct(criteria, field)\n *     await distinct(field)\n *     distinct(field)\n *     await distinct()\n *     distinct()\n *\n * @param {Object|Query} [criteria]\n * @param {String} [field]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct\n * @api public\n */ Query.prototype.distinct = function(criteria, field) {\n    this.op = \"distinct\";\n    this._validate();\n    if (!field && typeof criteria === \"string\") {\n        field = criteria;\n        criteria = undefined;\n    }\n    if (\"string\" == typeof field) {\n        this._distinctDoc = field;\n    }\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `distinct` Query\n * @returns the results\n */ Query.prototype._distinct = async function _distinct() {\n    if (!this._distinctDoc) {\n        throw new Error(\"No value for `distinct` has been declared\");\n    }\n    const conds = this._conditions, options = this._optionsForExec();\n    debug(\"distinct\", this._collection.collectionName, conds, options);\n    return this._collection.distinct(this._distinctDoc, conds, options);\n};\n/**\n * Declare and/or execute this query as an `updateMany()` operation. This function will update _all_ documents that match\n * `criteria`, rather than just the first one.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update every document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */ Query.prototype.updateMany = function updateMany(criteria, doc, options) {\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    return _update(this, \"updateMany\", criteria, doc, options);\n};\n/**\n * Executes a `updateMany` Query\n * @returns the results\n */ Query.prototype._updateMany = async function() {\n    return _updateExec(this, \"updateMany\");\n};\n/**\n * Declare and/or execute this query as an `updateOne()` operation. This function will _always_ update just one document,\n * regardless of the `multi` option.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * #### Example:\n *\n *     // Update the first document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */ Query.prototype.updateOne = function updateOne(criteria, doc, options) {\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    return _update(this, \"updateOne\", criteria, doc, options);\n};\n/**\n * Executes a `updateOne` Query\n * @returns the results\n */ Query.prototype._updateOne = async function() {\n    return _updateExec(this, \"updateOne\");\n};\n/**\n * Declare and/or execute this query as an `replaceOne()` operation. Similar\n * to `updateOne()`, except `replaceOne()` is not allowed to use atomic\n * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always\n * replace the existing doc.\n *\n * #### Example:\n *\n *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 }`\n *     mquery().replaceOne({ _id: 1 }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @return {Query} this\n * @api public\n */ Query.prototype.replaceOne = function replaceOne(criteria, doc, options) {\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    this.setOptions({\n        overwrite: true\n    });\n    return _update(this, \"replaceOne\", criteria, doc, options);\n};\n/**\n * Executes a `replaceOne` Query\n * @returns the results\n */ Query.prototype._replaceOne = async function() {\n    return _updateExec(this, \"replaceOne\");\n};\n/*!\n * Internal helper for updateMany, updateOne\n */ function _update(query, op, criteria, doc, options) {\n    query.op = op;\n    if (Query.canMerge(criteria)) {\n        query.merge(criteria);\n    }\n    if (doc) {\n        query._mergeUpdate(doc);\n    }\n    if (utils.isObject(options)) {\n        // { overwrite: true }\n        query.setOptions(options);\n    }\n    return query;\n}\n/**\n * Helper for de-duplicating \"update*\" functions\n * @param {Query} query The Query Object (replacement for \"this\")\n * @param {String} op The Operation to be done\n * @returns the results\n */ async function _updateExec(query, op) {\n    const options = query._optionsForExec();\n    const criteria = query._conditions;\n    const doc = query._updateForExec();\n    debug(\"update\", query._collection.collectionName, criteria, doc, options);\n    return query._collection[op](criteria, doc, options);\n}\n/**\n * Declare and/or execute this query as a `deleteOne()` operation.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteOne({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.deleteOne = function(criteria) {\n    this.op = \"deleteOne\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `deleteOne` Query\n * @returns the results\n */ Query.prototype._deleteOne = async function() {\n    const options = this._optionsForExec();\n    delete options.justOne;\n    const conds = this._conditions;\n    debug(\"deleteOne\", this._collection.collectionName, conds, options);\n    return this._collection.deleteOne(conds, options);\n};\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Always deletes\n * _every_ document that matches `criteria`.\n *\n * #### Example:\n *\n *     await mquery(collection).deleteMany({ artist: 'Anne Murray' })\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @return {Query} this\n * @api public\n */ Query.prototype.deleteMany = function(criteria) {\n    this.op = \"deleteMany\";\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    return this;\n};\n/**\n * Executes a `deleteMany` Query\n * @returns the results\n */ Query.prototype._deleteMany = async function() {\n    const options = this._optionsForExec();\n    delete options.justOne;\n    const conds = this._conditions;\n    debug(\"deleteOne\", this._collection.collectionName, conds, options);\n    return this._collection.deleteMany(conds, options);\n};\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).\n *\n * #### Available options\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await query.findOneAndUpdate(conditions, update, options) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     await query.findOneAndUpdate(conditions, update) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     await query.findOneAndUpdate(update)             // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     await query.findOneAndUpdate()                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @param {Object|Query} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @return {Query} this\n * @api public\n */ Query.prototype.findOneAndUpdate = function(criteria, doc, options) {\n    this.op = \"findOneAndUpdate\";\n    this._validate();\n    if (arguments.length === 1) {\n        doc = criteria;\n        criteria = options = undefined;\n    }\n    if (Query.canMerge(criteria)) {\n        this.merge(criteria);\n    }\n    // apply doc\n    if (doc) {\n        this._mergeUpdate(doc);\n    }\n    options && this.setOptions(options);\n    return this;\n};\n/**\n * Executes a `findOneAndUpdate` Query\n * @returns the results\n */ Query.prototype._findOneAndUpdate = async function() {\n    const conds = this._conditions;\n    const update = this._updateForExec();\n    const options = this._optionsForExec();\n    return this._collection.findOneAndUpdate(conds, update, options);\n};\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, returning the found document (if any).\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * #### Examples:\n *\n *     await A.where().findOneAndRemove(conditions, options) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     await A.where().findOneAndRemove(conditions) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     await A.where().findOneAndRemove()   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *     A.where().findOneAndDelete()           // alias of .findOneAndRemove()\n *\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */ Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options) {\n    this.op = \"findOneAndRemove\";\n    this._validate();\n    // apply conditions\n    if (Query.canMerge(conditions)) {\n        this.merge(conditions);\n    }\n    // apply options\n    options && this.setOptions(options);\n    return this;\n};\n/**\n * Executes a `findOneAndRemove` Query\n * @returns the results\n */ Query.prototype._findOneAndRemove = async function() {\n    const options = this._optionsForExec();\n    const conds = this._conditions;\n    return this._collection.findOneAndDelete(conds, options);\n};\n/**\n * Add trace function that gets called when the query is executed.\n * The function will be called with (method, queryInfo, query) and\n * should return a callback function which will be called\n * with (err, result, millis) when the query is complete.\n *\n * queryInfo is an object containing: {\n *   collectionName: <name of the collection>,\n *   conditions: <query criteria>,\n *   options: <comment, fields, readPreference, etc>,\n *   doc: [document to update, if applicable]\n * }\n *\n * NOTE: Does not trace stream queries.\n *\n * @param {Function} traceFunction\n * @return {Query} this\n * @api public\n */ Query.prototype.setTraceFunction = function(traceFunction) {\n    this._traceFunction = traceFunction;\n    return this;\n};\n/**\n * Executes the query\n *\n * #### Examples:\n *\n *     query.exec();\n *     await query.exec();\n *     query.exec('update');\n *     await query.exec('find');\n *\n * @param {String|Function} [operation]\n * @api public\n */ Query.prototype.exec = async function exec(op) {\n    if (typeof op === \"string\") {\n        this.op = op;\n    }\n    assert.ok(this.op, \"Missing query type: (find, etc)\");\n    const fnName = \"_\" + this.op;\n    // better error, because default would list it as \"this[fnName] is not a function\"\n    if (typeof this[fnName] !== \"function\") {\n        throw new TypeError(`this[${fnName}] is not a function`);\n    }\n    return this[fnName]();\n};\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */ Query.prototype.then = async function(res, rej) {\n    return this.exec().then(res, rej);\n};\n/**\n * Returns a cursor for the given `find` query.\n *\n * @throws Error if operation is not a find\n * @returns {Cursor} MongoDB driver cursor\n */ Query.prototype.cursor = function() {\n    if (\"find\" != this.op) throw new Error(\"cursor() is only available for find\");\n    const conds = this._conditions;\n    const options = this._optionsForExec();\n    if (this.$useProjection) {\n        options.projection = this._fieldsForExec();\n    } else {\n        options.fields = this._fieldsForExec();\n    }\n    debug(\"cursor\", this._collection.collectionName, conds, options);\n    return this._collection.findCursor(conds, options);\n};\n/**\n * Determines if field selection has been made.\n *\n * @return {Boolean}\n * @api public\n */ Query.prototype.selected = function selected() {\n    return !!(this._fields && Object.keys(this._fields).length > 0);\n};\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively() // false\n *     query.select('name')\n *     query.selectedInclusively() // true\n *     query.selectedExlusively() // false\n *\n * @returns {Boolean}\n */ Query.prototype.selectedInclusively = function selectedInclusively() {\n    if (!this._fields) return false;\n    const keys = Object.keys(this._fields);\n    if (0 === keys.length) return false;\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (0 === this._fields[key]) return false;\n        if (this._fields[key] && typeof this._fields[key] === \"object\" && this._fields[key].$meta) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExlusively() // false\n *     query.select('-name')\n *     query.selectedExlusively() // true\n *     query.selectedInclusively() // false\n *\n * @returns {Boolean}\n */ Query.prototype.selectedExclusively = function selectedExclusively() {\n    if (!this._fields) return false;\n    const keys = Object.keys(this._fields);\n    if (0 === keys.length) return false;\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (0 === this._fields[key]) return true;\n    }\n    return false;\n};\n/**\n * Merges `doc` with the current update object.\n *\n * @param {Object} doc\n */ Query.prototype._mergeUpdate = function(doc) {\n    if (!this._updateDoc) this._updateDoc = {};\n    if (doc instanceof Query) {\n        if (doc._updateDoc) {\n            utils.mergeClone(this._updateDoc, doc._updateDoc);\n        }\n    } else {\n        utils.mergeClone(this._updateDoc, doc);\n    }\n};\n/**\n * Returns default options.\n *\n * @return {Object}\n * @api private\n */ Query.prototype._optionsForExec = function() {\n    const options = utils.clone(this.options);\n    return options;\n};\n/**\n * Returns fields selection for this query.\n *\n * @return {Object}\n * @api private\n */ Query.prototype._fieldsForExec = function() {\n    return utils.clone(this._fields);\n};\n/**\n * Return an update document with corrected $set operations.\n *\n * @api private\n */ Query.prototype._updateForExec = function() {\n    const update = utils.clone(this._updateDoc);\n    const ops = utils.keys(update);\n    const ret = {};\n    for (const op of ops){\n        if (this.options.overwrite) {\n            ret[op] = update[op];\n            continue;\n        }\n        if (\"$\" !== op[0]) {\n            // fix up $set sugar\n            if (!ret.$set) {\n                if (update.$set) {\n                    ret.$set = update.$set;\n                } else {\n                    ret.$set = {};\n                }\n            }\n            ret.$set[op] = update[op];\n            if (!~ops.indexOf(\"$set\")) ops.push(\"$set\");\n        } else if (\"$set\" === op) {\n            if (!ret.$set) {\n                ret[op] = update[op];\n            }\n        } else {\n            ret[op] = update[op];\n        }\n    }\n    this._compiledUpdate = ret;\n    return ret;\n};\n/**\n * Make sure _path is set.\n *\n * @parmam {String} method\n */ Query.prototype._ensurePath = function(method) {\n    if (!this._path) {\n        const msg = method + \"() must be used after where() \" + \"when called with these arguments\";\n        throw new Error(msg);\n    }\n};\n/*!\n * Permissions\n */ Query.permissions = __webpack_require__(/*! ./permissions */ \"(ssr)/./node_modules/mquery/lib/permissions.js\");\nQuery._isPermitted = function(a, b) {\n    const denied = Query.permissions[b];\n    if (!denied) return true;\n    return true !== denied[a];\n};\nQuery.prototype._validate = function(action) {\n    let fail;\n    let validator;\n    if (undefined === action) {\n        validator = Query.permissions[this.op];\n        if (\"function\" != typeof validator) return true;\n        fail = validator(this);\n    } else if (!Query._isPermitted(action, this.op)) {\n        fail = action;\n    }\n    if (fail) {\n        throw new Error(fail + \" cannot be used with \" + this.op);\n    }\n};\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @param {Object} conds\n * @return {Boolean}\n */ Query.canMerge = function(conds) {\n    return conds instanceof Query || utils.isObject(conds);\n};\n/**\n * Set a trace function that will get called whenever a\n * query is executed.\n *\n * See `setTraceFunction()` for details.\n *\n * @param {Object} conds\n * @return {Boolean}\n */ Query.setGlobalTraceFunction = function(traceFunction) {\n    Query.traceFunction = traceFunction;\n};\n/*!\n * Exports.\n */ Query.utils = utils;\nQuery.env = __webpack_require__(/*! ./env */ \"(ssr)/./node_modules/mquery/lib/env.js\");\nQuery.Collection = __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mquery/lib/collection/index.js\");\nQuery.BaseCollection = __webpack_require__(/*! ./collection/collection */ \"(ssr)/./node_modules/mquery/lib/collection/collection.js\");\nmodule.exports = exports = Query; // TODO\n // test utils\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9tcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Q0FFQyxHQUVELE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1HLFFBQVFILG1CQUFPQSxDQUFDLHdEQUFTO0FBRS9COzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVELFNBQVNJLE1BQU1DLFFBQVEsRUFBRUMsT0FBTztJQUM5QixJQUFJLENBQUUsS0FBSSxZQUFZRixLQUFJLEdBQ3hCLE9BQU8sSUFBSUEsTUFBTUMsVUFBVUM7SUFFN0IsTUFBTUMsUUFBUSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsU0FBUztJQUV4QyxJQUFJLENBQUNDLEVBQUUsR0FBR0gsTUFBTUcsRUFBRSxJQUFJQztJQUV0QixJQUFJLENBQUNMLE9BQU8sR0FBR00sT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR04sTUFBTUQsT0FBTztJQUU5QyxJQUFJLENBQUNRLFdBQVcsR0FBR1AsTUFBTU8sV0FBVyxHQUNoQ1osTUFBTWEsS0FBSyxDQUFDUixNQUFNTyxXQUFXLElBQzdCLENBQUM7SUFFTCxJQUFJLENBQUNFLE9BQU8sR0FBR1QsTUFBTVMsT0FBTyxHQUN4QmQsTUFBTWEsS0FBSyxDQUFDUixNQUFNUyxPQUFPLElBQ3pCTDtJQUVKLElBQUksQ0FBQ00sVUFBVSxHQUFHVixNQUFNVSxVQUFVLEdBQzlCZixNQUFNYSxLQUFLLENBQUNSLE1BQU1VLFVBQVUsSUFDNUJOO0lBRUosSUFBSSxDQUFDTyxLQUFLLEdBQUdYLE1BQU1XLEtBQUssSUFBSVA7SUFDNUIsSUFBSSxDQUFDUSxZQUFZLEdBQUdaLE1BQU1ZLFlBQVksSUFBSVI7SUFDMUMsSUFBSSxDQUFDUyxXQUFXLEdBQUdiLE1BQU1hLFdBQVcsSUFBSVQ7SUFDeEMsSUFBSSxDQUFDVSxjQUFjLEdBQUdkLE1BQU1j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MEMsVUFBVSxHQUFHOUMsbUJBQU9BLENBQUM7QUFDM0JJLE1BQU1rTyxjQUFjLEdBQUd0TyxtQkFBT0EsQ0FBQztBQUMvQnVPLE9BQU9DLE9BQU8sR0FBR0EsVUFBVXBPLE9BRTNCLE9BQU87Q0FDUCxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmxvZy1hcHBsaWNhdGlvbi8uL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL21xdWVyeS5qcz83YjU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbXF1ZXJ5Jyk7XG5cbi8qKlxuICogUXVlcnkgY29uc3RydWN0b3IgdXNlZCBmb3IgYnVpbGRpbmcgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh7IG5hbWU6ICdtcXVlcnknIH0pO1xuICogICAgIHF1ZXJ5LnNldE9wdGlvbnMoeyBjb2xsZWN0aW9uOiBtb2R1bGVDb2xsZWN0aW9uIH0pXG4gKiAgICAgYXdhaXQgcXVlcnkud2hlcmUoJ2FnZScpLmd0ZSgyMSkuZXhlYygpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdIGNyaXRlcmlhIGZvciB0aGUgcXVlcnkgT1IgdGhlIGNvbGxlY3Rpb24gaW5zdGFuY2UgdG8gdXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBRdWVyeSkpXG4gICAgcmV0dXJuIG5ldyBRdWVyeShjcml0ZXJpYSwgb3B0aW9ucyk7XG5cbiAgY29uc3QgcHJvdG8gPSB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICB0aGlzLm9wID0gcHJvdG8ub3AgfHwgdW5kZWZpbmVkO1xuXG4gIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3RvLm9wdGlvbnMpO1xuXG4gIHRoaXMuX2NvbmRpdGlvbnMgPSBwcm90by5fY29uZGl0aW9uc1xuICAgID8gdXRpbHMuY2xvbmUocHJvdG8uX2NvbmRpdGlvbnMpXG4gICAgOiB7fTtcblxuICB0aGlzLl9maWVsZHMgPSBwcm90by5fZmllbGRzXG4gICAgPyB1dGlscy5jbG9uZShwcm90by5fZmllbGRzKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHRoaXMuX3VwZGF0ZURvYyA9IHByb3RvLl91cGRhdGVEb2NcbiAgICA/IHV0aWxzLmNsb25lKHByb3RvLl91cGRhdGVEb2MpXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdGhpcy5fcGF0aCA9IHByb3RvLl9wYXRoIHx8IHVuZGVmaW5lZDtcbiAgdGhpcy5fZGlzdGluY3REb2MgPSBwcm90by5fZGlzdGluY3REb2MgfHwgdW5kZWZpbmVkO1xuICB0aGlzLl9jb2xsZWN0aW9uID0gcHJvdG8uX2NvbGxlY3Rpb24gfHwgdW5kZWZpbmVkO1xuICB0aGlzLl90cmFjZUZ1bmN0aW9uID0gcHJvdG8uX3RyYWNlRnVuY3Rpb24gfHwgdW5kZWZpbmVkO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGNyaXRlcmlhKSB7XG4gICAgdGhpcy5maW5kKGNyaXRlcmlhKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBwYXJhbWV0ZXIgdGhhdCB0aGUgdXNlciBjYW4gc2V0IHdoaWNoIGRldGVybWluZXMgaWYgbXF1ZXJ5XG4gKiB1c2VzICR3aXRoaW4gb3IgJGdlb1dpdGhpbiBmb3IgcXVlcmllcy4gSXQgZGVmYXVsdHMgdG8gdHJ1ZSB3aGljaFxuICogbWVhbnMgJGdlb1dpdGhpbiB3aWxsIGJlIHVzZWQuIElmIHVzaW5nIE1vbmdvREIgPCAyLjQgeW91IHNob3VsZFxuICogc2V0IHRoaXMgdG8gZmFsc2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB1c2UkZ2VvV2l0aGluXG4gKi9cblxubGV0ICR3aXRoaW5DbWQgPSAnJGdlb1dpdGhpbic7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnksICd1c2UkZ2VvV2l0aGluJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJHdpdGhpbkNtZCA9PSAnJGdlb1dpdGhpbic7IH0sXG4gIHNldDogZnVuY3Rpb24odikge1xuICAgIGlmICh0cnVlID09PSB2KSB7XG4gICAgICAvLyBtb25nb2RiID49IDIuNFxuICAgICAgJHdpdGhpbkNtZCA9ICckZ2VvV2l0aGluJztcbiAgICB9IGVsc2Uge1xuICAgICAgJHdpdGhpbkNtZCA9ICckd2l0aGluJztcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgcXVlcnkgdG8gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aXRoIGFsbCBhcmd1bWVudHMgYW5kIG9wdGlvbnMgcmV0YWluZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBDcmVhdGUgYSBxdWVyeSB0aGF0IHdpbGwgcmVhZCBkb2N1bWVudHMgd2l0aCBhIFwidmlkZW9cIiBjYXRlZ29yeSBmcm9tXG4gKiAgICAgLy8gYGFDb2xsZWN0aW9uYCBvbiB0aGUgcHJpbWFyeSBub2RlIGluIHRoZSByZXBsaWNhLXNldCB1bmxlc3MgaXQgaXMgZG93bixcbiAqICAgICAvLyBpbiB3aGljaCBjYXNlIHdlJ2xsIHJlYWQgZnJvbSBhIHNlY29uZGFyeSBub2RlLlxuICogICAgIHZhciBxdWVyeSA9IG1xdWVyeSh7IGNhdGVnb3J5OiAndmlkZW8nIH0pXG4gKiAgICAgcXVlcnkuc2V0T3B0aW9ucyh7IGNvbGxlY3Rpb246IGFDb2xsZWN0aW9uLCByZWFkOiAncHJpbWFyeVByZWZlcnJlZCcgfSk7XG4gKlxuICogICAgIC8vIGNyZWF0ZSBhIGNvbnN0cnVjdG9yIGJhc2VkIG9mZiB0aGVzZSBzZXR0aW5nc1xuICogICAgIHZhciBWaWRlbyA9IHF1ZXJ5LnRvQ29uc3RydWN0b3IoKTtcbiAqXG4gKiAgICAgLy8gVmlkZW8gaXMgbm93IGEgc3ViY2xhc3Mgb2YgbXF1ZXJ5KCkgYW5kIHdvcmtzIHRoZSBzYW1lIHdheSBidXQgd2l0aCB0aGVcbiAqICAgICAvLyBkZWZhdWx0IHF1ZXJ5IHBhcmFtZXRlcnMgYW5kIG9wdGlvbnMgc2V0LlxuICpcbiAqICAgICAvLyBydW4gYSBxdWVyeSB3aXRoIHRoZSBwcmV2aW91cyBzZXR0aW5ncyBidXQgZmlsdGVyIGZvciBtb3ZpZXMgd2l0aCBuYW1lc1xuICogICAgIC8vIHRoYXQgc3RhcnQgd2l0aCBcIkxpZmVcIi5cbiAqICAgICBWaWRlbygpLndoZXJlKHsgbmFtZTogL15MaWZlLyB9KS5leGVjKGNiKTtcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gbmV3IFF1ZXJ5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50b0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gdG9Db25zdHJ1Y3RvcigpIHtcbiAgZnVuY3Rpb24gQ3VzdG9tUXVlcnkoY3JpdGVyaWEsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tUXVlcnkpKVxuICAgICAgcmV0dXJuIG5ldyBDdXN0b21RdWVyeShjcml0ZXJpYSwgb3B0aW9ucyk7XG4gICAgUXVlcnkuY2FsbCh0aGlzLCBjcml0ZXJpYSwgb3B0aW9ucyk7XG4gIH1cblxuICB1dGlscy5pbmhlcml0cyhDdXN0b21RdWVyeSwgUXVlcnkpO1xuXG4gIC8vIHNldCBpbmhlcml0ZWQgZGVmYXVsdHNcbiAgY29uc3QgcCA9IEN1c3RvbVF1ZXJ5LnByb3RvdHlwZTtcblxuICBwLm9wdGlvbnMgPSB7fTtcbiAgcC5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XG5cbiAgcC5vcCA9IHRoaXMub3A7XG4gIHAuX2NvbmRpdGlvbnMgPSB1dGlscy5jbG9uZSh0aGlzLl9jb25kaXRpb25zKTtcbiAgcC5fZmllbGRzID0gdXRpbHMuY2xvbmUodGhpcy5fZmllbGRzKTtcbiAgcC5fdXBkYXRlRG9jID0gdXRpbHMuY2xvbmUodGhpcy5fdXBkYXRlRG9jKTtcbiAgcC5fcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHAuX2Rpc3RpbmN0RG9jID0gdGhpcy5fZGlzdGluY3REb2M7XG4gIHAuX2NvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICBwLl90cmFjZUZ1bmN0aW9uID0gdGhpcy5fdHJhY2VGdW5jdGlvbjtcblxuICByZXR1cm4gQ3VzdG9tUXVlcnk7XG59O1xuXG4vKipcbiAqIFNldHMgcXVlcnkgb3B0aW9ucy5cbiAqXG4gKiAjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBbdGFpbGFibGVdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL1RhaWxhYmxlK0N1cnNvcnMpICpcbiAqIC0gW3NvcnRdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QnNvcnQoXFwpJTdEJTdEKSAqXG4gKiAtIFtsaW1pdF0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCbGltaXQlMjglMjklN0QlN0QpICpcbiAqIC0gW3NraXBdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QnNraXAlMjglMjklN0QlN0QpICpcbiAqIC0gW21heFRpbWVdKGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWV0YS9tYXhUaW1lTVMvI29wLl9TX21heFRpbWVNUykgKlxuICogLSBbYmF0Y2hTaXplXShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lN0IlN0JiYXRjaFNpemUlMjglMjklN0QlN0QpICpcbiAqIC0gW2NvbW1lbnRdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSUyNGNvbW1lbnQpICpcbiAqIC0gW2hpbnRdKGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSUyNGhpbnQpICpcbiAqIC0gW3NsYXZlT2tdKGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZSkgKlxuICogLSBbc2FmZV0oaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZ2V0TGFzdEVycm9yK0NvbW1hbmQpXG4gKiAtIGNvbGxlY3Rpb24gdGhlIGNvbGxlY3Rpb24gdG8gcXVlcnkgYWdhaW5zdFxuICpcbiAqIF8qIGRlbm90ZXMgYSBxdWVyeSBoZWxwZXIgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAoIShvcHRpb25zICYmIHV0aWxzLmlzT2JqZWN0KG9wdGlvbnMpKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBzZXQgYXJiaXRyYXJ5IG9wdGlvbnNcbiAgY29uc3QgbWV0aG9kcyA9IHV0aWxzLmtleXMob3B0aW9ucyk7XG4gIGxldCBtZXRob2Q7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgKytpKSB7XG4gICAgbWV0aG9kID0gbWV0aG9kc1tpXTtcblxuICAgIC8vIHVzZSBtZXRob2RzIGlmIGV4aXN0IChzYWZlciBvcHRpb24gbWFuaXB1bGF0aW9uKVxuICAgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB0aGlzW21ldGhvZF0pIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnNbbWV0aG9kXSlcbiAgICAgICAgPyBvcHRpb25zW21ldGhvZF1cbiAgICAgICAgOiBbb3B0aW9uc1ttZXRob2RdXTtcbiAgICAgIHRoaXNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zW21ldGhvZF0gPSBvcHRpb25zW21ldGhvZF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhpcyBRdWVyeXMgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb259IGNvbGxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjb2xsZWN0aW9uKGNvbGwpIHtcbiAgdGhpcy5fY29sbGVjdGlvbiA9IG5ldyBRdWVyeS5Db2xsZWN0aW9uKGNvbGwpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgY29sbGF0aW9uIHRvIHRoaXMgb3AgKE1vbmdvREIgMy40IGFuZCB1cClcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmZpbmQoKS5jb2xsYXRpb24oeyBsb2NhbGU6IFwiZW5fVVNcIiwgc3RyZW5ndGg6IDEgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIE1vbmdvREIgZG9jcyBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmNvbGxhdGlvbi8jY3Vyc29yLmNvbGxhdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY29sbGF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5vcHRpb25zLmNvbGxhdGlvbiA9IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCR3aGVyZWAgY29uZGl0aW9uXG4gKlxuICogVXNlIGAkd2hlcmVgIHdoZW4geW91IG5lZWQgdG8gc2VsZWN0IGRvY3VtZW50cyB1c2luZyBhIEphdmFTY3JpcHQgZXhwcmVzc2lvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LiR3aGVyZSgndGhpcy5jb21tZW50cy5sZW5ndGggPiAxMCB8fCB0aGlzLm5hbWUubGVuZ3RoID4gNScpXG4gKlxuICogICAgIHF1ZXJ5LiR3aGVyZShmdW5jdGlvbiAoKSB7XG4gKiAgICAgICByZXR1cm4gdGhpcy5jb21tZW50cy5sZW5ndGggPiAxMCB8fCB0aGlzLm5hbWUubGVuZ3RoID4gNTtcbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBqcyBqYXZhc2NyaXB0IHN0cmluZyBvciBmdW5jdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQG1ldGhvZCAkd2hlcmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLiR3aGVyZSA9IGZ1bmN0aW9uKGpzKSB7XG4gIHRoaXMuX2NvbmRpdGlvbnMuJHdoZXJlID0ganM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgcGF0aGAgZm9yIHVzZSB3aXRoIGNoYWluaW5nLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gaW5zdGVhZCBvZiB3cml0aW5nOlxuICogICAgIGF3YWl0IFVzZXIuZmluZCh7YWdlOiB7JGd0ZTogMjEsICRsdGU6IDY1fX0pO1xuICpcbiAqICAgICAvLyB3ZSBjYW4gaW5zdGVhZCB3cml0ZTpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnKS5ndGUoMjEpLmx0ZSg2NSk7XG4gKlxuICogICAgIC8vIHBhc3NpbmcgcXVlcnkgY29uZGl0aW9ucyBpcyBwZXJtaXR0ZWRcbiAqICAgICBVc2VyLmZpbmQoKS53aGVyZSh7IG5hbWU6ICd2b25kZXJmdWwnIH0pXG4gKlxuICogICAgIC8vIGNoYWluaW5nXG4gKiAgICAgYXdhaXQgVXNlclxuICogICAgICAgLndoZXJlKCdhZ2UnKS5ndGUoMjEpLmx0ZSg2NSlcbiAqICAgICAgIC53aGVyZSgnbmFtZScsIC9edm9uZGVyZnVsL2kpXG4gKiAgICAgICAud2hlcmUoJ2ZyaWVuZHMnKS5zbGljZSgxMClcbiAqICAgICAgIC5leGVjKClcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gW3ZhbF1cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzO1xuICBpZiAoIXRoaXMub3ApIHRoaXMub3AgPSAnZmluZCc7XG5cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmd1bWVudHNbMF07XG5cbiAgaWYgKCdzdHJpbmcnID09IHR5cGUpIHtcbiAgICB0aGlzLl9wYXRoID0gYXJndW1lbnRzWzBdO1xuXG4gICAgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2NvbmRpdGlvbnNbdGhpcy5fcGF0aF0gPSBhcmd1bWVudHNbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoJ29iamVjdCcgPT0gdHlwZSAmJiAhQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2UoYXJndW1lbnRzWzBdKTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdGggbXVzdCBiZSBhIHN0cmluZyBvciBvYmplY3QnKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBjb21wbGVtZW50YXJ5IGNvbXBhcmlzb24gdmFsdWUgZm9yIHBhdGhzIHNwZWNpZmllZCB3aXRoIGB3aGVyZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZXF1YWxzKDQ5KTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJywgNDkpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHModmFsKSB7XG4gIHRoaXMuX2Vuc3VyZVBhdGgoJ2VxdWFscycpO1xuICBjb25zdCBwYXRoID0gdGhpcy5fcGF0aDtcbiAgdGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgY29tcGxlbWVudGFyeSBjb21wYXJpc29uIHZhbHVlIGZvciBwYXRocyBzcGVjaWZpZWQgd2l0aCBgd2hlcmUoKWBcbiAqIFRoaXMgaXMgYWxpYXMgb2YgYGVxdWFsc2BcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScpLmVxKDQ5KTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgVXNlci5zaGVyZSgnYWdlJykuZXF1YWxzKDQ5KTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJywgNDkpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHZhbCkge1xuICB0aGlzLl9lbnN1cmVQYXRoKCdlcScpO1xuICBjb25zdCBwYXRoID0gdGhpcy5fcGF0aDtcbiAgdGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGFuIGAkb3JgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5Lm9yKFt7IGNvbG9yOiAncmVkJyB9LCB7IHN0YXR1czogJ2VtZXJnZW5jeScgfV0pXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IoYXJyYXkpIHtcbiAgY29uc3Qgb3IgPSB0aGlzLl9jb25kaXRpb25zLiRvciB8fCAodGhpcy5fY29uZGl0aW9ucy4kb3IgPSBbXSk7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIGFycmF5ID0gW2FycmF5XTtcbiAgb3IucHVzaC5hcHBseShvciwgYXJyYXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFyZ3VtZW50cyBmb3IgYSBgJG5vcmAgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkubm9yKFt7IGNvbG9yOiAnZ3JlZW4nIH0sIHsgc3RhdHVzOiAnb2snIH1dKVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IGFycmF5IG9mIGNvbmRpdGlvbnNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5ub3IgPSBmdW5jdGlvbiBub3IoYXJyYXkpIHtcbiAgY29uc3Qgbm9yID0gdGhpcy5fY29uZGl0aW9ucy4kbm9yIHx8ICh0aGlzLl9jb25kaXRpb25zLiRub3IgPSBbXSk7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIGFycmF5ID0gW2FycmF5XTtcbiAgbm9yLnB1c2guYXBwbHkobm9yLCBhcnJheSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhIGAkYW5kYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5hbmQoW3sgY29sb3I6ICdncmVlbicgfSwgeyBzdGF0dXM6ICdvaycgfV0pXG4gKlxuICogQHNlZSAkYW5kIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYW5kL1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChhcnJheSkge1xuICBjb25zdCBhbmQgPSB0aGlzLl9jb25kaXRpb25zLiRhbmQgfHwgKHRoaXMuX2NvbmRpdGlvbnMuJGFuZCA9IFtdKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkgYXJyYXkgPSBbYXJyYXldO1xuICBhbmQucHVzaC5hcHBseShhbmQsIGFycmF5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRndCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFRoaW5nLmZpbmQoKS53aGVyZSgnYWdlJykuZ3QoMjEpXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgVGhpbmcuZmluZCgpLmd0KCdhZ2UnLCAyMSlcbiAqXG4gKiBAbWV0aG9kIGd0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkZ3RlIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgZ3RlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkbHQgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGx0ZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGx0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJG5lIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbmVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiAkaW4gcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBpblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuICRuaW4gcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBuaW5cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiAkYWxsIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgYWxsXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSAkc2l6ZSBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIHNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhICRyZWdleCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIHJlZ2V4XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJG1heERpc3RhbmNlIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgbWF4RGlzdGFuY2VcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKiFcbiAqIGd0LCBndGUsIGx0LCBsdGUsIG5lLCBpbiwgbmluLCBhbGwsIHJlZ2V4LCBzaXplLCBtYXhEaXN0YW5jZVxuICpcbiAqICAgICBUaGluZy53aGVyZSgndHlwZScpLm5pbihhcnJheSlcbiAqL1xuXG4nZ3QgZ3RlIGx0IGx0ZSBuZSBpbiBuaW4gYWxsIHJlZ2V4IHNpemUgbWF4RGlzdGFuY2UgbWluRGlzdGFuY2UnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbigkY29uZGl0aW9uYWwpIHtcbiAgUXVlcnkucHJvdG90eXBlWyRjb25kaXRpb25hbF0gPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgcGF0aCwgdmFsO1xuXG4gICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVBhdGgoJGNvbmRpdGlvbmFsKTtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy5fY29uZGl0aW9uc1twYXRoXSA9PT0gJ29iamVjdCcgP1xuICAgICAgdGhpcy5fY29uZGl0aW9uc1twYXRoXSA6XG4gICAgICAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgICBjb25kc1snJCcgKyAkY29uZGl0aW9uYWxdID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRtb2RgIGNvbmRpdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHZhbCwgcGF0aDtcblxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ21vZCcpO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoICYmICFBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSkpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdtb2QnKTtcbiAgICB2YWwgPSBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV1dO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICB9IGVsc2UgaWYgKDMgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB2YWwgPSBbYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl1dO1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYXJndW1lbnRzWzFdO1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzLiRtb2QgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gYCRleGlzdHNgIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8geyBuYW1lOiB7ICRleGlzdHM6IHRydWUgfX1cbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cygpXG4gKiAgICAgVGhpbmcud2hlcmUoJ25hbWUnKS5leGlzdHModHJ1ZSlcbiAqICAgICBUaGluZy5maW5kKCkuZXhpc3RzKCduYW1lJylcbiAqXG4gKiAgICAgLy8geyBuYW1lOiB7ICRleGlzdHM6IGZhbHNlIH19XG4gKiAgICAgVGhpbmcud2hlcmUoJ25hbWUnKS5leGlzdHMoZmFsc2UpO1xuICogICAgIFRoaW5nLmZpbmQoKS5leGlzdHMoJ25hbWUnLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcGF0aCwgdmFsO1xuXG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnZXhpc3RzJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgICAgdGhpcy5fZW5zdXJlUGF0aCgnZXhpc3RzJyk7XG4gICAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhbCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHMuJGV4aXN0cyA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGVsZW1NYXRjaGAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5lbGVtTWF0Y2goJ2NvbW1lbnQnLCB7IGF1dGhvcjogJ2F1dG9ib3QnLCB2b3RlczogeyRndGU6IDV9fSlcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnQnKS5lbGVtTWF0Y2goeyBhdXRob3I6ICdhdXRvYm90Jywgdm90ZXM6IHskZ3RlOiA1fX0pXG4gKlxuICogICAgIHF1ZXJ5LmVsZW1NYXRjaCgnY29tbWVudCcsIGZ1bmN0aW9uIChlbGVtKSB7XG4gKiAgICAgICBlbGVtLndoZXJlKCdhdXRob3InKS5lcXVhbHMoJ2F1dG9ib3QnKTtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ3ZvdGVzJykuZ3RlKDUpO1xuICogICAgIH0pXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50JykuZWxlbU1hdGNoKGZ1bmN0aW9uIChlbGVtKSB7XG4gKiAgICAgICBlbGVtLndoZXJlKHsgYXV0aG9yOiAnYXV0b2JvdCcgfSk7XG4gKiAgICAgICBlbGVtLndoZXJlKCd2b3RlcycpLmd0ZSg1KTtcbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gcGF0aFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGNyaXRlcmlhXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZWxlbU1hdGNoID0gZnVuY3Rpb24oKSB7XG4gIGlmIChudWxsID09IGFyZ3VtZW50c1swXSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG5cbiAgbGV0IGZuLCBwYXRoLCBjcml0ZXJpYTtcblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ2VsZW1NYXRjaCcpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIGZuID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZ3VtZW50c1swXSkpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdlbGVtTWF0Y2gnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICBjcml0ZXJpYSA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJndW1lbnRzWzFdKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBmbiA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMV0gJiYgdXRpbHMuaXNPYmplY3QoYXJndW1lbnRzWzFdKSkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY3JpdGVyaWEgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKGZuKSB7XG4gICAgY3JpdGVyaWEgPSBuZXcgUXVlcnk7XG4gICAgZm4oY3JpdGVyaWEpO1xuICAgIGNyaXRlcmlhID0gY3JpdGVyaWEuX2NvbmRpdGlvbnM7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzLiRlbGVtTWF0Y2ggPSBjcml0ZXJpYTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBTcGF0aWFsIHF1ZXJpZXNcblxuLyoqXG4gKiBTdWdhciBmb3IgZ2VvLXNwYXRpYWwgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndpdGhpbigpLmJveCgpXG4gKiAgICAgcXVlcnkud2l0aGluKCkuY2lyY2xlKClcbiAqICAgICBxdWVyeS53aXRoaW4oKS5nZW9tZXRyeSgpXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBjZW50ZXI6IFs1MCw1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBib3g6IFtbNDAuNzMsIC03My45XSwgWzQwLjcsIC03My45ODhdXSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgcG9seWdvbjogW1tdLFtdLFtdLFtdXSB9KTtcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10sIFtdKSAvLyBwb2x5Z29uXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10pIC8vIGJveFxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyB0eXBlOiAnTGluZVN0cmluZycsIGNvb3JkaW5hdGVzOiBbLi4uXSB9KTsgLy8gZ2VvbWV0cnlcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogTXVzdCBiZSB1c2VkIGFmdGVyIGB3aGVyZSgpYC5cbiAqXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbiB3aXRoaW4oKSB7XG4gIC8vIG9waW5pb25hdGVkLCBtdXN0IGJlIHVzZWQgYWZ0ZXIgd2hlcmVcbiAgdGhpcy5fZW5zdXJlUGF0aCgnd2l0aGluJyk7XG4gIHRoaXMuX2dlb0NvbXBhcmlzb24gPSAkd2l0aGluQ21kO1xuXG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmJveC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IGVsc2UgaWYgKDIgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9seWdvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgY29uc3QgYXJlYSA9IGFyZ3VtZW50c1swXTtcblxuICBpZiAoIWFyZWEpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuXG4gIGlmIChhcmVhLmNlbnRlcilcbiAgICByZXR1cm4gdGhpcy5jaXJjbGUoYXJlYSk7XG5cbiAgaWYgKGFyZWEuYm94KVxuICAgIHJldHVybiB0aGlzLmJveC5hcHBseSh0aGlzLCBhcmVhLmJveCk7XG5cbiAgaWYgKGFyZWEucG9seWdvbilcbiAgICByZXR1cm4gdGhpcy5wb2x5Z29uLmFwcGx5KHRoaXMsIGFyZWEucG9seWdvbik7XG5cbiAgaWYgKGFyZWEudHlwZSAmJiBhcmVhLmNvb3JkaW5hdGVzKVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5KGFyZWEpO1xuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGJveCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHZhciBsb3dlckxlZnQgPSBbNDAuNzMwODMsIC03My45OTc1Nl1cbiAqICAgICB2YXIgdXBwZXJSaWdodD0gWzQwLjc0MTQwNCwgIC03My45ODgxMzVdXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5ib3gobG93ZXJMZWZ0LCB1cHBlclJpZ2h0KVxuICogICAgIHF1ZXJ5LmJveCgnbG9jJywgbG93ZXJMZWZ0LCB1cHBlclJpZ2h0IClcbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBzZWUgUXVlcnkjd2l0aGluICNxdWVyeV9RdWVyeS13aXRoaW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuYm94ID0gZnVuY3Rpb24oKSB7XG4gIGxldCBwYXRoLCBib3g7XG5cbiAgaWYgKDMgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAvLyBib3goJ2xvYycsIFtdLCBbXSlcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGJveCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIC8vIGJveChbXSwgW10pXG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnYm94Jyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgYm94ID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG4gIGNvbmRzW3RoaXMuX2dlb0NvbXBhcmlzb24gfHwgJHdpdGhpbkNtZF0gPSB7ICRib3g6IGJveCB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJHBvbHlnb24gY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkucG9seWdvbihbMTAsMjBdLCBbMTMsIDI1XSwgWzcsMTVdKVxuICogICAgIHF1ZXJ5LnBvbHlnb24oJ2xvYycsIFsxMCwyMF0sIFsxMywgMjVdLCBbNywxNV0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFtwYXRoXVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IFt2YWxdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5wb2x5Z29uID0gZnVuY3Rpb24oKSB7XG4gIGxldCB2YWwsIHBhdGg7XG5cbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBhcmd1bWVudHNbMF0pIHtcbiAgICAvLyBwb2x5Z29uKCdsb2MnLCBbXSxbXSxbXSlcbiAgICB2YWwgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgcGF0aCA9IHZhbC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHBvbHlnb24oW10sW10sW10pXG4gICAgdGhpcy5fZW5zdXJlUGF0aCgncG9seWdvbicpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHNbdGhpcy5fZ2VvQ29tcGFyaXNvbiB8fCAkd2l0aGluQ21kXSA9IHsgJHBvbHlnb246IHZhbCB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJGNlbnRlciBvciAkY2VudGVyU3BoZXJlIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHZhciBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUgfVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5jaXJjbGUoYXJlYSlcbiAqICAgICBxdWVyeS5jZW50ZXIoJ2xvYycsIGFyZWEpO1xuICpcbiAqICAgICAvLyBmb3Igc3BoZXJpY2FsIGNhbGN1bGF0aW9uc1xuICogICAgIHZhciBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUsIHNwaGVyaWNhbDogdHJ1ZSB9XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmNpcmNsZShhcmVhKVxuICogICAgIHF1ZXJ5LmNlbnRlcignbG9jJywgYXJlYSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IGFyZWFcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0dlb3NwYXRpYWwrSW5kZXhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNpcmNsZSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcGF0aCwgdmFsO1xuXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnY2lyY2xlJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAoISgncmFkaXVzJyBpbiB2YWwgJiYgdmFsLmNlbnRlcikpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjZW50ZXIgYW5kIHJhZGl1cyBhcmUgcmVxdWlyZWQnKTtcblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gfHwgKHRoaXMuX2NvbmRpdGlvbnNbcGF0aF0gPSB7fSk7XG5cbiAgY29uc3QgdHlwZSA9IHZhbC5zcGhlcmljYWxcbiAgICA/ICckY2VudGVyU3BoZXJlJ1xuICAgIDogJyRjZW50ZXInO1xuXG4gIGNvbnN0IHdLZXkgPSB0aGlzLl9nZW9Db21wYXJpc29uIHx8ICR3aXRoaW5DbWQ7XG4gIGNvbmRzW3dLZXldID0ge307XG4gIGNvbmRzW3dLZXldW3R5cGVdID0gW3ZhbC5jZW50ZXIsIHZhbC5yYWRpdXNdO1xuXG4gIGlmICgndW5pcXVlJyBpbiB2YWwpXG4gICAgY29uZHNbd0tleV0uJHVuaXF1ZURvY3MgPSAhIXZhbC51bmlxdWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbmVhcmAgb3IgYCRuZWFyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiBUaGVzZSBvcGVyYXRvcnMgcmV0dXJuIGRvY3VtZW50cyBzb3J0ZWQgYnkgZGlzdGFuY2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0gfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1LCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKiAgICAgcXVlcnkubmVhcignbG9jJywgeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqICAgICBxdWVyeS5uZWFyKHsgY2VudGVyOiB7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBbLi5dIH19KVxuICogICAgIHF1ZXJ5Lm5lYXIoKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBbLi5dIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvR2Vvc3BhdGlhbCtJbmRleGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubmVhciA9IGZ1bmN0aW9uIG5lYXIoKSB7XG4gIGxldCBwYXRoLCB2YWw7XG5cbiAgdGhpcy5fZ2VvQ29tcGFyaXNvbiA9ICckbmVhcic7XG5cbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbmVhcicpO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKCF2YWwuY2VudGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjZW50ZXIgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcblxuICBjb25zdCB0eXBlID0gdmFsLnNwaGVyaWNhbFxuICAgID8gJyRuZWFyU3BoZXJlJ1xuICAgIDogJyRuZWFyJztcblxuICAvLyBjZW50ZXIgY291bGQgYmUgYSBHZW9KU09OIG9iamVjdCBvciBhbiBBcnJheVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwuY2VudGVyKSkge1xuICAgIGNvbmRzW3R5cGVdID0gdmFsLmNlbnRlcjtcblxuICAgIGNvbnN0IHJhZGl1cyA9ICdtYXhEaXN0YW5jZScgaW4gdmFsXG4gICAgICA/IHZhbC5tYXhEaXN0YW5jZVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKG51bGwgIT0gcmFkaXVzKSB7XG4gICAgICBjb25kcy4kbWF4RGlzdGFuY2UgPSByYWRpdXM7XG4gICAgfVxuICAgIGlmIChudWxsICE9IHZhbC5taW5EaXN0YW5jZSkge1xuICAgICAgY29uZHMuJG1pbkRpc3RhbmNlID0gdmFsLm1pbkRpc3RhbmNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBHZW9KU09OP1xuICAgIGlmICh2YWwuY2VudGVyLnR5cGUgIT0gJ1BvaW50JyB8fCAhQXJyYXkuaXNBcnJheSh2YWwuY2VudGVyLmNvb3JkaW5hdGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdJbnZhbGlkIEdlb0pTT04gc3BlY2lmaWVkIGZvciAlcycsIHR5cGUpKTtcbiAgICB9XG4gICAgY29uZHNbdHlwZV0gPSB7ICRnZW9tZXRyeTogdmFsLmNlbnRlciB9O1xuXG4gICAgLy8gTW9uZ29EQiAyLjYgaW5zaXN0cyBvbiBtYXhEaXN0YW5jZSBiZWluZyBpbiAkbmVhciAvICRuZWFyU3BoZXJlXG4gICAgaWYgKCdtYXhEaXN0YW5jZScgaW4gdmFsKSB7XG4gICAgICBjb25kc1t0eXBlXVsnJG1heERpc3RhbmNlJ10gPSB2YWwubWF4RGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICgnbWluRGlzdGFuY2UnIGluIHZhbCkge1xuICAgICAgY29uZHNbdHlwZV1bJyRtaW5EaXN0YW5jZSddID0gdmFsLm1pbkRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBpbnRlcnNlY3RzIHF1ZXJ5IGZvciBgZ2VvbWV0cnkoKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgncGF0aCcpLmludGVyc2VjdHMoKS5nZW9tZXRyeSh7XG4gKiAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJ1xuICogICAgICAgLCBjb29yZGluYXRlczogW1sxODAuMCwgMTEuMF0sIFsxODAsIDkuMF1dXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ3BhdGgnKS5pbnRlcnNlY3RzKHtcbiAqICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnXG4gKiAgICAgICAsIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiBpbnRlcnNlY3RzKCkge1xuICAvLyBvcGluaW9uYXRlZCwgbXVzdCBiZSB1c2VkIGFmdGVyIHdoZXJlXG4gIHRoaXMuX2Vuc3VyZVBhdGgoJ2ludGVyc2VjdHMnKTtcblxuICB0aGlzLl9nZW9Db21wYXJpc29uID0gJyRnZW9JbnRlcnNlY3RzJztcblxuICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3QgYXJlYSA9IGFyZ3VtZW50c1swXTtcblxuICBpZiAobnVsbCAhPSBhcmVhICYmIGFyZWEudHlwZSAmJiBhcmVhLmNvb3JkaW5hdGVzKVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5KGFyZWEpO1xuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRnZW9tZXRyeWAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgcG9seUEgPSBbW1sgMTAsIDIwIF0sIFsgMTAsIDQwIF0sIFsgMzAsIDQwIF0sIFsgMzAsIDIwIF1dXVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2x5Z29uJywgY29vcmRpbmF0ZXM6IHBvbHlBIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgdmFyIHBvbHlCID0gW1sgMCwgMCBdLCBbIDEsIDEgXV1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuZ2VvbWV0cnkoeyB0eXBlOiAnTGluZVN0cmluZycsIGNvb3JkaW5hdGVzOiBwb2x5QiB9KVxuICpcbiAqICAgICAvLyBvclxuICogICAgIHZhciBwb2x5QyA9IFsgMCwgMCBdXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IHBvbHlDIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLmludGVyc2VjdHMoKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBwb2x5QyB9KVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBgZ2VvbWV0cnkoKWAgKiptdXN0KiogY29tZSBhZnRlciBlaXRoZXIgYGludGVyc2VjdHMoKWAgb3IgYHdpdGhpbigpYC5cbiAqXG4gKiBUaGUgYG9iamVjdGAgYXJndW1lbnQgbXVzdCBjb250YWluIGB0eXBlYCBhbmQgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0aWVzLlxuICogLSB0eXBlIHtTdHJpbmd9XG4gKiAtIGNvb3JkaW5hdGVzIHtBcnJheX1cbiAqXG4gKiBUaGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBNdXN0IGNvbnRhaW4gYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggaXMgYSBTdHJpbmcgYW5kIGEgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0eSB3aGljaCBpcyBhbiBBcnJheS4gU2VlIHRoZSBleGFtcGxlcy5cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWxlYXNlLW5vdGVzLzIuNC8jbmV3LWdlb3NwYXRpYWwtaW5kZXhlcy13aXRoLWdlb2pzb24tYW5kLWltcHJvdmVkLXNwaGVyaWNhbC1nZW9tZXRyeVxuICogQHNlZSBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9HZW9zcGF0aWFsK0luZGV4aW5nXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb21ldHJ5L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZ2VvbWV0cnkgPSBmdW5jdGlvbiBnZW9tZXRyeSgpIHtcbiAgaWYgKCEoJyR3aXRoaW4nID09IHRoaXMuX2dlb0NvbXBhcmlzb24gfHxcbiAgICAgICAgJyRnZW9XaXRoaW4nID09IHRoaXMuX2dlb0NvbXBhcmlzb24gfHxcbiAgICAgICAgJyRuZWFyJyA9PSB0aGlzLl9nZW9Db21wYXJpc29uIHx8XG4gICAgICAgICckZ2VvSW50ZXJzZWN0cycgPT0gdGhpcy5fZ2VvQ29tcGFyaXNvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb21ldHJ5KCkgbXVzdCBjb21lIGFmdGVyIGB3aXRoaW4oKWAsIGBpbnRlcnNlY3RzKClgLCBvciBgbmVhcigpJyk7XG4gIH1cblxuICBsZXQgdmFsLCBwYXRoO1xuXG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnZ2VvbWV0cnknKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKCEodmFsLnR5cGUgJiYgQXJyYXkuaXNBcnJheSh2YWwuY29vcmRpbmF0ZXMpKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHNbdGhpcy5fZ2VvQ29tcGFyaXNvbl0gPSB7ICRnZW9tZXRyeTogdmFsIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbmQgc3BhdGlhbFxuXG4vKipcbiAqIFNwZWNpZmllcyB3aGljaCBkb2N1bWVudCBmaWVsZHMgdG8gaW5jbHVkZSBvciBleGNsdWRlXG4gKlxuICogIyMjIyBTdHJpbmcgc3ludGF4XG4gKlxuICogV2hlbiBwYXNzaW5nIGEgc3RyaW5nLCBwcmVmaXhpbmcgYSBwYXRoIHdpdGggYC1gIHdpbGwgZmxhZyB0aGF0IHBhdGggYXMgZXhjbHVkZWQuIFdoZW4gYSBwYXRoIGRvZXMgbm90IGhhdmUgdGhlIGAtYCBwcmVmaXgsIGl0IGlzIGluY2x1ZGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gaW5jbHVkZSBhIGFuZCBiLCBleGNsdWRlIGNcbiAqICAgICBxdWVyeS5zZWxlY3QoJ2EgYiAtYycpO1xuICpcbiAqICAgICAvLyBvciB5b3UgbWF5IHVzZSBvYmplY3Qgbm90YXRpb24sIHVzZWZ1bCB3aGVuXG4gKiAgICAgLy8geW91IGhhdmUga2V5cyBhbHJlYWR5IHByZWZpeGVkIHdpdGggYSBcIi1cIlxuICogICAgIHF1ZXJ5LnNlbGVjdCh7YTogMSwgYjogMSwgYzogMH0pO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gIGxldCBhcmcgPSBhcmd1bWVudHNbMF07XG4gIGlmICghYXJnKSByZXR1cm4gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3Q6IHNlbGVjdCBvbmx5IHRha2VzIDEgYXJndW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX3ZhbGlkYXRlKCdzZWxlY3QnKTtcblxuICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMgfHwgKHRoaXMuX2ZpZWxkcyA9IHt9KTtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGxldCBpLCBsZW47XG5cbiAgaWYgKCgnc3RyaW5nJyA9PSB0eXBlIHx8IHV0aWxzLmlzQXJndW1lbnRzT2JqZWN0KGFyZykpICYmXG4gICAgJ251bWJlcicgPT0gdHlwZW9mIGFyZy5sZW5ndGggfHwgQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgaWYgKCdzdHJpbmcnID09IHR5cGUpXG4gICAgICBhcmcgPSBhcmcuc3BsaXQoL1xccysvKTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFyZy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgbGV0IGZpZWxkID0gYXJnW2ldO1xuICAgICAgaWYgKCFmaWVsZCkgY29udGludWU7XG4gICAgICBjb25zdCBpbmNsdWRlID0gJy0nID09IGZpZWxkWzBdID8gMCA6IDE7XG4gICAgICBpZiAoaW5jbHVkZSA9PT0gMCkgZmllbGQgPSBmaWVsZC5zdWJzdHJpbmcoMSk7XG4gICAgICBmaWVsZHNbZmllbGRdID0gaW5jbHVkZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh1dGlscy5pc09iamVjdChhcmcpKSB7XG4gICAgY29uc3Qga2V5cyA9IHV0aWxzLmtleXMoYXJnKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgZmllbGRzW2tleXNbaV1dID0gYXJnW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc2VsZWN0KCkgYXJndW1lbnQuIE11c3QgYmUgc3RyaW5nIG9yIG9iamVjdC4nKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgJHNsaWNlIGNvbmRpdGlvbiBmb3IgYSBgcGF0aGBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIDUpXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgLTUpXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgWzEwLCA1XSlcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudHMnKS5zbGljZSg1KVxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50cycpLnNsaWNlKFstMTAsIDVdKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgbnVtYmVyL3JhbmdlIG9mIGVsZW1lbnRzIHRvIHNsaWNlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL1JldHJpZXZpbmcrYStTdWJzZXQrb2YrRmllbGRzI1JldHJpZXZpbmdhU3Vic2V0b2ZGaWVsZHMtUmV0cmlldmluZ2FTdWJyYW5nZW9mQXJyYXlFbGVtZW50c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKDAgPT09IGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NsaWNlJyk7XG5cbiAgbGV0IHBhdGgsIHZhbDtcblxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gICAgICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICB0aGlzLnNsaWNlKGtleXNbaV0sIGFyZ1trZXlzW2ldXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgdmFsID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoMyA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgfVxuXG4gIGNvbnN0IG15RmllbGRzID0gdGhpcy5fZmllbGRzIHx8ICh0aGlzLl9maWVsZHMgPSB7fSk7XG4gIG15RmllbGRzW3BhdGhdID0geyAkc2xpY2U6IHZhbCB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc29ydCBvcmRlclxuICpcbiAqIElmIGFuIG9iamVjdCBpcyBwYXNzZWQsIHZhbHVlcyBhbGxvd2VkIGFyZSAnYXNjJywgJ2Rlc2MnLCAnYXNjZW5kaW5nJywgJ2Rlc2NlbmRpbmcnLCAxLCBhbmQgLTEuXG4gKlxuICogSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCBpdCBtdXN0IGJlIGEgc3BhY2UgZGVsaW1pdGVkIGxpc3Qgb2YgcGF0aCBuYW1lcy4gVGhlIHNvcnQgb3JkZXIgb2YgZWFjaCBwYXRoIGlzIGFzY2VuZGluZyB1bmxlc3MgdGhlIHBhdGggbmFtZSBpcyBwcmVmaXhlZCB3aXRoIGAtYCB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgZGVzY2VuZGluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHRoZXNlIGFyZSBlcXVpdmFsZW50XG4gKiAgICAgcXVlcnkuc29ydCh7IGZpZWxkOiAnYXNjJywgdGVzdDogLTEgfSk7XG4gKiAgICAgcXVlcnkuc29ydCgnZmllbGQgLXRlc3QnKTtcbiAqICAgICBxdWVyeS5zb3J0KFtbJ2ZpZWxkJywgMV0sIFsndGVzdCcsIC0xXV0pO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiAgLSBUaGUgYXJyYXkgc3ludGF4IGAuc29ydChbWydmaWVsZCcsIDFdLCBbJ3Rlc3QnLCAtMV1dKWAgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFttb25nb2RiIGRyaXZlciA+PSAyLjAuNDZdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUvYmxvYi8yLjEvSElTVE9SWS5tZCMyMDQ2LTIwMTUtMTAtMTUpLlxuICogIC0gQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8QXJyYXl9IGFyZ1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihhcmcpIHtcbiAgaWYgKCFhcmcpIHJldHVybiB0aGlzO1xuICBsZXQgaSwgbGVuLCBmaWVsZDtcblxuICB0aGlzLl92YWxpZGF0ZSgnc29ydCcpO1xuXG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuXG4gIC8vIC5zb3J0KFtbJ2ZpZWxkJywgMV0sIFsndGVzdCcsIC0xXV0pXG4gIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdbaV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzb3J0KCkgYXJndW1lbnQsIG11c3QgYmUgYXJyYXkgb2YgYXJyYXlzJyk7XG4gICAgICB9XG4gICAgICBfcHVzaEFycih0aGlzLm9wdGlvbnMsIGFyZ1tpXVswXSwgYXJnW2ldWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyAuc29ydCgnZmllbGQgLXRlc3QnKVxuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiAnc3RyaW5nJyA9PSB0eXBlKSB7XG4gICAgYXJnID0gYXJnLnNwbGl0KC9cXHMrLyk7XG4gICAgbGVuID0gYXJnLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGZpZWxkID0gYXJnW2ldO1xuICAgICAgaWYgKCFmaWVsZCkgY29udGludWU7XG4gICAgICBjb25zdCBhc2NlbmQgPSAnLScgPT0gZmllbGRbMF0gPyAtMSA6IDE7XG4gICAgICBpZiAoYXNjZW5kID09PSAtMSkgZmllbGQgPSBmaWVsZC5zdWJzdHJpbmcoMSk7XG4gICAgICBwdXNoKHRoaXMub3B0aW9ucywgZmllbGQsIGFzY2VuZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyAuc29ydCh7IGZpZWxkOiAxLCB0ZXN0OiAtMSB9KVxuICBpZiAodXRpbHMuaXNPYmplY3QoYXJnKSkge1xuICAgIGNvbnN0IGtleXMgPSB1dGlscy5rZXlzKGFyZyk7XG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZpZWxkID0ga2V5c1tpXTtcbiAgICAgIHB1c2godGhpcy5vcHRpb25zLCBmaWVsZCwgYXJnW2ZpZWxkXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgYXJnIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgX3B1c2hNYXAodGhpcy5vcHRpb25zLCBhcmcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LiBNdXN0IGJlIGEgc3RyaW5nLCBvYmplY3QsIG9yIGFycmF5LicpO1xufTtcblxuLyohXG4gKiBAaWdub3JlXG4gKi9cblxuY29uc3QgX3ZhbGlkU29ydFZhbHVlID0ge1xuICAxOiAxLFxuICAnLTEnOiAtMSxcbiAgYXNjOiAxLFxuICBhc2NlbmRpbmc6IDEsXG4gIGRlc2M6IC0xLFxuICBkZXNjZW5kaW5nOiAtMVxufTtcblxuZnVuY3Rpb24gcHVzaChvcHRzLCBmaWVsZCwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5zb3J0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhblxcJ3QgbWl4IHNvcnQgc3ludGF4ZXMuIFVzZSBlaXRoZXIgYXJyYXkgb3Igb2JqZWN0OicgK1xuICAgICAgJ1xcbi0gYC5zb3J0KFtbXFwnZmllbGRcXCcsIDFdLCBbXFwndGVzdFxcJywgLTFdXSlgJyArXG4gICAgICAnXFxuLSBgLnNvcnQoeyBmaWVsZDogMSwgdGVzdDogLTEgfSlgJyk7XG4gIH1cblxuICBsZXQgcztcbiAgaWYgKHZhbHVlICYmIHZhbHVlLiRtZXRhKSB7XG4gICAgcyA9IG9wdHMuc29ydCB8fCAob3B0cy5zb3J0ID0ge30pO1xuICAgIHNbZmllbGRdID0geyAkbWV0YTogdmFsdWUuJG1ldGEgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzID0gb3B0cy5zb3J0IHx8IChvcHRzLnNvcnQgPSB7fSk7XG4gIGxldCB2YWwgPSBTdHJpbmcodmFsdWUgfHwgMSkudG9Mb3dlckNhc2UoKTtcbiAgdmFsID0gX3ZhbGlkU29ydFZhbHVlW3ZhbF07XG4gIGlmICghdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQgdmFsdWU6IHsgJyArIGZpZWxkICsgJzogJyArIHZhbHVlICsgJyB9Jyk7XG5cbiAgc1tmaWVsZF0gPSB2YWw7XG59XG5cbmZ1bmN0aW9uIF9wdXNoQXJyKG9wdHMsIGZpZWxkLCB2YWx1ZSkge1xuICBvcHRzLnNvcnQgPSBvcHRzLnNvcnQgfHwgW107XG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRzLnNvcnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuXFwndCBtaXggc29ydCBzeW50YXhlcy4gVXNlIGVpdGhlciBhcnJheSBvciBvYmplY3Q6JyArXG4gICAgICAnXFxuLSBgLnNvcnQoW1tcXCdmaWVsZFxcJywgMV0sIFtcXCd0ZXN0XFwnLCAtMV1dKWAnICtcbiAgICAgICdcXG4tIGAuc29ydCh7IGZpZWxkOiAxLCB0ZXN0OiAtMSB9KWAnKTtcbiAgfVxuXG4gIGxldCB2YWwgPSBTdHJpbmcodmFsdWUgfHwgMSkudG9Mb3dlckNhc2UoKTtcbiAgdmFsID0gX3ZhbGlkU29ydFZhbHVlW3ZhbF07XG4gIGlmICghdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQgdmFsdWU6IFsgJyArIGZpZWxkICsgJywgJyArIHZhbHVlICsgJyBdJyk7XG5cbiAgb3B0cy5zb3J0LnB1c2goW2ZpZWxkLCB2YWxdKTtcbn1cblxuZnVuY3Rpb24gX3B1c2hNYXAob3B0cywgbWFwKSB7XG4gIG9wdHMuc29ydCA9IG9wdHMuc29ydCB8fCBuZXcgTWFwKCk7XG4gIGlmICghKG9wdHMuc29ydCBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5cXCd0IG1peCBzb3J0IHN5bnRheGVzLiBVc2UgZWl0aGVyIGFycmF5IG9yICcgK1xuICAgICAgJ29iamVjdCBvciBtYXAgY29uc2lzdGVudGx5Jyk7XG4gIH1cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIGxldCB2YWwgPSBTdHJpbmcodmFsdWUgfHwgMSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSBfdmFsaWRTb3J0VmFsdWVbdmFsXTtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0IHZhbHVlOiA8ICcgKyBrZXkgKyAnOiAnICsgdmFsdWUgKyAnID4nKTtcblxuICAgIG9wdHMuc29ydC5zZXQoa2V5LCB2YWwpO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgbGltaXQgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkubGltaXQoMjApXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBsaW1pdFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCbGltaXQlMjglMjklN0QlN0RcbiAqIEBhcGkgcHVibGljXG4gKi9cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBza2lwIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNraXAoMTAwKS5saW1pdCgyMClcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIHNraXBcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSU3QiU3QnNraXAlMjglMjklN0QlN0RcbiAqIEBhcGkgcHVibGljXG4gKi9cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBiYXRjaFNpemUgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuYmF0Y2hTaXplKDEwMClcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGJhdGNoU2l6ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWR2YW5jZWQrUXVlcmllcyNBZHZhbmNlZFF1ZXJpZXMtJTdCJTdCYmF0Y2hTaXplJTI4JTI5JTdEJTdEXG4gKiBAYXBpIHB1YmxpY1xuICovXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYGNvbW1lbnRgIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmNvbW1lbnQoJ2xvZ2luIHF1ZXJ5JylcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGNvbW1lbnRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHA6Ly93d3cubW9uZ29kYi5vcmcvZGlzcGxheS9ET0NTL0FkdmFuY2VkK1F1ZXJpZXMjQWR2YW5jZWRRdWVyaWVzLSUyNGNvbW1lbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyohXG4gKiBsaW1pdCwgc2tpcCwgYmF0Y2hTaXplLCBjb21tZW50XG4gKlxuICogU2V0cyB0aGVzZSBhc3NvY2lhdGVkIG9wdGlvbnMuXG4gKlxuICogICAgIHF1ZXJ5LmNvbW1lbnQoJ2ZlZWQgcXVlcnknKTtcbiAqL1xuXG5bJ2xpbWl0JywgJ3NraXAnLCAnYmF0Y2hTaXplJywgJ2NvbW1lbnQnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBRdWVyeS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLl92YWxpZGF0ZShtZXRob2QpO1xuICAgIHRoaXMub3B0aW9uc1ttZXRob2RdID0gdjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgbWF4VGltZU1TIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5Lm1heFRpbWUoMTAwKVxuICogICAgIHF1ZXJ5Lm1heFRpbWVNUygxMDApXG4gKlxuICogQG1ldGhvZCBtYXhUaW1lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHNlZSBtb25nb2RiIGh0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWV0YS9tYXhUaW1lTVMvI29wLl9TX21heFRpbWVNU1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubWF4VGltZSA9IFF1ZXJ5LnByb3RvdHlwZS5tYXhUaW1lTVMgPSBmdW5jdGlvbihtcykge1xuICB0aGlzLl92YWxpZGF0ZSgnbWF4VGltZScpO1xuICB0aGlzLm9wdGlvbnMubWF4VGltZU1TID0gbXM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHF1ZXJ5IGhpbnRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuaGludCh7IGluZGV4QTogMSwgaW5kZXhCOiAtMX0pO1xuICogICAgIHF1ZXJ5LmhpbnQoJ2luZGV4QV8xX2luZGV4Ql8xJyk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSB2YWwgYSBoaW50IG9iamVjdCBvciB0aGUgaW5kZXggbmFtZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9BZHZhbmNlZCtRdWVyaWVzI0FkdmFuY2VkUXVlcmllcy0lMjRoaW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5oaW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICgwID09PSBhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcztcblxuICB0aGlzLl92YWxpZGF0ZSgnaGludCcpO1xuXG4gIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZykpIHtcbiAgICBjb25zdCBoaW50ID0gdGhpcy5vcHRpb25zLmhpbnQgfHwgKHRoaXMub3B0aW9ucy5oaW50ID0ge30pO1xuXG4gICAgLy8gbXVzdCBrZWVwIG9iamVjdCBrZXlzIGluIG9yZGVyIHNvIGRvbid0IHVzZSBPYmplY3Qua2V5cygpXG4gICAgZm9yIChjb25zdCBrIGluIGFyZykge1xuICAgICAgaGludFtrXSA9IGFyZ1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLm9wdGlvbnMuaGludCA9IGFyZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGludC4gJyArIGFyZyk7XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIGFja25vd2xlZGdlbWVudCB0aGF0IHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIHBlcnNpc3RlZCB0byBNb25nb0RCJ3NcbiAqIG9uLWRpc2sgam91cm5hbC5cbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqIC0gYHVwZGF0ZU1hbnkoKWBcbiAqXG4gKiBEZWZhdWx0cyB0byB0aGUgYGpgIHZhbHVlIGlmIGl0IGlzIHNwZWNpZmllZCBpbiB3cml0ZUNvbmNlcm4gb3B0aW9uc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbXF1ZXJ5KCkudygyKS5qKHRydWUpLnd0aW1lb3V0KDIwMDApO1xuICpcbiAqIEBtZXRob2QgalxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9kb2NzLm1vbmdvZGIuY29tL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jai1vcHRpb25cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5qID0gZnVuY3Rpb24gaih2YWwpIHtcbiAgdGhpcy5vcHRpb25zLmogPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzbGF2ZU9rIG9wdGlvbi4gX0RlcHJlY2F0ZWRfIGluIE1vbmdvREIgMi4yIGluIGZhdm9yIG9mIHJlYWQgcHJlZmVyZW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5zbGF2ZU9rKCkgLy8gdHJ1ZVxuICogICAgIHF1ZXJ5LnNsYXZlT2sodHJ1ZSlcbiAqICAgICBxdWVyeS5zbGF2ZU9rKGZhbHNlKVxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSByZWFkKCkgcHJlZmVyZW5jZXMgaW5zdGVhZCBpZiBvbiBtb25nb2RiID49IDIuMlxuICogQHBhcmFtIHtCb29sZWFufSB2IGRlZmF1bHRzIHRvIHRydWVcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2VcbiAqIEBzZWUgcmVhZCgpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2xhdmVPayA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5vcHRpb25zLnNsYXZlT2sgPSBhcmd1bWVudHMubGVuZ3RoID8gISF2IDogdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlYWRQcmVmZXJlbmNlIG9wdGlvbiBmb3IgdGhlIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncHJpbWFyeScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncCcpICAvLyBzYW1lIGFzIHByaW1hcnlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncHJpbWFyeVByZWZlcnJlZCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncHAnKSAvLyBzYW1lIGFzIHByaW1hcnlQcmVmZXJyZWRcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnc2Vjb25kYXJ5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzJykgIC8vIHNhbWUgYXMgc2Vjb25kYXJ5XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3NlY29uZGFyeVByZWZlcnJlZCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnc3AnKSAvLyBzYW1lIGFzIHNlY29uZGFyeVByZWZlcnJlZFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCduZWFyZXN0JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCduJykgIC8vIHNhbWUgYXMgbmVhcmVzdFxuICpcbiAqICAgICAvLyB5b3UgY2FuIGFsc28gdXNlIG1vbmdvZGIuUmVhZFByZWZlcmVuY2UgY2xhc3MgdG8gYWxzbyBzcGVjaWZ5IHRhZ3NcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKG1vbmdvZGIuUmVhZFByZWZlcmVuY2UoJ3NlY29uZGFyeScsIFt7IGRjOidzZicsIHM6IDEgfSx7IGRjOidtYScsIHM6IDIgfV0pKVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5zZXRSZWFkUHJlZmVyZW5jZSgncHJpbWFyeScpIC8vIGFsaWFzIG9mIC5yZWFkKClcbiAqXG4gKiAjIyMjIFByZWZlcmVuY2VzOlxuICpcbiAqICAgICBwcmltYXJ5IC0gKGRlZmF1bHQpICBSZWFkIGZyb20gcHJpbWFyeSBvbmx5LiBPcGVyYXRpb25zIHdpbGwgcHJvZHVjZSBhbiBlcnJvciBpZiBwcmltYXJ5IGlzIHVuYXZhaWxhYmxlLiBDYW5ub3QgYmUgY29tYmluZWQgd2l0aCB0YWdzLlxuICogICAgIHNlY29uZGFyeSAgICAgICAgICAgIFJlYWQgZnJvbSBzZWNvbmRhcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZXJyb3IuXG4gKiAgICAgcHJpbWFyeVByZWZlcnJlZCAgICAgUmVhZCBmcm9tIHByaW1hcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYSBzZWNvbmRhcnkuXG4gKiAgICAgc2Vjb25kYXJ5UHJlZmVycmVkICAgUmVhZCBmcm9tIGEgc2Vjb25kYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHJlYWQgZnJvbSB0aGUgcHJpbWFyeS5cbiAqICAgICBuZWFyZXN0ICAgICAgICAgICAgICBBbGwgb3BlcmF0aW9ucyByZWFkIGZyb20gYW1vbmcgdGhlIG5lYXJlc3QgY2FuZGlkYXRlcywgYnV0IHVubGlrZSBvdGhlciBtb2RlcywgdGhpcyBvcHRpb24gd2lsbCBpbmNsdWRlIGJvdGggdGhlIHByaW1hcnkgYW5kIGFsbCBzZWNvbmRhcmllcyBpbiB0aGUgcmFuZG9tIHNlbGVjdGlvbi5cbiAqXG4gKiBBbGlhc2VzXG4gKlxuICogICAgIHAgICBwcmltYXJ5XG4gKiAgICAgcHAgIHByaW1hcnlQcmVmZXJyZWRcbiAqICAgICBzICAgc2Vjb25kYXJ5XG4gKiAgICAgc3AgIHNlY29uZGFyeVByZWZlcnJlZFxuICogICAgIG4gICBuZWFyZXN0XG4gKlxuICogUmVhZCBtb3JlIGFib3V0IGhvdyB0byB1c2UgcmVhZCBwcmVmZXJlbmNlcyBbaGVyZV0oaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlKSBhbmQgW2hlcmVdKGh0dHA6Ly9tb25nb2RiLmdpdGh1Yi5jb20vbm9kZS1tb25nb2RiLW5hdGl2ZS9kcml2ZXItYXJ0aWNsZXMvYW5pbnRyb2R1Y3Rpb250bzFfMWFuZDJfMi5odG1sI3JlYWQtcHJlZmVyZW5jZXMpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlYWRQcmVmZXJlbmNlfSBwcmVmIG9uZSBvZiB0aGUgbGlzdGVkIHByZWZlcmVuY2Ugb3B0aW9ucyBvciB0aGVpciBhbGlhc2VzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlXG4gKiBAc2VlIGRyaXZlciBodHRwOi8vbW9uZ29kYi5naXRodWIuY29tL25vZGUtbW9uZ29kYi1uYXRpdmUvZHJpdmVyLWFydGljbGVzL2FuaW50cm9kdWN0aW9udG8xXzFhbmQyXzIuaHRtbCNyZWFkLXByZWZlcmVuY2VzXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucmVhZCA9IFF1ZXJ5LnByb3RvdHlwZS5zZXRSZWFkUHJlZmVyZW5jZSA9IGZ1bmN0aW9uKHByZWYpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmICFRdWVyeS5wcm90b3R5cGUucmVhZC5kZXByZWNhdGlvbldhcm5pbmdJc3N1ZWQpIHtcbiAgICBjb25zb2xlLmVycm9yKCdEZXByZWNhdGlvbiB3YXJuaW5nOiBcXCd0YWdzXFwnIGFyZ3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQgYW55bW9yZSBpbiBRdWVyeS5yZWFkKCkgbWV0aG9kLiBQbGVhc2UgdXNlIG1vbmdvZGIuUmVhZFByZWZlcmVuY2Ugb2JqZWN0IGluc3RlYWQuJyk7XG4gICAgUXVlcnkucHJvdG90eXBlLnJlYWQuZGVwcmVjYXRpb25XYXJuaW5nSXNzdWVkID0gdHJ1ZTtcbiAgfVxuICB0aGlzLm9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSB1dGlscy5yZWFkUHJlZihwcmVmKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlYWRDb25jZXJuIG9wdGlvbiBmb3IgdGhlIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2xvY2FsJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbCcpICAvLyBzYW1lIGFzIGxvY2FsXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdhdmFpbGFibGUnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdhJykgIC8vIHNhbWUgYXMgYXZhaWxhYmxlXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdtYWpvcml0eScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ20nKSAgLy8gc2FtZSBhcyBtYWpvcml0eVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbGluZWFyaXphYmxlJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbHonKSAvLyBzYW1lIGFzIGxpbmVhcml6YWJsZVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2Vybignc25hcHNob3QnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdzJykgIC8vIHNhbWUgYXMgc25hcHNob3RcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucigncycpIC8vIHIgaXMgYWxpYXMgb2YgcmVhZENvbmNlcm5cbiAqXG4gKlxuICogIyMjIyBSZWFkIENvbmNlcm4gTGV2ZWw6XG4gKlxuICogICAgIGxvY2FsICAgICAgICAgTW9uZ29EQiAzLjIrIFRoZSBxdWVyeSByZXR1cm5zIGZyb20gdGhlIGluc3RhbmNlIHdpdGggbm8gZ3VhcmFudGVlIGd1YXJhbnRlZSB0aGF0IHRoZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gdG8gYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycyAoaS5lLiBtYXkgYmUgcm9sbGVkIGJhY2spLlxuICogICAgIGF2YWlsYWJsZSAgICAgTW9uZ29EQiAzLjYrIFRoZSBxdWVyeSByZXR1cm5zIGZyb20gdGhlIGluc3RhbmNlIHdpdGggbm8gZ3VhcmFudGVlIGd1YXJhbnRlZSB0aGF0IHRoZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gdG8gYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycyAoaS5lLiBtYXkgYmUgcm9sbGVkIGJhY2spLlxuICogICAgIG1ham9yaXR5ICAgICAgTW9uZ29EQiAzLjIrIFRoZSBxdWVyeSByZXR1cm5zIHRoZSBkYXRhIHRoYXQgaGFzIGJlZW4gYWNrbm93bGVkZ2VkIGJ5IGEgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0IG1lbWJlcnMuIFRoZSBkb2N1bWVudHMgcmV0dXJuZWQgYnkgdGhlIHJlYWQgb3BlcmF0aW9uIGFyZSBkdXJhYmxlLCBldmVuIGluIHRoZSBldmVudCBvZiBmYWlsdXJlLlxuICogICAgIGxpbmVhcml6YWJsZSAgTW9uZ29EQiAzLjQrIFRoZSBxdWVyeSByZXR1cm5zIGRhdGEgdGhhdCByZWZsZWN0cyBhbGwgc3VjY2Vzc2Z1bCBtYWpvcml0eS1hY2tub3dsZWRnZWQgd3JpdGVzIHRoYXQgY29tcGxldGVkIHByaW9yIHRvIHRoZSBzdGFydCBvZiB0aGUgcmVhZCBvcGVyYXRpb24uIFRoZSBxdWVyeSBtYXkgd2FpdCBmb3IgY29uY3VycmVudGx5IGV4ZWN1dGluZyB3cml0ZXMgdG8gcHJvcGFnYXRlIHRvIGEgbWFqb3JpdHkgb2YgcmVwbGljYSBzZXQgbWVtYmVycyBiZWZvcmUgcmV0dXJuaW5nIHJlc3VsdHMuXG4gKiAgICAgc25hcHNob3QgICAgICBNb25nb0RCIDQuMCsgT25seSBhdmFpbGFibGUgZm9yIG9wZXJhdGlvbnMgd2l0aGluIG11bHRpLWRvY3VtZW50IHRyYW5zYWN0aW9ucy4gVXBvbiB0cmFuc2FjdGlvbiBjb21taXQgd2l0aCB3cml0ZSBjb25jZXJuIFwibWFqb3JpdHlcIiwgdGhlIHRyYW5zYWN0aW9uIG9wZXJhdGlvbnMgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSByZWFkIGZyb20gYSBzbmFwc2hvdCBvZiBtYWpvcml0eS1jb21taXR0ZWQgZGF0YS5cbiAqXG4gKiBBbGlhc2VzXG4gKlxuICogICAgIGwgICBsb2NhbFxuICogICAgIGEgICBhdmFpbGFibGVcbiAqICAgICBtICAgbWFqb3JpdHlcbiAqICAgICBseiAgbGluZWFyaXphYmxlXG4gKiAgICAgcyAgIHNuYXBzaG90XG4gKlxuICogUmVhZCBtb3JlIGFib3V0IGhvdyB0byB1c2UgcmVhZCBjb25jZXJuIFtoZXJlXShodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9yZWFkLWNvbmNlcm4vKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWwgb25lIG9mIHRoZSBsaXN0ZWQgcmVhZCBjb25jZXJuIGxldmVsIG9yIHRoZWlyIGFsaWFzZXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9yZWFkLWNvbmNlcm4vXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucmVhZENvbmNlcm4gPSBRdWVyeS5wcm90b3R5cGUuciA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gIHRoaXMub3B0aW9ucy5yZWFkQ29uY2VybiA9IHV0aWxzLnJlYWRDb25jZXJuKGxldmVsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGFpbGFibGUgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkudGFpbGFibGUoKSA8PT0gdHJ1ZVxuICogICAgIHF1ZXJ5LnRhaWxhYmxlKHRydWUpXG4gKiAgICAgcXVlcnkudGFpbGFibGUoZmFsc2UpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB2IGRlZmF1bHRzIHRvIHRydWVcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9UYWlsYWJsZStDdXJzb3JzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl92YWxpZGF0ZSgndGFpbGFibGUnKTtcblxuICB0aGlzLm9wdGlvbnMudGFpbGFibGUgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgPyAhIWFyZ3VtZW50c1swXVxuICAgIDogdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBgbW9uZ29kYCBzZXJ2ZXJzLCBvciB0YWcgc2V0IG9mIGBtb25nb2RgIHNlcnZlcnMsXG4gKiB0aGF0IG11c3QgYWNrbm93bGVkZ2UgdGhpcyB3cml0ZSBiZWZvcmUgdGhpcyB3cml0ZSBpcyBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwuXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIGB3YCB2YWx1ZSBpZiBpdCBpcyBzcGVjaWZpZWQgaW4gd3JpdGVDb25jZXJuIG9wdGlvbnNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybigwKVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybigxKVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2Vybih7IHc6IDEsIGo6IHRydWUsIHd0aW1lb3V0OiAyMDAwIH0pXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKCdtYWpvcml0eScpXG4gKiAgICAgbXF1ZXJ5KCkud3JpdGVDb25jZXJuKCdtJykgLy8gc2FtZSBhcyBtYWpvcml0eVxuICogICAgIG1xdWVyeSgpLndyaXRlQ29uY2VybigndGFnU2V0TmFtZScpIC8vIGlmIHRoZSB0YWcgc2V0IGlzICdtJywgdXNlIC53cml0ZUNvbmNlcm4oeyB3OiAnbScgfSkgaW5zdGVhZFxuICogICAgIG1xdWVyeSgpLncoMSkgLy8gdyBpcyBhbGlhcyBvZiB3cml0ZUNvbmNlcm5cbiAqXG4gKiBAbWV0aG9kIHdyaXRlQ29uY2VyblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfG51bWJlcnxvYmplY3R9IGNvbmNlcm4gMCBmb3IgZmlyZS1hbmQtZm9yZ2V0LCAxIGZvciBhY2tub3dsZWRnZWQgYnkgb25lIHNlcnZlciwgJ21ham9yaXR5JyBmb3IgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0LCBvciBbYW55IG9mIHRoZSBtb3JlIGFkdmFuY2VkIG9wdGlvbnNdKGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uKS5cbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3LW9wdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLndyaXRlQ29uY2VybiA9IFF1ZXJ5LnByb3RvdHlwZS53ID0gZnVuY3Rpb24gd3JpdGVDb25jZXJuKGNvbmNlcm4pIHtcbiAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgY29uY2Vybikge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGNvbmNlcm4uaikgdGhpcy5vcHRpb25zLmogPSBjb25jZXJuLmo7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uY2Vybi53KSB0aGlzLm9wdGlvbnMudyA9IGNvbmNlcm4udztcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjb25jZXJuLnd0aW1lb3V0KSB0aGlzLm9wdGlvbnMud3RpbWVvdXQgPSBjb25jZXJuLnd0aW1lb3V0O1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy53ID0gJ20nID09PSBjb25jZXJuID8gJ21ham9yaXR5JyA6IGNvbmNlcm47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIHRpbWUgbGltaXQsIGluIG1pbGxpc2Vjb25kcywgZm9yIHRoZSB3cml0ZSBjb25jZXJuLlxuICogSWYgYG1zID4gMWAsIGl0IGlzIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhpcyB3cml0ZVxuICogdG8gcHJvcGFnYXRlIHRocm91Z2ggdGhlIHJlcGxpY2Egc2V0IGJlZm9yZSB0aGlzIG9wZXJhdGlvbiBmYWlscy5cbiAqIFRoZSBkZWZhdWx0IGlzIGAwYCwgd2hpY2ggbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gYHd0aW1lb3V0YCB2YWx1ZSBpZiBpdCBpcyBzcGVjaWZpZWQgaW4gd3JpdGVDb25jZXJuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtcXVlcnkoKS53KDIpLmoodHJ1ZSkud3RpbWVvdXQoMjAwMClcbiAqXG4gKiBAbWV0aG9kIHd0aW1lb3V0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG1zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vZG9jcy5tb25nb2RiLmNvbS9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3d0aW1lb3V0XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud3RpbWVvdXQgPSBRdWVyeS5wcm90b3R5cGUud1RpbWVvdXQgPSBmdW5jdGlvbiB3dGltZW91dChtcykge1xuICB0aGlzLm9wdGlvbnMud3RpbWVvdXQgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1lcmdlcyBhbm90aGVyIFF1ZXJ5IG9yIGNvbmRpdGlvbnMgb2JqZWN0IGludG8gdGhpcyBvbmUuXG4gKlxuICogV2hlbiBhIFF1ZXJ5IGlzIHBhc3NlZCwgY29uZGl0aW9ucywgZmllbGQgc2VsZWN0aW9uIGFuZCBvcHRpb25zIGFyZSBtZXJnZWQuXG4gKlxuICogQHBhcmFtIHtRdWVyeXxPYmplY3R9IHNvdXJjZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgaWYgKCFzb3VyY2UpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKCFRdWVyeS5jYW5NZXJnZShzb3VyY2UpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQuIEV4cGVjdGVkIGluc3RhbmNlb2YgbXF1ZXJ5IG9yIHBsYWluIG9iamVjdCcpO1xuXG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIC8vIGlmIHNvdXJjZSBoYXMgYSBmZWF0dXJlLCBhcHBseSBpdCB0byBvdXJzZWx2ZXNcblxuICAgIGlmIChzb3VyY2UuX2NvbmRpdGlvbnMpIHtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHNvdXJjZS5fY29uZGl0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5fZmllbGRzKSB7XG4gICAgICB0aGlzLl9maWVsZHMgfHwgKHRoaXMuX2ZpZWxkcyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2ZpZWxkcywgc291cmNlLl9maWVsZHMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2Uub3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zIHx8ICh0aGlzLm9wdGlvbnMgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZSh0aGlzLm9wdGlvbnMsIHNvdXJjZS5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl91cGRhdGVEb2MpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURvYyB8fCAodGhpcy5fdXBkYXRlRG9jID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGVEb2MsIHNvdXJjZS5fdXBkYXRlRG9jKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl9kaXN0aW5jdERvYykge1xuICAgICAgdGhpcy5fZGlzdGluY3REb2MgPSBzb3VyY2UuX2Rpc3RpbmN0RG9jO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcGxhaW4gb2JqZWN0XG4gIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHNvdXJjZSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmRzIGRvY3VtZW50cy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmZpbmQoKVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmQoKVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmQoeyBuYW1lOiAnQnVybmluZyBMaWdodHMnIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2ZpbmQnO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBmaW5kYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdFxuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmQgPSBhc3luYyBmdW5jdGlvbiBfZmluZCgpIHtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBpZiAodGhpcy4kdXNlUHJvamVjdGlvbikge1xuICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmZpZWxkcyA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfVxuXG4gIGRlYnVnKCdfZmluZCcsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcXVlcnkgY3Vyc29yXG4gKlxuICogIyMjIyBFeGFtcGxlczpcbiAqXG4gKiAgICAgcXVlcnkuZmluZCgpLmN1cnNvcigpO1xuICogICAgIHF1ZXJ5LmN1cnNvcih7IG5hbWU6ICdCdXJuaW5nIExpZ2h0cycgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7T2JqZWN0fSBjdXJzb3JcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmN1cnNvciA9IGZ1bmN0aW9uIGN1cnNvcihjcml0ZXJpYSkge1xuICBpZiAodGhpcy5vcCkge1xuICAgIGlmICh0aGlzLm9wICE9PSAnZmluZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJy5jdXJzb3Igb25seSBzdXBwb3J0IC5maW5kIG1ldGhvZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmQoY3JpdGVyaWEpO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBpZiAodGhpcy4kdXNlUHJvamVjdGlvbikge1xuICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmZpZWxkcyA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfVxuXG4gIGRlYnVnKCdmaW5kQ3Vyc29yJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kQ3Vyc29yKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IGFzIGEgZmluZE9uZSgpIG9wZXJhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmZpbmRPbmUoKS53aGVyZSgnbmFtZScsIC9eQnVybmluZy8pO1xuICpcbiAqICAgICBxdWVyeS5maW5kT25lKHsgbmFtZTogL15CdXJuaW5nLyB9KVxuICpcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kT25lKHsgbmFtZTogL15CdXJuaW5nLyB9KTsgLy8gZXhlY3V0ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2NyaXRlcmlhXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZSA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnZmluZE9uZSc7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGZpbmRPbmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmUgPSBhc3luYyBmdW5jdGlvbiBfZmluZE9uZSgpIHtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBpZiAodGhpcy4kdXNlUHJvamVjdGlvbikge1xuICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmZpZWxkcyA9IHRoaXMuX2ZpZWxkc0ZvckV4ZWMoKTtcbiAgfVxuXG4gIGRlYnVnKCdmaW5kT25lJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmZpbmRPbmUoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdHVlcyB0aGUgcXVlcnkgYXMgYSBjb3VudCgpIG9wZXJhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmNvdW50KCkud2hlcmUoJ2NvbG9yJywgJ2JsYWNrJykuZXhlYygpO1xuICpcbiAqICAgICBxdWVyeS5jb3VudCh7IGNvbG9yOiAnYmxhY2snIH0pXG4gKlxuICogICAgIGF3YWl0IHF1ZXJ5LmNvdW50KHsgY29sb3I6ICdibGFjaycgfSk7XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IHF1ZXJ5LndoZXJlKCdjb2xvcicsICdibGFjaycpLmNvdW50KCk7XG4gKiAgICAgY29uc29sZS5sb2coJ3RoZXJlIGFyZSAlZCBraXR0ZW5zJywgY291bnQpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY3JpdGVyaWFdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWdncmVnYXRpb24jQWdncmVnYXRpb24tQ291bnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oY3JpdGVyaWEpIHtcbiAgdGhpcy5vcCA9ICdjb3VudCc7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgaWYgKFF1ZXJ5LmNhbk1lcmdlKGNyaXRlcmlhKSkge1xuICAgIHRoaXMubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYGNvdW50YCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9jb3VudCA9IGFzeW5jIGZ1bmN0aW9uIF9jb3VudCgpIHtcbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zLFxuICAgICAgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgZGVidWcoJ2NvdW50JywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmNvdW50KGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgb3IgZXhlY3V0ZXMgYSBkaXN0aW5jdCgpIG9wZXJhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IGRpc3RpbmN0KGNyaXRlcmlhLCBmaWVsZClcbiAqICAgICBkaXN0aW5jdChjcml0ZXJpYSwgZmllbGQpXG4gKiAgICAgYXdhaXQgZGlzdGluY3QoZmllbGQpXG4gKiAgICAgZGlzdGluY3QoZmllbGQpXG4gKiAgICAgYXdhaXQgZGlzdGluY3QoKVxuICogICAgIGRpc3RpbmN0KClcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2NyaXRlcmlhXVxuICogQHBhcmFtIHtTdHJpbmd9IFtmaWVsZF1cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvQWdncmVnYXRpb24jQWdncmVnYXRpb24tRGlzdGluY3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRpc3RpbmN0ID0gZnVuY3Rpb24oY3JpdGVyaWEsIGZpZWxkKSB7XG4gIHRoaXMub3AgPSAnZGlzdGluY3QnO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmICghZmllbGQgJiYgdHlwZW9mIGNyaXRlcmlhID09PSAnc3RyaW5nJykge1xuICAgIGZpZWxkID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZpZWxkKSB7XG4gICAgdGhpcy5fZGlzdGluY3REb2MgPSBmaWVsZDtcbiAgfVxuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBkaXN0aW5jdGAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZGlzdGluY3QgPSBhc3luYyBmdW5jdGlvbiBfZGlzdGluY3QoKSB7XG4gIGlmICghdGhpcy5fZGlzdGluY3REb2MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIGZvciBgZGlzdGluY3RgIGhhcyBiZWVuIGRlY2xhcmVkJyk7XG4gIH1cblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnMsXG4gICAgICBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICBkZWJ1ZygnZGlzdGluY3QnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZGlzdGluY3QodGhpcy5fZGlzdGluY3REb2MsIGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGFuIGB1cGRhdGVNYW55KClgIG9wZXJhdGlvbi4gVGhpcyBmdW5jdGlvbiB3aWxsIHVwZGF0ZSBfYWxsXyBkb2N1bWVudHMgdGhhdCBtYXRjaFxuICogYGNyaXRlcmlhYCwgcmF0aGVyIHRoYW4ganVzdCB0aGUgZmlyc3Qgb25lLlxuICpcbiAqIF9BbGwgcGF0aHMgcGFzc2VkIHRoYXQgYXJlIG5vdCAkYXRvbWljIG9wZXJhdGlvbnMgd2lsbCBiZWNvbWUgJHNldCBvcHMuX1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVXBkYXRlIGV2ZXJ5IGRvY3VtZW50IHdob3NlIGB0aXRsZWAgY29udGFpbnMgJ3Rlc3QnXG4gKiAgICAgbXF1ZXJ5KCkudXBkYXRlTWFueSh7IHRpdGxlOiAvdGVzdC8gfSwgeyB5ZWFyOiAyMDE3IH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXSB0aGUgdXBkYXRlIGNvbW1hbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS51cGRhdGVNYW55ID0gZnVuY3Rpb24gdXBkYXRlTWFueShjcml0ZXJpYSwgZG9jLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZG9jID0gY3JpdGVyaWE7XG4gICAgY3JpdGVyaWEgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU1hbnknLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgdXBkYXRlTWFueWAgUXVlcnlcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fdXBkYXRlTWFueSA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX3VwZGF0ZUV4ZWModGhpcywgJ3VwZGF0ZU1hbnknKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGFuIGB1cGRhdGVPbmUoKWAgb3BlcmF0aW9uLiBUaGlzIGZ1bmN0aW9uIHdpbGwgX2Fsd2F5c18gdXBkYXRlIGp1c3Qgb25lIGRvY3VtZW50LFxuICogcmVnYXJkbGVzcyBvZiB0aGUgYG11bHRpYCBvcHRpb24uXG4gKlxuICogX0FsbCBwYXRocyBwYXNzZWQgdGhhdCBhcmUgbm90ICRhdG9taWMgb3BlcmF0aW9ucyB3aWxsIGJlY29tZSAkc2V0IG9wcy5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBVcGRhdGUgdGhlIGZpcnN0IGRvY3VtZW50IHdob3NlIGB0aXRsZWAgY29udGFpbnMgJ3Rlc3QnXG4gKiAgICAgbXF1ZXJ5KCkudXBkYXRlTWFueSh7IHRpdGxlOiAvdGVzdC8gfSwgeyB5ZWFyOiAyMDE3IH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjcml0ZXJpYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXSB0aGUgdXBkYXRlIGNvbW1hbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUoY3JpdGVyaWEsIGRvYywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGRvYyA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVPbmUnLCBjcml0ZXJpYSwgZG9jLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgdXBkYXRlT25lYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl91cGRhdGVPbmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF91cGRhdGVFeGVjKHRoaXMsICd1cGRhdGVPbmUnKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGFuIGByZXBsYWNlT25lKClgIG9wZXJhdGlvbi4gU2ltaWxhclxuICogdG8gYHVwZGF0ZU9uZSgpYCwgZXhjZXB0IGByZXBsYWNlT25lKClgIGlzIG5vdCBhbGxvd2VkIHRvIHVzZSBhdG9taWNcbiAqIG1vZGlmaWVycyAoYCRzZXRgLCBgJHB1c2hgLCBldGMuKS4gQ2FsbGluZyBgcmVwbGFjZU9uZSgpYCB3aWxsIGFsd2F5c1xuICogcmVwbGFjZSB0aGUgZXhpc3RpbmcgZG9jLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gUmVwbGFjZSB0aGUgZG9jdW1lbnQgd2l0aCBgX2lkYCAxIHdpdGggYHsgX2lkOiAxLCB5ZWFyOiAyMDE3IH1gXG4gKiAgICAgbXF1ZXJ5KCkucmVwbGFjZU9uZSh7IF9pZDogMSB9LCB7IHllYXI6IDIwMTcgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NyaXRlcmlhXVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnJlcGxhY2VPbmUgPSBmdW5jdGlvbiByZXBsYWNlT25lKGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBkb2MgPSBjcml0ZXJpYTtcbiAgICBjcml0ZXJpYSA9IG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB0aGlzLnNldE9wdGlvbnMoeyBvdmVyd3JpdGU6IHRydWUgfSk7XG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICdyZXBsYWNlT25lJywgY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYHJlcGxhY2VPbmVgIFF1ZXJ5XG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0c1xuICovXG5RdWVyeS5wcm90b3R5cGUuX3JlcGxhY2VPbmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF91cGRhdGVFeGVjKHRoaXMsICdyZXBsYWNlT25lJyk7XG59O1xuXG4vKiFcbiAqIEludGVybmFsIGhlbHBlciBmb3IgdXBkYXRlTWFueSwgdXBkYXRlT25lXG4gKi9cblxuZnVuY3Rpb24gX3VwZGF0ZShxdWVyeSwgb3AsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgcXVlcnkub3AgPSBvcDtcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgcXVlcnkubWVyZ2UoY3JpdGVyaWEpO1xuICB9XG5cbiAgaWYgKGRvYykge1xuICAgIHF1ZXJ5Ll9tZXJnZVVwZGF0ZShkb2MpO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgLy8geyBvdmVyd3JpdGU6IHRydWUgfVxuICAgIHF1ZXJ5LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gcXVlcnk7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciBkZS1kdXBsaWNhdGluZyBcInVwZGF0ZSpcIiBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5IFRoZSBRdWVyeSBPYmplY3QgKHJlcGxhY2VtZW50IGZvciBcInRoaXNcIilcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcCBUaGUgT3BlcmF0aW9uIHRvIGJlIGRvbmVcbiAqIEByZXR1cm5zIHRoZSByZXN1bHRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF91cGRhdGVFeGVjKHF1ZXJ5LCBvcCkge1xuICBjb25zdCBvcHRpb25zID0gcXVlcnkuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgY29uc3QgY3JpdGVyaWEgPSBxdWVyeS5fY29uZGl0aW9ucztcbiAgY29uc3QgZG9jID0gcXVlcnkuX3VwZGF0ZUZvckV4ZWMoKTtcblxuICBkZWJ1ZygndXBkYXRlJywgcXVlcnkuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpO1xuXG4gIHJldHVybiBxdWVyeS5fY29sbGVjdGlvbltvcF0oY3JpdGVyaWEsIGRvYywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGEgYGRlbGV0ZU9uZSgpYCBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBtcXVlcnkoY29sbGVjdGlvbikuZGVsZXRlT25lKHsgYXJ0aXN0OiAnQW5uZSBNdXJyYXknIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uKGNyaXRlcmlhKSB7XG4gIHRoaXMub3AgPSAnZGVsZXRlT25lJztcblxuICBpZiAoUXVlcnkuY2FuTWVyZ2UoY3JpdGVyaWEpKSB7XG4gICAgdGhpcy5tZXJnZShjcml0ZXJpYSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBgZGVsZXRlT25lYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9kZWxldGVPbmUgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIGRlbGV0ZSBvcHRpb25zLmp1c3RPbmU7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIGRlYnVnKCdkZWxldGVPbmUnLCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBjb25kcywgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZGVsZXRlT25lKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGEgYGRlbGV0ZU1hbnkoKWAgb3BlcmF0aW9uLiBBbHdheXMgZGVsZXRlc1xuICogX2V2ZXJ5XyBkb2N1bWVudCB0aGF0IG1hdGNoZXMgYGNyaXRlcmlhYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IG1xdWVyeShjb2xsZWN0aW9uKS5kZWxldGVNYW55KHsgYXJ0aXN0OiAnQW5uZSBNdXJyYXknIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtjcml0ZXJpYV0gbW9uZ29kYiBzZWxlY3RvclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRlbGV0ZU1hbnkgPSBmdW5jdGlvbihjcml0ZXJpYSkge1xuICB0aGlzLm9wID0gJ2RlbGV0ZU1hbnknO1xuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBkZWxldGVNYW55YCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9kZWxldGVNYW55ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICBkZWxldGUgb3B0aW9ucy5qdXN0T25lO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICBkZWJ1ZygnZGVsZXRlT25lJywgdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSwgY29uZHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmRlbGV0ZU1hbnkoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYSBtb25nb2RiIFtmaW5kQW5kTW9kaWZ5XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9maW5kQW5kTW9kaWZ5K0NvbW1hbmQpIHVwZGF0ZSBjb21tYW5kLlxuICpcbiAqIEZpbmRzIGEgbWF0Y2hpbmcgZG9jdW1lbnQsIHVwZGF0ZXMgaXQgYWNjb3JkaW5nIHRvIHRoZSBgdXBkYXRlYCBhcmcsIHBhc3NpbmcgYW55IGBvcHRpb25zYCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqICMjIyMgQXZhaWxhYmxlIG9wdGlvbnNcbiAqXG4gKiAtIGBuZXdgOiBib29sIC0gdHJ1ZSB0byByZXR1cm4gdGhlIG1vZGlmaWVkIGRvY3VtZW50IHJhdGhlciB0aGFuIHRoZSBvcmlnaW5hbC4gZGVmYXVsdHMgdG8gdHJ1ZVxuICogLSBgdXBzZXJ0YDogYm9vbCAtIGNyZWF0ZXMgdGhlIG9iamVjdCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBkZWZhdWx0cyB0byBmYWxzZS5cbiAqIC0gYHNvcnRgOiBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZVxuICpcbiAqICMjIyMgRXhhbXBsZXM6XG4gKlxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlLCBvcHRpb25zKSAvLyBleGVjdXRlc1xuICogICAgIHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlLCBvcHRpb25zKSAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlKSAvLyBleGVjdXRlc1xuICogICAgIHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlKSAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmRPbmVBbmRVcGRhdGUodXBkYXRlKSAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSh1cGRhdGUpICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0ZXNcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW3F1ZXJ5XVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAc2VlIG1vbmdvZGIgaHR0cDovL3d3dy5tb25nb2RiLm9yZy9kaXNwbGF5L0RPQ1MvZmluZEFuZE1vZGlmeStDb21tYW5kXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFVwZGF0ZSA9IGZ1bmN0aW9uKGNyaXRlcmlhLCBkb2MsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcCA9ICdmaW5kT25lQW5kVXBkYXRlJztcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGRvYyA9IGNyaXRlcmlhO1xuICAgIGNyaXRlcmlhID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjcml0ZXJpYSkpIHtcbiAgICB0aGlzLm1lcmdlKGNyaXRlcmlhKTtcbiAgfVxuXG4gIC8vIGFwcGx5IGRvY1xuICBpZiAoZG9jKSB7XG4gICAgdGhpcy5fbWVyZ2VVcGRhdGUoZG9jKTtcbiAgfVxuXG4gIG9wdGlvbnMgJiYgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBmaW5kT25lQW5kVXBkYXRlYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kVXBkYXRlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlRm9yRXhlYygpO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKGNvbmRzLCB1cGRhdGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYSBtb25nb2RiIFtmaW5kQW5kTW9kaWZ5XShodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9maW5kQW5kTW9kaWZ5K0NvbW1hbmQpIHJlbW92ZSBjb21tYW5kLlxuICpcbiAqIEZpbmRzIGEgbWF0Y2hpbmcgZG9jdW1lbnQsIHJlbW92ZXMgaXQsIHJldHVybmluZyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogIyMjIyBBdmFpbGFibGUgb3B0aW9uc1xuICpcbiAqIC0gYHNvcnRgOiBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZVxuICpcbiAqICMjIyMgRXhhbXBsZXM6XG4gKlxuICogICAgIGF3YWl0IEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMsIG9wdGlvbnMpIC8vIGV4ZWN1dGVzXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucywgb3B0aW9ucykgIC8vIHJldHVybiBRdWVyeVxuICogICAgIGF3YWl0IEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMpIC8vIGV4ZWN1dGVzXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucykgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIGF3YWl0IEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKCkgICAvLyBleGVjdXRlc1xuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKCkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZERlbGV0ZSgpICAgICAgICAgICAvLyBhbGlhcyBvZiAuZmluZE9uZUFuZFJlbW92ZSgpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwOi8vd3d3Lm1vbmdvZGIub3JnL2Rpc3BsYXkvRE9DUy9maW5kQW5kTW9kaWZ5K0NvbW1hbmRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmRSZW1vdmUgPSBRdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZERlbGV0ZSA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcCA9ICdmaW5kT25lQW5kUmVtb3ZlJztcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICAvLyBhcHBseSBjb25kaXRpb25zXG4gIGlmIChRdWVyeS5jYW5NZXJnZShjb25kaXRpb25zKSkge1xuICAgIHRoaXMubWVyZ2UoY29uZGl0aW9ucyk7XG4gIH1cblxuICAvLyBhcHBseSBvcHRpb25zXG4gIG9wdGlvbnMgJiYgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGBmaW5kT25lQW5kUmVtb3ZlYCBRdWVyeVxuICogQHJldHVybnMgdGhlIHJlc3VsdHNcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kUmVtb3ZlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZShjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEFkZCB0cmFjZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHF1ZXJ5IGlzIGV4ZWN1dGVkLlxuICogVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggKG1ldGhvZCwgcXVlcnlJbmZvLCBxdWVyeSkgYW5kXG4gKiBzaG91bGQgcmV0dXJuIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWRcbiAqIHdpdGggKGVyciwgcmVzdWx0LCBtaWxsaXMpIHdoZW4gdGhlIHF1ZXJ5IGlzIGNvbXBsZXRlLlxuICpcbiAqIHF1ZXJ5SW5mbyBpcyBhbiBvYmplY3QgY29udGFpbmluZzoge1xuICogICBjb2xsZWN0aW9uTmFtZTogPG5hbWUgb2YgdGhlIGNvbGxlY3Rpb24+LFxuICogICBjb25kaXRpb25zOiA8cXVlcnkgY3JpdGVyaWE+LFxuICogICBvcHRpb25zOiA8Y29tbWVudCwgZmllbGRzLCByZWFkUHJlZmVyZW5jZSwgZXRjPixcbiAqICAgZG9jOiBbZG9jdW1lbnQgdG8gdXBkYXRlLCBpZiBhcHBsaWNhYmxlXVxuICogfVxuICpcbiAqIE5PVEU6IERvZXMgbm90IHRyYWNlIHN0cmVhbSBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYWNlRnVuY3Rpb25cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5RdWVyeS5wcm90b3R5cGUuc2V0VHJhY2VGdW5jdGlvbiA9IGZ1bmN0aW9uKHRyYWNlRnVuY3Rpb24pIHtcbiAgdGhpcy5fdHJhY2VGdW5jdGlvbiA9IHRyYWNlRnVuY3Rpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnlcbiAqXG4gKiAjIyMjIEV4YW1wbGVzOlxuICpcbiAqICAgICBxdWVyeS5leGVjKCk7XG4gKiAgICAgYXdhaXQgcXVlcnkuZXhlYygpO1xuICogICAgIHF1ZXJ5LmV4ZWMoJ3VwZGF0ZScpO1xuICogICAgIGF3YWl0IHF1ZXJ5LmV4ZWMoJ2ZpbmQnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29wZXJhdGlvbl1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmV4ZWMgPSBhc3luYyBmdW5jdGlvbiBleGVjKG9wKSB7XG4gIGlmICh0eXBlb2Ygb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5vcCA9IG9wO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKHRoaXMub3AsICdNaXNzaW5nIHF1ZXJ5IHR5cGU6IChmaW5kLCBldGMpJyk7XG5cbiAgY29uc3QgZm5OYW1lID0gJ18nICsgdGhpcy5vcDtcblxuICAvLyBiZXR0ZXIgZXJyb3IsIGJlY2F1c2UgZGVmYXVsdCB3b3VsZCBsaXN0IGl0IGFzIFwidGhpc1tmbk5hbWVdIGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgaWYgKHR5cGVvZiB0aGlzW2ZuTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0aGlzWyR7Zm5OYW1lfV0gaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzW2ZuTmFtZV0oKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGVpdGhlciB0aGUgZG9jKHMpIG9yIHJlamVjdGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50aGVuID0gYXN5bmMgZnVuY3Rpb24ocmVzLCByZWopIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLnRoZW4ocmVzLCByZWopO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY3Vyc29yIGZvciB0aGUgZ2l2ZW4gYGZpbmRgIHF1ZXJ5LlxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgb3BlcmF0aW9uIGlzIG5vdCBhIGZpbmRcbiAqIEByZXR1cm5zIHtDdXJzb3J9IE1vbmdvREIgZHJpdmVyIGN1cnNvclxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jdXJzb3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCdmaW5kJyAhPSB0aGlzLm9wKVxuICAgIHRocm93IG5ldyBFcnJvcignY3Vyc29yKCkgaXMgb25seSBhdmFpbGFibGUgZm9yIGZpbmQnKTtcblxuICBjb25zdCBjb25kcyA9IHRoaXMuX2NvbmRpdGlvbnM7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIGlmICh0aGlzLiR1c2VQcm9qZWN0aW9uKSB7XG4gICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuZmllbGRzID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICB9XG5cbiAgZGVidWcoJ2N1cnNvcicsIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIGNvbmRzLCBvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5maW5kQ3Vyc29yKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBmaWVsZCBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ZWQgPSBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgcmV0dXJuICEhKHRoaXMuX2ZpZWxkcyAmJiBPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpLmxlbmd0aCA+IDApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGluY2x1c2l2ZSBmaWVsZCBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZS5cbiAqXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpIC8vIGZhbHNlXG4gKiAgICAgcXVlcnkuc2VsZWN0KCduYW1lJylcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCkgLy8gdHJ1ZVxuICogICAgIHF1ZXJ5LnNlbGVjdGVkRXhsdXNpdmVseSgpIC8vIGZhbHNlXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkSW5jbHVzaXZlbHkgPSBmdW5jdGlvbiBzZWxlY3RlZEluY2x1c2l2ZWx5KCkge1xuICBpZiAoIXRoaXMuX2ZpZWxkcykgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpO1xuICBpZiAoMCA9PT0ga2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICgwID09PSB0aGlzLl9maWVsZHNba2V5XSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLl9maWVsZHNba2V5XSAmJlxuICAgICAgICB0eXBlb2YgdGhpcy5fZmllbGRzW2tleV0gPT09ICdvYmplY3QnICYmXG4gICAgICAgIHRoaXMuX2ZpZWxkc1trZXldLiRtZXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZXhjbHVzaXZlIGZpZWxkIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlLlxuICpcbiAqICAgICBxdWVyeS5zZWxlY3RlZEV4bHVzaXZlbHkoKSAvLyBmYWxzZVxuICogICAgIHF1ZXJ5LnNlbGVjdCgnLW5hbWUnKVxuICogICAgIHF1ZXJ5LnNlbGVjdGVkRXhsdXNpdmVseSgpIC8vIHRydWVcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCkgLy8gZmFsc2VcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ZWRFeGNsdXNpdmVseSA9IGZ1bmN0aW9uIHNlbGVjdGVkRXhjbHVzaXZlbHkoKSB7XG4gIGlmICghdGhpcy5fZmllbGRzKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcyk7XG4gIGlmICgwID09PSBrZXlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgaWYgKDAgPT09IHRoaXMuX2ZpZWxkc1trZXldKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIGBkb2NgIHdpdGggdGhlIGN1cnJlbnQgdXBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9tZXJnZVVwZGF0ZSA9IGZ1bmN0aW9uKGRvYykge1xuICBpZiAoIXRoaXMuX3VwZGF0ZURvYykgdGhpcy5fdXBkYXRlRG9jID0ge307XG4gIGlmIChkb2MgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIGlmIChkb2MuX3VwZGF0ZURvYykge1xuICAgICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGVEb2MsIGRvYy5fdXBkYXRlRG9jKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGVEb2MsIGRvYyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9vcHRpb25zRm9yRXhlYyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gdXRpbHMuY2xvbmUodGhpcy5vcHRpb25zKTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmllbGRzIHNlbGVjdGlvbiBmb3IgdGhpcyBxdWVyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2ZpZWxkc0ZvckV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHV0aWxzLmNsb25lKHRoaXMuX2ZpZWxkcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiB1cGRhdGUgZG9jdW1lbnQgd2l0aCBjb3JyZWN0ZWQgJHNldCBvcGVyYXRpb25zLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fdXBkYXRlRm9yRXhlYyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB1cGRhdGUgPSB1dGlscy5jbG9uZSh0aGlzLl91cGRhdGVEb2MpO1xuICBjb25zdCBvcHMgPSB1dGlscy5rZXlzKHVwZGF0ZSk7XG4gIGNvbnN0IHJldCA9IHt9O1xuXG4gIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vdmVyd3JpdGUpIHtcbiAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCckJyAhPT0gb3BbMF0pIHtcbiAgICAgIC8vIGZpeCB1cCAkc2V0IHN1Z2FyXG4gICAgICBpZiAoIXJldC4kc2V0KSB7XG4gICAgICAgIGlmICh1cGRhdGUuJHNldCkge1xuICAgICAgICAgIHJldC4kc2V0ID0gdXBkYXRlLiRzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LiRzZXQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0LiRzZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICAgIGlmICghfm9wcy5pbmRleE9mKCckc2V0JykpIG9wcy5wdXNoKCckc2V0Jyk7XG4gICAgfSBlbHNlIGlmICgnJHNldCcgPT09IG9wKSB7XG4gICAgICBpZiAoIXJldC4kc2V0KSB7XG4gICAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jb21waWxlZFVwZGF0ZSA9IHJldDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogTWFrZSBzdXJlIF9wYXRoIGlzIHNldC5cbiAqXG4gKiBAcGFybWFtIHtTdHJpbmd9IG1ldGhvZFxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZW5zdXJlUGF0aCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIXRoaXMuX3BhdGgpIHtcbiAgICBjb25zdCBtc2cgPSBtZXRob2QgKyAnKCkgbXVzdCBiZSB1c2VkIGFmdGVyIHdoZXJlKCkgJ1xuICAgICAgICAgICAgICAgICAgICAgKyAnd2hlbiBjYWxsZWQgd2l0aCB0aGVzZSBhcmd1bWVudHMnO1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59O1xuXG4vKiFcbiAqIFBlcm1pc3Npb25zXG4gKi9cblxuUXVlcnkucGVybWlzc2lvbnMgPSByZXF1aXJlKCcuL3Blcm1pc3Npb25zJyk7XG5cblF1ZXJ5Ll9pc1Blcm1pdHRlZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgY29uc3QgZGVuaWVkID0gUXVlcnkucGVybWlzc2lvbnNbYl07XG4gIGlmICghZGVuaWVkKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHRydWUgIT09IGRlbmllZFthXTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgbGV0IGZhaWw7XG4gIGxldCB2YWxpZGF0b3I7XG5cbiAgaWYgKHVuZGVmaW5lZCA9PT0gYWN0aW9uKSB7XG5cbiAgICB2YWxpZGF0b3IgPSBRdWVyeS5wZXJtaXNzaW9uc1t0aGlzLm9wXTtcbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgdmFsaWRhdG9yKSByZXR1cm4gdHJ1ZTtcblxuICAgIGZhaWwgPSB2YWxpZGF0b3IodGhpcyk7XG5cbiAgfSBlbHNlIGlmICghUXVlcnkuX2lzUGVybWl0dGVkKGFjdGlvbiwgdGhpcy5vcCkpIHtcbiAgICBmYWlsID0gYWN0aW9uO1xuICB9XG5cbiAgaWYgKGZhaWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFpbCArICcgY2Fubm90IGJlIHVzZWQgd2l0aCAnICsgdGhpcy5vcCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgY29uZHNgIGNhbiBiZSBtZXJnZWQgdXNpbmcgYG1xdWVyeSgpLm1lcmdlKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cblF1ZXJ5LmNhbk1lcmdlID0gZnVuY3Rpb24oY29uZHMpIHtcbiAgcmV0dXJuIGNvbmRzIGluc3RhbmNlb2YgUXVlcnkgfHwgdXRpbHMuaXNPYmplY3QoY29uZHMpO1xufTtcblxuLyoqXG4gKiBTZXQgYSB0cmFjZSBmdW5jdGlvbiB0aGF0IHdpbGwgZ2V0IGNhbGxlZCB3aGVuZXZlciBhXG4gKiBxdWVyeSBpcyBleGVjdXRlZC5cbiAqXG4gKiBTZWUgYHNldFRyYWNlRnVuY3Rpb24oKWAgZm9yIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5RdWVyeS5zZXRHbG9iYWxUcmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24odHJhY2VGdW5jdGlvbikge1xuICBRdWVyeS50cmFjZUZ1bmN0aW9uID0gdHJhY2VGdW5jdGlvbjtcbn07XG5cbi8qIVxuICogRXhwb3J0cy5cbiAqL1xuXG5RdWVyeS51dGlscyA9IHV0aWxzO1xuUXVlcnkuZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblF1ZXJ5LkNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcblF1ZXJ5LkJhc2VDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFF1ZXJ5O1xuXG4vLyBUT0RPXG4vLyB0ZXN0IHV0aWxzXG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsInV0aWwiLCJ1dGlscyIsImRlYnVnIiwiUXVlcnkiLCJjcml0ZXJpYSIsIm9wdGlvbnMiLCJwcm90byIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwib3AiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJfY29uZGl0aW9ucyIsImNsb25lIiwiX2ZpZWxkcyIsIl91cGRhdGVEb2MiLCJfcGF0aCIsIl9kaXN0aW5jdERvYyIsIl9jb2xsZWN0aW9uIiwiX3RyYWNlRnVuY3Rpb24iLCJzZXRPcHRpb25zIiwiZmluZCIsIiR3aXRoaW5DbWQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInNldCIsInYiLCJ0b0NvbnN0cnVjdG9yIiwiQ3VzdG9tUXVlcnkiLCJjYWxsIiwiaW5oZXJpdHMiLCJwIiwiaXNPYmplY3QiLCJtZXRob2RzIiwia2V5cyIsIm1ldGhvZCIsImkiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJpc0FycmF5IiwiYXBwbHkiLCJjb2xsZWN0aW9uIiwiY29sbCIsIkNvbGxlY3Rpb24iLCJjb2xsYXRpb24iLCJ2YWx1ZSIsIiR3aGVyZSIsImpzIiwid2hlcmUiLCJhcmd1bWVudHMiLCJ0eXBlIiwibWVyZ2UiLCJUeXBlRXJyb3IiLCJlcXVhbHMiLCJ2YWwiLCJfZW5zdXJlUGF0aCIsInBhdGgiLCJlcSIsIm9yIiwiYXJyYXkiLCIkb3IiLCJwdXNoIiwibm9yIiwiJG5vciIsImFuZCIsIiRhbmQiLCJzcGxpdCIsImZvckVhY2giLCIkY29uZGl0aW9uYWwiLCJjb25kcyIsIm1vZCIsIiRtb2QiLCJleGlzdHMiLCIkZXhpc3RzIiwiZWxlbU1hdGNoIiwiZm4iLCIkZWxlbU1hdGNoIiwid2l0aGluIiwiX2dlb0NvbXBhcmlzb24iLCJib3giLCJwb2x5Z29uIiwiYXJlYSIsImNlbnRlciIsImNpcmNsZSIsImNvb3JkaW5hdGVzIiwiZ2VvbWV0cnkiLCIkYm94IiwiZnJvbSIsInNoaWZ0IiwiJHBvbHlnb24iLCJFcnJvciIsInNwaGVyaWNhbCIsIndLZXkiLCJyYWRpdXMiLCIkdW5pcXVlRG9jcyIsInVuaXF1ZSIsIm5lYXIiLCJtYXhEaXN0YW5jZSIsIiRtYXhEaXN0YW5jZSIsIm1pbkRpc3RhbmNlIiwiJG1pbkRpc3RhbmNlIiwiZm9ybWF0IiwiJGdlb21ldHJ5IiwiaW50ZXJzZWN0cyIsInNlbGVjdCIsImFyZyIsIl92YWxpZGF0ZSIsImZpZWxkcyIsImxlbiIsImlzQXJndW1lbnRzT2JqZWN0IiwiZmllbGQiLCJpbmNsdWRlIiwic3Vic3RyaW5nIiwic2xpY2UiLCJudW1LZXlzIiwibXlGaWVsZHMiLCIkc2xpY2UiLCJzb3J0IiwiX3B1c2hBcnIiLCJhc2NlbmQiLCJNYXAiLCJfcHVzaE1hcCIsIl92YWxpZFNvcnRWYWx1ZSIsImFzYyIsImFzY2VuZGluZyIsImRlc2MiLCJkZXNjZW5kaW5nIiwib3B0cyIsInMiLCIkbWV0YSIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwibWFwIiwia2V5IiwibWF4VGltZSIsIm1heFRpbWVNUyIsIm1zIiwiaGludCIsImsiLCJqIiwic2xhdmVPayIsInJlYWQiLCJzZXRSZWFkUHJlZmVyZW5jZSIsInByZWYiLCJkZXByZWNhdGlvbldhcm5pbmdJc3N1ZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJyZWFkUHJlZmVyZW5jZSIsInJlYWRQcmVmIiwicmVhZENvbmNlcm4iLCJyIiwibGV2ZWwiLCJ0YWlsYWJsZSIsIndyaXRlQ29uY2VybiIsInciLCJjb25jZXJuIiwid3RpbWVvdXQiLCJ3VGltZW91dCIsInNvdXJjZSIsImNhbk1lcmdlIiwibWVyZ2VDbG9uZSIsIl9maW5kIiwiX29wdGlvbnNGb3JFeGVjIiwiJHVzZVByb2plY3Rpb24iLCJwcm9qZWN0aW9uIiwiX2ZpZWxkc0ZvckV4ZWMiLCJjb2xsZWN0aW9uTmFtZSIsImN1cnNvciIsImZpbmRDdXJzb3IiLCJmaW5kT25lIiwiX2ZpbmRPbmUiLCJjb3VudCIsIl9jb3VudCIsImRpc3RpbmN0IiwiX2Rpc3RpbmN0IiwidXBkYXRlTWFueSIsImRvYyIsIl91cGRhdGUiLCJfdXBkYXRlTWFueSIsIl91cGRhdGVFeGVjIiwidXBkYXRlT25lIiwiX3VwZGF0ZU9uZSIsInJlcGxhY2VPbmUiLCJvdmVyd3JpdGUiLCJfcmVwbGFjZU9uZSIsInF1ZXJ5IiwiX21lcmdlVXBkYXRlIiwiX3VwZGF0ZUZvckV4ZWMiLCJkZWxldGVPbmUiLCJfZGVsZXRlT25lIiwianVzdE9uZSIsImRlbGV0ZU1hbnkiLCJfZGVsZXRlTWFueSIsImZpbmRPbmVBbmRVcGRhdGUiLCJfZmluZE9uZUFuZFVwZGF0ZSIsInVwZGF0ZSIsImZpbmRPbmVBbmRSZW1vdmUiLCJmaW5kT25lQW5kRGVsZXRlIiwiY29uZGl0aW9ucyIsIl9maW5kT25lQW5kUmVtb3ZlIiwic2V0VHJhY2VGdW5jdGlvbiIsInRyYWNlRnVuY3Rpb24iLCJleGVjIiwib2siLCJmbk5hbWUiLCJ0aGVuIiwicmVzIiwicmVqIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluY2x1c2l2ZWx5Iiwic2VsZWN0ZWRFeGNsdXNpdmVseSIsIm9wcyIsInJldCIsIiRzZXQiLCJpbmRleE9mIiwiX2NvbXBpbGVkVXBkYXRlIiwibXNnIiwicGVybWlzc2lvbnMiLCJfaXNQZXJtaXR0ZWQiLCJhIiwiYiIsImRlbmllZCIsImFjdGlvbiIsImZhaWwiLCJ2YWxpZGF0b3IiLCJzZXRHbG9iYWxUcmFjZUZ1bmN0aW9uIiwiZW52IiwiQmFzZUNvbGxlY3Rpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/mquery.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/permissions.js":
/*!************************************************!*\
  !*** ./node_modules/mquery/lib/permissions.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst denied = exports;\ndenied.distinct = function(self) {\n    if (self._fields && Object.keys(self._fields).length > 0) {\n        return \"field selection and slice\";\n    }\n    const keys = Object.keys(denied.distinct);\n    let err;\n    keys.every(function(option) {\n        if (self.options[option]) {\n            err = option;\n            return false;\n        }\n        return true;\n    });\n    return err;\n};\ndenied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.hint = denied.distinct.tailable = true;\n// aggregation integration\ndenied.findOneAndUpdate = denied.findOneAndRemove = function(self) {\n    const keys = Object.keys(denied.findOneAndUpdate);\n    let err;\n    keys.every(function(option) {\n        if (self.options[option]) {\n            err = option;\n            return false;\n        }\n        return true;\n    });\n    return err;\n};\ndenied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.tailable = true;\ndenied.count = function(self) {\n    if (self._fields && Object.keys(self._fields).length > 0) {\n        return \"field selection and slice\";\n    }\n    const keys = Object.keys(denied.count);\n    let err;\n    keys.every(function(option) {\n        if (self.options[option]) {\n            err = option;\n            return false;\n        }\n        return true;\n    });\n    return err;\n};\ndenied.count.slice = denied.count.batchSize = denied.count.tailable = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi9wZXJtaXNzaW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDO0FBRWZELE9BQU9FLFFBQVEsR0FBRyxTQUFTQyxJQUFJO0lBQzdCLElBQUlBLEtBQUtDLE9BQU8sSUFBSUMsT0FBT0MsSUFBSSxDQUFDSCxLQUFLQyxPQUFPLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ3hELE9BQU87SUFDVDtJQUVBLE1BQU1ELE9BQU9ELE9BQU9DLElBQUksQ0FBQ04sT0FBT0UsUUFBUTtJQUN4QyxJQUFJTTtJQUVKRixLQUFLRyxLQUFLLENBQUMsU0FBU0MsTUFBTTtRQUN4QixJQUFJUCxLQUFLUSxPQUFPLENBQUNELE9BQU8sRUFBRTtZQUN4QkYsTUFBTUU7WUFDTixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxPQUFPRjtBQUNUO0FBQ0FSLE9BQU9FLFFBQVEsQ0FBQ1UsTUFBTSxHQUN0QlosT0FBT0UsUUFBUSxDQUFDVyxLQUFLLEdBQ3JCYixPQUFPRSxRQUFRLENBQUNZLElBQUksR0FDcEJkLE9BQU9FLFFBQVEsQ0FBQ2EsS0FBSyxHQUNyQmYsT0FBT0UsUUFBUSxDQUFDYyxJQUFJLEdBQ3BCaEIsT0FBT0UsUUFBUSxDQUFDZSxTQUFTLEdBQ3pCakIsT0FBT0UsUUFBUSxDQUFDZ0IsSUFBSSxHQUNwQmxCLE9BQU9FLFFBQVEsQ0FBQ2lCLFFBQVEsR0FBRztBQUczQiwwQkFBMEI7QUFHMUJuQixPQUFPb0IsZ0JBQWdCLEdBQ3ZCcEIsT0FBT3FCLGdCQUFnQixHQUFHLFNBQVNsQixJQUFJO0lBQ3JDLE1BQU1HLE9BQU9ELE9BQU9DLElBQUksQ0FBQ04sT0FBT29CLGdCQUFnQjtJQUNoRCxJQUFJWjtJQUVKRixLQUFLRyxLQUFLLENBQUMsU0FBU0MsTUFBTTtRQUN4QixJQUFJUCxLQUFLUSxPQUFPLENBQUNELE9BQU8sRUFBRTtZQUN4QkYsTUFBTUU7WUFDTixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxPQUFPRjtBQUNUO0FBQ0FSLE9BQU9vQixnQkFBZ0IsQ0FBQ0wsS0FBSyxHQUM3QmYsT0FBT29CLGdCQUFnQixDQUFDSixJQUFJLEdBQzVCaEIsT0FBT29CLGdCQUFnQixDQUFDSCxTQUFTLEdBQ2pDakIsT0FBT29CLGdCQUFnQixDQUFDRCxRQUFRLEdBQUc7QUFHbkNuQixPQUFPc0IsS0FBSyxHQUFHLFNBQVNuQixJQUFJO0lBQzFCLElBQUlBLEtBQUtDLE9BQU8sSUFBSUMsT0FBT0MsSUFBSSxDQUFDSCxLQUFLQyxPQUFPLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ3hELE9BQU87SUFDVDtJQUVBLE1BQU1ELE9BQU9ELE9BQU9DLElBQUksQ0FBQ04sT0FBT3NCLEtBQUs7SUFDckMsSUFBSWQ7SUFFSkYsS0FBS0csS0FBSyxDQUFDLFNBQVNDLE1BQU07UUFDeEIsSUFBSVAsS0FBS1EsT0FBTyxDQUFDRCxPQUFPLEVBQUU7WUFDeEJGLE1BQU1FO1lBQ04sT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBRUEsT0FBT0Y7QUFDVDtBQUVBUixPQUFPc0IsS0FBSyxDQUFDVCxLQUFLLEdBQ2xCYixPQUFPc0IsS0FBSyxDQUFDTCxTQUFTLEdBQ3RCakIsT0FBT3NCLEtBQUssQ0FBQ0gsUUFBUSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmxvZy1hcHBsaWNhdGlvbi8uL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL3Blcm1pc3Npb25zLmpzPzMyYWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZW5pZWQgPSBleHBvcnRzO1xuXG5kZW5pZWQuZGlzdGluY3QgPSBmdW5jdGlvbihzZWxmKSB7XG4gIGlmIChzZWxmLl9maWVsZHMgJiYgT2JqZWN0LmtleXMoc2VsZi5fZmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdmaWVsZCBzZWxlY3Rpb24gYW5kIHNsaWNlJztcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZW5pZWQuZGlzdGluY3QpO1xuICBsZXQgZXJyO1xuXG4gIGtleXMuZXZlcnkoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgaWYgKHNlbGYub3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICBlcnIgPSBvcHRpb247XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gZXJyO1xufTtcbmRlbmllZC5kaXN0aW5jdC5zZWxlY3QgPVxuZGVuaWVkLmRpc3RpbmN0LnNsaWNlID1cbmRlbmllZC5kaXN0aW5jdC5zb3J0ID1cbmRlbmllZC5kaXN0aW5jdC5saW1pdCA9XG5kZW5pZWQuZGlzdGluY3Quc2tpcCA9XG5kZW5pZWQuZGlzdGluY3QuYmF0Y2hTaXplID1cbmRlbmllZC5kaXN0aW5jdC5oaW50ID1cbmRlbmllZC5kaXN0aW5jdC50YWlsYWJsZSA9IHRydWU7XG5cblxuLy8gYWdncmVnYXRpb24gaW50ZWdyYXRpb25cblxuXG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZSA9XG5kZW5pZWQuZmluZE9uZUFuZFJlbW92ZSA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlbmllZC5maW5kT25lQW5kVXBkYXRlKTtcbiAgbGV0IGVycjtcblxuICBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIGlmIChzZWxmLm9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgZXJyID0gb3B0aW9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZS5saW1pdCA9XG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZS5za2lwID1cbmRlbmllZC5maW5kT25lQW5kVXBkYXRlLmJhdGNoU2l6ZSA9XG5kZW5pZWQuZmluZE9uZUFuZFVwZGF0ZS50YWlsYWJsZSA9IHRydWU7XG5cblxuZGVuaWVkLmNvdW50ID0gZnVuY3Rpb24oc2VsZikge1xuICBpZiAoc2VsZi5fZmllbGRzICYmIE9iamVjdC5rZXlzKHNlbGYuX2ZpZWxkcykubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnZmllbGQgc2VsZWN0aW9uIGFuZCBzbGljZSc7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVuaWVkLmNvdW50KTtcbiAgbGV0IGVycjtcblxuICBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIGlmIChzZWxmLm9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgZXJyID0gb3B0aW9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbmRlbmllZC5jb3VudC5zbGljZSA9XG5kZW5pZWQuY291bnQuYmF0Y2hTaXplID1cbmRlbmllZC5jb3VudC50YWlsYWJsZSA9IHRydWU7XG4iXSwibmFtZXMiOlsiZGVuaWVkIiwiZXhwb3J0cyIsImRpc3RpbmN0Iiwic2VsZiIsIl9maWVsZHMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZXJyIiwiZXZlcnkiLCJvcHRpb24iLCJvcHRpb25zIiwic2VsZWN0Iiwic2xpY2UiLCJzb3J0IiwibGltaXQiLCJza2lwIiwiYmF0Y2hTaXplIiwiaGludCIsInRhaWxhYmxlIiwiZmluZE9uZUFuZFVwZGF0ZSIsImZpbmRPbmVBbmRSZW1vdmUiLCJjb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/permissions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mquery/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/mquery/lib/utils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*!\n * Module dependencies.\n */ const specialProperties = [\n    \"__proto__\",\n    \"constructor\",\n    \"prototype\"\n];\n/**\n * Clones objects\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */ const clone = exports.clone = function clone(obj, options) {\n    if (obj === undefined || obj === null) return obj;\n    if (Array.isArray(obj)) return exports.cloneArray(obj, options);\n    if (obj.constructor) {\n        if (/ObjectI[dD]$/.test(obj.constructor.name)) {\n            return \"function\" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.id);\n        }\n        if (obj.constructor.name === \"ReadPreference\") {\n            return new obj.constructor(obj.mode, clone(obj.tags, options));\n        }\n        if (\"Binary\" == obj._bsontype && obj.buffer && obj.value) {\n            return \"function\" == typeof obj.clone ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);\n        }\n        if (\"Date\" === obj.constructor.name || \"Function\" === obj.constructor.name) return new obj.constructor(+obj);\n        if (\"RegExp\" === obj.constructor.name) return new RegExp(obj);\n        if (\"Buffer\" === obj.constructor.name) return Buffer.from(obj);\n    }\n    if (isObject(obj)) return exports.cloneObject(obj, options);\n    if (obj.valueOf) return obj.valueOf();\n};\n/*!\n * ignore\n */ exports.cloneObject = function cloneObject(obj, options) {\n    const minimize = options && options.minimize, ret = {}, keys = Object.keys(obj), len = keys.length;\n    let hasKeys = false, val, k = \"\", i = 0;\n    for(i = 0; i < len; ++i){\n        k = keys[i];\n        // Not technically prototype pollution because this wouldn't merge properties\n        // onto `Object.prototype`, but avoid properties like __proto__ as a precaution.\n        if (specialProperties.indexOf(k) !== -1) {\n            continue;\n        }\n        val = clone(obj[k], options);\n        if (!minimize || \"undefined\" !== typeof val) {\n            hasKeys || (hasKeys = true);\n            ret[k] = val;\n        }\n    }\n    return minimize ? hasKeys && ret : ret;\n};\nexports.cloneArray = function cloneArray(arr, options) {\n    const ret = [], l = arr.length;\n    let i = 0;\n    for(; i < l; i++)ret.push(clone(arr[i], options));\n    return ret;\n};\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */ exports.merge = function merge(to, from) {\n    const keys = Object.keys(from);\n    for (const key of keys){\n        if (specialProperties.indexOf(key) !== -1) {\n            continue;\n        }\n        if (\"undefined\" === typeof to[key]) {\n            to[key] = from[key];\n        } else {\n            if (exports.isObject(from[key])) {\n                merge(to[key], from[key]);\n            } else {\n                to[key] = from[key];\n            }\n        }\n    }\n};\n/**\n * Same as merge but clones the assigned values.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */ exports.mergeClone = function mergeClone(to, from) {\n    const keys = Object.keys(from);\n    for (const key of keys){\n        if (specialProperties.indexOf(key) !== -1) {\n            continue;\n        }\n        if (\"undefined\" === typeof to[key]) {\n            to[key] = clone(from[key]);\n        } else {\n            if (exports.isObject(from[key])) {\n                mergeClone(to[key], from[key]);\n            } else {\n                to[key] = clone(from[key]);\n            }\n        }\n    }\n};\n/**\n * Read pref helper (mongo 2.2 drivers support this)\n *\n * Allows using aliases instead of full preference names:\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * @param {String} pref\n */ exports.readPref = function readPref(pref) {\n    switch(pref){\n        case \"p\":\n            pref = \"primary\";\n            break;\n        case \"pp\":\n            pref = \"primaryPreferred\";\n            break;\n        case \"s\":\n            pref = \"secondary\";\n            break;\n        case \"sp\":\n            pref = \"secondaryPreferred\";\n            break;\n        case \"n\":\n            pref = \"nearest\";\n            break;\n    }\n    return pref;\n};\n/**\n * Read Concern helper (mongo 3.2 drivers support this)\n *\n * Allows using string to specify read concern level:\n *\n *     local          3.2+\n *     available      3.6+\n *     majority       3.2+\n *     linearizable   3.4+\n *     snapshot       4.0+\n *\n * @param {String|Object} concern\n */ exports.readConcern = function readConcern(concern) {\n    if (\"string\" === typeof concern) {\n        switch(concern){\n            case \"l\":\n                concern = \"local\";\n                break;\n            case \"a\":\n                concern = \"available\";\n                break;\n            case \"m\":\n                concern = \"majority\";\n                break;\n            case \"lz\":\n                concern = \"linearizable\";\n                break;\n            case \"s\":\n                concern = \"snapshot\";\n                break;\n        }\n        concern = {\n            level: concern\n        };\n    }\n    return concern;\n};\n/**\n * Object.prototype.toString.call helper\n */ const _toString = Object.prototype.toString;\nexports.toString = function(arg) {\n    return _toString.call(arg);\n};\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n */ const isObject = exports.isObject = function(arg) {\n    return \"[object Object]\" == exports.toString(arg);\n};\n/**\n * Object.keys helper\n */ exports.keys = Object.keys;\n/**\n * Basic Object.create polyfill.\n * Only one argument is supported.\n *\n * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n */ exports.create = \"function\" == typeof Object.create ? Object.create : create;\nfunction create(proto) {\n    if (arguments.length > 1) {\n        throw new Error(\"Adding properties is not supported\");\n    }\n    function F() {}\n    F.prototype = proto;\n    return new F;\n}\n/**\n * inheritance\n */ exports.inherits = function(ctor, superCtor) {\n    ctor.prototype = exports.create(superCtor.prototype);\n    ctor.prototype.constructor = ctor;\n};\n/**\n * Check if this object is an arguments object\n *\n * @param {Any} v\n * @return {Boolean}\n */ exports.isArgumentsObject = function(v) {\n    return Object.prototype.toString.call(v) === \"[object Arguments]\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF1ZXJ5L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOztDQUVDLEdBRUQsTUFBTUEsb0JBQW9CO0lBQUM7SUFBYTtJQUFlO0NBQVk7QUFFbkU7Ozs7Ozs7Q0FPQyxHQUVELE1BQU1DLFFBQVFDLGFBQWEsR0FBRyxTQUFTRCxNQUFNRSxHQUFHLEVBQUVDLE9BQU87SUFDdkQsSUFBSUQsUUFBUUUsYUFBYUYsUUFBUSxNQUMvQixPQUFPQTtJQUVULElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0osTUFDaEIsT0FBT0QsUUFBUU0sVUFBVSxDQUFDTCxLQUFLQztJQUVqQyxJQUFJRCxJQUFJTSxXQUFXLEVBQUU7UUFDbkIsSUFBSSxlQUFlQyxJQUFJLENBQUNQLElBQUlNLFdBQVcsQ0FBQ0UsSUFBSSxHQUFHO1lBQzdDLE9BQU8sY0FBYyxPQUFPUixJQUFJRixLQUFLLEdBQ2pDRSxJQUFJRixLQUFLLEtBQ1QsSUFBSUUsSUFBSU0sV0FBVyxDQUFDTixJQUFJUyxFQUFFO1FBQ2hDO1FBRUEsSUFBSVQsSUFBSU0sV0FBVyxDQUFDRSxJQUFJLEtBQUssa0JBQWtCO1lBQzdDLE9BQU8sSUFBSVIsSUFBSU0sV0FBVyxDQUFDTixJQUFJVSxJQUFJLEVBQUVaLE1BQU1FLElBQUlXLElBQUksRUFBRVY7UUFDdkQ7UUFFQSxJQUFJLFlBQVlELElBQUlZLFNBQVMsSUFBSVosSUFBSWEsTUFBTSxJQUFJYixJQUFJYyxLQUFLLEVBQUU7WUFDeEQsT0FBTyxjQUFjLE9BQU9kLElBQUlGLEtBQUssR0FDakNFLElBQUlGLEtBQUssS0FDVCxJQUFJRSxJQUFJTSxXQUFXLENBQUNOLElBQUljLEtBQUssQ0FBQyxPQUFPZCxJQUFJZSxRQUFRO1FBQ3ZEO1FBRUEsSUFBSSxXQUFXZixJQUFJTSxXQUFXLENBQUNFLElBQUksSUFBSSxlQUFlUixJQUFJTSxXQUFXLENBQUNFLElBQUksRUFDeEUsT0FBTyxJQUFJUixJQUFJTSxXQUFXLENBQUMsQ0FB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QztBQUMvQztBQUVBOztDQUVDLEdBRURqRCxZQUFZLEdBQUcwQixPQUFPRCxJQUFJO0FBRTFCOzs7OztDQUtDLEdBRUR6QixjQUFjLEdBQUcsY0FBYyxPQUFPMEIsT0FBT3lCLE1BQU0sR0FDL0N6QixPQUFPeUIsTUFBTSxHQUNiQTtBQUVKLFNBQVNBLE9BQU9DLEtBQUs7SUFDbkIsSUFBSUMsVUFBVXpCLE1BQU0sR0FBRyxHQUFHO1FBQ3hCLE1BQU0sSUFBSTBCLE1BQU07SUFDbEI7SUFFQSxTQUFTQyxLQUFNO0lBQ2ZBLEVBQUVSLFNBQVMsR0FBR0s7SUFDZCxPQUFPLElBQUlHO0FBQ2I7QUFFQTs7Q0FFQyxHQUVEdkQsZ0JBQWdCLEdBQUcsU0FBU3lELElBQUksRUFBRUMsU0FBUztJQUN6Q0QsS0FBS1YsU0FBUyxHQUFHL0MsUUFBUW1ELE1BQU0sQ0FBQ08sVUFBVVgsU0FBUztJQUNuRFUsS0FBS1YsU0FBUyxDQUFDeEMsV0FBVyxHQUFHa0Q7QUFDL0I7QUFFQTs7Ozs7Q0FLQyxHQUVEekQseUJBQXlCLEdBQUcsU0FBUzRELENBQUM7SUFDcEMsT0FBT2xDLE9BQU9xQixTQUFTLENBQUNDLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDVSxPQUFPO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmxvZy1hcHBsaWNhdGlvbi8uL25vZGVfbW9kdWxlcy9tcXVlcnkvbGliL3V0aWxzLmpzPzk1NWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSBbJ19fcHJvdG9fXycsICdjb25zdHJ1Y3RvcicsICdwcm90b3R5cGUnXTtcblxuLyoqXG4gKiBDbG9uZXMgb2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBjbG9uZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNsb25lZCBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IGNsb25lID0gZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG9iaiwgb3B0aW9ucykge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKVxuICAgIHJldHVybiBvYmo7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICByZXR1cm4gZXhwb3J0cy5jbG9uZUFycmF5KG9iaiwgb3B0aW9ucyk7XG5cbiAgaWYgKG9iai5jb25zdHJ1Y3Rvcikge1xuICAgIGlmICgvT2JqZWN0SVtkRF0kLy50ZXN0KG9iai5jb25zdHJ1Y3Rvci5uYW1lKSkge1xuICAgICAgcmV0dXJuICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai5jbG9uZVxuICAgICAgICA/IG9iai5jbG9uZSgpXG4gICAgICAgIDogbmV3IG9iai5jb25zdHJ1Y3RvcihvYmouaWQpO1xuICAgIH1cblxuICAgIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ1JlYWRQcmVmZXJlbmNlJykge1xuICAgICAgcmV0dXJuIG5ldyBvYmouY29uc3RydWN0b3Iob2JqLm1vZGUsIGNsb25lKG9iai50YWdzLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgaWYgKCdCaW5hcnknID09IG9iai5fYnNvbnR5cGUgJiYgb2JqLmJ1ZmZlciAmJiBvYmoudmFsdWUpIHtcbiAgICAgIHJldHVybiAnZnVuY3Rpb24nID09IHR5cGVvZiBvYmouY2xvbmVcbiAgICAgICAgPyBvYmouY2xvbmUoKVxuICAgICAgICA6IG5ldyBvYmouY29uc3RydWN0b3Iob2JqLnZhbHVlKHRydWUpLCBvYmouc3ViX3R5cGUpO1xuICAgIH1cblxuICAgIGlmICgnRGF0ZScgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdGdW5jdGlvbicgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgcmV0dXJuIG5ldyBvYmouY29uc3RydWN0b3IoK29iaik7XG5cbiAgICBpZiAoJ1JlZ0V4cCcgPT09IG9iai5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob2JqKTtcblxuICAgIGlmICgnQnVmZmVyJyA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUpXG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20ob2JqKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChvYmopKVxuICAgIHJldHVybiBleHBvcnRzLmNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucyk7XG5cbiAgaWYgKG9iai52YWx1ZU9mKVxuICAgIHJldHVybiBvYmoudmFsdWVPZigpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmNsb25lT2JqZWN0ID0gZnVuY3Rpb24gY2xvbmVPYmplY3Qob2JqLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1pbmltaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLm1pbmltaXplLFxuICAgICAgcmV0ID0ge30sXG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMob2JqKSxcbiAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQgaGFzS2V5cyA9IGZhbHNlLFxuICAgICAgdmFsLFxuICAgICAgayA9ICcnLFxuICAgICAgaSA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgayA9IGtleXNbaV07XG4gICAgLy8gTm90IHRlY2huaWNhbGx5IHByb3RvdHlwZSBwb2xsdXRpb24gYmVjYXVzZSB0aGlzIHdvdWxkbid0IG1lcmdlIHByb3BlcnRpZXNcbiAgICAvLyBvbnRvIGBPYmplY3QucHJvdG90eXBlYCwgYnV0IGF2b2lkIHByb3BlcnRpZXMgbGlrZSBfX3Byb3RvX18gYXMgYSBwcmVjYXV0aW9uLlxuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5pbmRleE9mKGspICE9PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsID0gY2xvbmUob2JqW2tdLCBvcHRpb25zKTtcblxuICAgIGlmICghbWluaW1pemUgfHwgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgdmFsKSkge1xuICAgICAgaGFzS2V5cyB8fCAoaGFzS2V5cyA9IHRydWUpO1xuICAgICAgcmV0W2tdID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW5pbWl6ZVxuICAgID8gaGFzS2V5cyAmJiByZXRcbiAgICA6IHJldDtcbn07XG5cbmV4cG9ydHMuY2xvbmVBcnJheSA9IGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJldCA9IFtdLFxuICAgICAgbCA9IGFyci5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspXG4gICAgcmV0LnB1c2goY2xvbmUoYXJyW2ldLCBvcHRpb25zKSk7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE1lcmdlcyBgZnJvbWAgaW50byBgdG9gIHdpdGhvdXQgb3ZlcndyaXRpbmcgZXhpc3RpbmcgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodG8sIGZyb20pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRvW2tleV0pIHtcbiAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChleHBvcnRzLmlzT2JqZWN0KGZyb21ba2V5XSkpIHtcbiAgICAgICAgbWVyZ2UodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNhbWUgYXMgbWVyZ2UgYnV0IGNsb25lcyB0aGUgYXNzaWduZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubWVyZ2VDbG9uZSA9IGZ1bmN0aW9uIG1lcmdlQ2xvbmUodG8sIGZyb20pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRvW2tleV0pIHtcbiAgICAgIHRvW2tleV0gPSBjbG9uZShmcm9tW2tleV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXhwb3J0cy5pc09iamVjdChmcm9tW2tleV0pKSB7XG4gICAgICAgIG1lcmdlQ2xvbmUodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvW2tleV0gPSBjbG9uZShmcm9tW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZWFkIHByZWYgaGVscGVyIChtb25nbyAyLjIgZHJpdmVycyBzdXBwb3J0IHRoaXMpXG4gKlxuICogQWxsb3dzIHVzaW5nIGFsaWFzZXMgaW5zdGVhZCBvZiBmdWxsIHByZWZlcmVuY2UgbmFtZXM6XG4gKlxuICogICAgIHAgICBwcmltYXJ5XG4gKiAgICAgcHAgIHByaW1hcnlQcmVmZXJyZWRcbiAqICAgICBzICAgc2Vjb25kYXJ5XG4gKiAgICAgc3AgIHNlY29uZGFyeVByZWZlcnJlZFxuICogICAgIG4gICBuZWFyZXN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZcbiAqL1xuXG5leHBvcnRzLnJlYWRQcmVmID0gZnVuY3Rpb24gcmVhZFByZWYocHJlZikge1xuICBzd2l0Y2ggKHByZWYpIHtcbiAgICBjYXNlICdwJzpcbiAgICAgIHByZWYgPSAncHJpbWFyeSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcCc6XG4gICAgICBwcmVmID0gJ3ByaW1hcnlQcmVmZXJyZWQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncyc6XG4gICAgICBwcmVmID0gJ3NlY29uZGFyeSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzcCc6XG4gICAgICBwcmVmID0gJ3NlY29uZGFyeVByZWZlcnJlZCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICduJzpcbiAgICAgIHByZWYgPSAnbmVhcmVzdCc7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBwcmVmO1xufTtcblxuXG4vKipcbiAqIFJlYWQgQ29uY2VybiBoZWxwZXIgKG1vbmdvIDMuMiBkcml2ZXJzIHN1cHBvcnQgdGhpcylcbiAqXG4gKiBBbGxvd3MgdXNpbmcgc3RyaW5nIHRvIHNwZWNpZnkgcmVhZCBjb25jZXJuIGxldmVsOlxuICpcbiAqICAgICBsb2NhbCAgICAgICAgICAzLjIrXG4gKiAgICAgYXZhaWxhYmxlICAgICAgMy42K1xuICogICAgIG1ham9yaXR5ICAgICAgIDMuMitcbiAqICAgICBsaW5lYXJpemFibGUgICAzLjQrXG4gKiAgICAgc25hcHNob3QgICAgICAgNC4wK1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uY2VyblxuICovXG5cbmV4cG9ydHMucmVhZENvbmNlcm4gPSBmdW5jdGlvbiByZWFkQ29uY2Vybihjb25jZXJuKSB7XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGNvbmNlcm4pIHtcbiAgICBzd2l0Y2ggKGNvbmNlcm4pIHtcbiAgICAgIGNhc2UgJ2wnOlxuICAgICAgICBjb25jZXJuID0gJ2xvY2FsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgY29uY2VybiA9ICdhdmFpbGFibGUnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICBjb25jZXJuID0gJ21ham9yaXR5JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdseic6XG4gICAgICAgIGNvbmNlcm4gPSAnbGluZWFyaXphYmxlJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgY29uY2VybiA9ICdzbmFwc2hvdCc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25jZXJuID0geyBsZXZlbDogY29uY2VybiB9O1xuICB9XG4gIHJldHVybiBjb25jZXJuO1xufTtcblxuLyoqXG4gKiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwgaGVscGVyXG4gKi9cblxuY29uc3QgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmV4cG9ydHMudG9TdHJpbmcgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKGFyZyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYGFyZ2AgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ3xGdW5jdGlvbnxSZWdFeHB8YW55fSBhcmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuY29uc3QgaXNPYmplY3QgPSBleHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiAnW29iamVjdCBPYmplY3RdJyA9PSBleHBvcnRzLnRvU3RyaW5nKGFyZyk7XG59O1xuXG4vKipcbiAqIE9iamVjdC5rZXlzIGhlbHBlclxuICovXG5cbmV4cG9ydHMua2V5cyA9IE9iamVjdC5rZXlzO1xuXG4vKipcbiAqIEJhc2ljIE9iamVjdC5jcmVhdGUgcG9seWZpbGwuXG4gKiBPbmx5IG9uZSBhcmd1bWVudCBpcyBzdXBwb3J0ZWQuXG4gKlxuICogQmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXG4gKi9cblxuZXhwb3J0cy5jcmVhdGUgPSAnZnVuY3Rpb24nID09IHR5cGVvZiBPYmplY3QuY3JlYXRlXG4gID8gT2JqZWN0LmNyZWF0ZVxuICA6IGNyZWF0ZTtcblxuZnVuY3Rpb24gY3JlYXRlKHByb3RvKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWRkaW5nIHByb3BlcnRpZXMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gRigpIHsgfVxuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5cbi8qKlxuICogaW5oZXJpdGFuY2VcbiAqL1xuXG5leHBvcnRzLmluaGVyaXRzID0gZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3IucHJvdG90eXBlID0gZXhwb3J0cy5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSk7XG4gIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3Rvcjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgYW4gYXJndW1lbnRzIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7QW55fSB2XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcbiJdLCJuYW1lcyI6WyJzcGVjaWFsUHJvcGVydGllcyIsImNsb25lIiwiZXhwb3J0cyIsIm9iaiIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJBcnJheSIsImlzQXJyYXkiLCJjbG9uZUFycmF5IiwiY29uc3RydWN0b3IiLCJ0ZXN0IiwibmFtZSIsImlkIiwibW9kZSIsInRhZ3MiLCJfYnNvbnR5cGUiLCJidWZmZXIiLCJ2YWx1ZSIsInN1Yl90eXBlIiwiUmVnRXhwIiwiQnVmZmVyIiwiZnJvbSIsImlzT2JqZWN0IiwiY2xvbmVPYmplY3QiLCJ2YWx1ZU9mIiwibWluaW1pemUiLCJyZXQiLCJrZXlzIiwiT2JqZWN0IiwibGVuIiwibGVuZ3RoIiwiaGFzS2V5cyIsInZhbCIsImsiLCJpIiwiaW5kZXhPZiIsImFyciIsImwiLCJwdXNoIiwibWVyZ2UiLCJ0byIsImtleSIsIm1lcmdlQ2xvbmUiLCJyZWFkUHJlZiIsInByZWYiLCJyZWFkQ29uY2VybiIsImNvbmNlcm4iLCJsZXZlbCIsIl90b1N0cmluZyIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiYXJnIiwiY2FsbCIsImNyZWF0ZSIsInByb3RvIiwiYXJndW1lbnRzIiwiRXJyb3IiLCJGIiwiaW5oZXJpdHMiLCJjdG9yIiwic3VwZXJDdG9yIiwiaXNBcmd1bWVudHNPYmplY3QiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mquery/lib/utils.js\n");

/***/ })

};
;