/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mpath";
exports.ids = ["vendor-chunks/mpath"];
exports.modules = {

/***/ "(ssr)/./node_modules/mpath/index.js":
/*!*************************************!*\
  !*** ./node_modules/mpath/index.js ***!
  \*************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = exports = __webpack_require__(/*! ./lib */ \"(ssr)/./node_modules/mpath/lib/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXBhdGgvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHQSxVQUFVQyxtQkFBT0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Jsb2ctYXBwbGljYXRpb24vLi9ub2RlX21vZHVsZXMvbXBhdGgvaW5kZXguanM/MTQ1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mpath/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mpath/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/mpath/lib/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint strict:off */ /* eslint no-var: off */ /* eslint no-redeclare: off */ var stringToParts = __webpack_require__(/*! ./stringToParts */ \"(ssr)/./node_modules/mpath/lib/stringToParts.js\");\n// These properties are special and can open client libraries to security\n// issues\nvar ignoreProperties = [\n    \"__proto__\",\n    \"constructor\",\n    \"prototype\"\n];\n/**\n * Returns the value of object `o` at the given `path`.\n *\n * ####Example:\n *\n *     var obj = {\n *         comments: [\n *             { title: 'exciting!', _doc: { title: 'great!' }}\n *           , { title: 'number dos' }\n *         ]\n *     }\n *\n *     mpath.get('comments.0.title', o)         // 'exciting!'\n *     mpath.get('comments.0.title', o, '_doc') // 'great!'\n *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']\n *\n *     // summary\n *     mpath.get(path, o)\n *     mpath.get(path, o, special)\n *     mpath.get(path, o, map)\n *     mpath.get(path, o, special, map)\n *\n * @param {String} path\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.\n */ exports.get = function(path, o, special, map) {\n    var lookup;\n    if (\"function\" == typeof special) {\n        if (special.length < 2) {\n            map = special;\n            special = undefined;\n        } else {\n            lookup = special;\n            special = undefined;\n        }\n    }\n    map || (map = K);\n    var parts = \"string\" == typeof path ? stringToParts(path) : path;\n    if (!Array.isArray(parts)) {\n        throw new TypeError(\"Invalid `path`. Must be either string or array\");\n    }\n    var obj = o, part;\n    for(var i = 0; i < parts.length; ++i){\n        part = parts[i];\n        if (typeof parts[i] !== \"string\" && typeof parts[i] !== \"number\") {\n            throw new TypeError(\"Each segment of path to `get()` must be a string or number, got \" + typeof parts[i]);\n        }\n        if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n            // reading a property from the array items\n            var paths = parts.slice(i);\n            // Need to `concat()` to avoid `map()` calling a constructor of an array\n            // subclass\n            return [].concat(obj).map(function(item) {\n                return item ? exports.get(paths, item, special || lookup, map) : map(undefined);\n            });\n        }\n        if (lookup) {\n            obj = lookup(obj, part);\n        } else {\n            var _from = special && obj[special] ? obj[special] : obj;\n            obj = _from instanceof Map ? _from.get(part) : _from[part];\n        }\n        if (!obj) return map(obj);\n    }\n    return map(obj);\n};\n/**\n * Returns true if `in` returns true for every piece of the path\n *\n * @param {String} path\n * @param {Object} o\n */ exports.has = function(path, o) {\n    var parts = typeof path === \"string\" ? stringToParts(path) : path;\n    if (!Array.isArray(parts)) {\n        throw new TypeError(\"Invalid `path`. Must be either string or array\");\n    }\n    var len = parts.length;\n    var cur = o;\n    for(var i = 0; i < len; ++i){\n        if (typeof parts[i] !== \"string\" && typeof parts[i] !== \"number\") {\n            throw new TypeError(\"Each segment of path to `has()` must be a string or number, got \" + typeof parts[i]);\n        }\n        if (cur == null || typeof cur !== \"object\" || !(parts[i] in cur)) {\n            return false;\n        }\n        cur = cur[parts[i]];\n    }\n    return true;\n};\n/**\n * Deletes the last piece of `path`\n *\n * @param {String} path\n * @param {Object} o\n */ exports.unset = function(path, o) {\n    var parts = typeof path === \"string\" ? stringToParts(path) : path;\n    if (!Array.isArray(parts)) {\n        throw new TypeError(\"Invalid `path`. Must be either string or array\");\n    }\n    var len = parts.length;\n    var cur = o;\n    for(var i = 0; i < len; ++i){\n        if (cur == null || typeof cur !== \"object\" || !(parts[i] in cur)) {\n            return false;\n        }\n        if (typeof parts[i] !== \"string\" && typeof parts[i] !== \"number\") {\n            throw new TypeError(\"Each segment of path to `unset()` must be a string or number, got \" + typeof parts[i]);\n        }\n        // Disallow any updates to __proto__ or special properties.\n        if (ignoreProperties.indexOf(parts[i]) !== -1) {\n            return false;\n        }\n        if (i === len - 1) {\n            delete cur[parts[i]];\n            return true;\n        }\n        cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];\n    }\n    return true;\n};\n/**\n * Sets the `val` at the given `path` of object `o`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.\n */ exports.set = function(path, val, o, special, map, _copying) {\n    var lookup;\n    if (\"function\" == typeof special) {\n        if (special.length < 2) {\n            map = special;\n            special = undefined;\n        } else {\n            lookup = special;\n            special = undefined;\n        }\n    }\n    map || (map = K);\n    var parts = \"string\" == typeof path ? stringToParts(path) : path;\n    if (!Array.isArray(parts)) {\n        throw new TypeError(\"Invalid `path`. Must be either string or array\");\n    }\n    if (null == o) return;\n    for(var i = 0; i < parts.length; ++i){\n        if (typeof parts[i] !== \"string\" && typeof parts[i] !== \"number\") {\n            throw new TypeError(\"Each segment of path to `set()` must be a string or number, got \" + typeof parts[i]);\n        }\n        // Silently ignore any updates to `__proto__`, these are potentially\n        // dangerous if using mpath with unsanitized data.\n        if (ignoreProperties.indexOf(parts[i]) !== -1) {\n            return;\n        }\n    }\n    // the existance of $ in a path tells us if the user desires\n    // the copying of an array instead of setting each value of\n    // the array to the one by one to matching positions of the\n    // current array. Unless the user explicitly opted out by passing\n    // false, see Automattic/mongoose#6273\n    var copy = _copying || /\\$/.test(path) && _copying !== false, obj = o, part;\n    for(var i = 0, len = parts.length - 1; i < len; ++i){\n        part = parts[i];\n        if (\"$\" == part) {\n            if (i == len - 1) {\n                break;\n            } else {\n                continue;\n            }\n        }\n        if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n            var paths = parts.slice(i);\n            if (!copy && Array.isArray(val)) {\n                for(var j = 0; j < obj.length && j < val.length; ++j){\n                    // assignment of single values of array\n                    exports.set(paths, val[j], obj[j], special || lookup, map, copy);\n                }\n            } else {\n                for(var j = 0; j < obj.length; ++j){\n                    // assignment of entire value\n                    exports.set(paths, val, obj[j], special || lookup, map, copy);\n                }\n            }\n            return;\n        }\n        if (lookup) {\n            obj = lookup(obj, part);\n        } else {\n            var _to = special && obj[special] ? obj[special] : obj;\n            obj = _to instanceof Map ? _to.get(part) : _to[part];\n        }\n        if (!obj) return;\n    }\n    // process the last property of the path\n    part = parts[len];\n    // use the special property if exists\n    if (special && obj[special]) {\n        obj = obj[special];\n    }\n    // set the value on the last branch\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n        if (!copy && Array.isArray(val)) {\n            _setArray(obj, val, part, lookup, special, map);\n        } else {\n            for(var j = 0; j < obj.length; ++j){\n                var item = obj[j];\n                if (item) {\n                    if (lookup) {\n                        lookup(item, part, map(val));\n                    } else {\n                        if (item[special]) item = item[special];\n                        item[part] = map(val);\n                    }\n                }\n            }\n        }\n    } else {\n        if (lookup) {\n            lookup(obj, part, map(val));\n        } else if (obj instanceof Map) {\n            obj.set(part, map(val));\n        } else {\n            obj[part] = map(val);\n        }\n    }\n};\n/*!\n * Split a string path into components delimited by '.' or\n * '[\\d+]'\n *\n * #### Example:\n *     stringToParts('foo[0].bar.1'); // ['foo', '0', 'bar', '1']\n */ exports.stringToParts = stringToParts;\n/*!\n * Recursively set nested arrays\n */ function _setArray(obj, val, part, lookup, special, map) {\n    for(var item, j = 0; j < obj.length && j < val.length; ++j){\n        item = obj[j];\n        if (Array.isArray(item) && Array.isArray(val[j])) {\n            _setArray(item, val[j], part, lookup, special, map);\n        } else if (item) {\n            if (lookup) {\n                lookup(item, part, map(val[j]));\n            } else {\n                if (item[special]) item = item[special];\n                item[part] = map(val[j]);\n            }\n        }\n    }\n}\n/*!\n * Returns the value passed to it.\n */ function K(v) {\n    return v;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXBhdGgvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixHQUNyQixzQkFBc0IsR0FDdEIsNEJBQTRCLEdBRTVCLElBQUlBLGdCQUFnQkMsbUJBQU9BLENBQUM7QUFFNUIseUVBQXlFO0FBQ3pFLFNBQVM7QUFDVCxJQUFJQyxtQkFBbUI7SUFBQztJQUFhO0lBQWU7Q0FBWTtBQUVoRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQkMsR0FFREMsV0FBVyxHQUFHLFNBQVNFLElBQUksRUFBRUMsQ0FBQyxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDMUMsSUFBSUM7SUFFSixJQUFJLGNBQWMsT0FBT0YsU0FBUztRQUNoQyxJQUFJQSxRQUFRRyxNQUFNLEdBQUcsR0FBRztZQUN0QkYsTUFBTUQ7WUFDTkEsVUFBVUk7UUFDWixPQUFPO1lBQ0xGLFNBQVNGO1lBQ1RBLFVBQVVJO1FBQ1o7SUFDRjtJQUVBSCxPQUFRQSxDQUFBQSxNQUFNSSxDQUFBQTtJQUVkLElBQUlDLFFBQVEsWUFBWSxPQUFPUixPQUMzQkwsY0FBY0ssUUFDZEE7SUFFSixJQUFJLENBQUNTLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTtRQUN6QixNQUFNLElBQUlHLFVBQVU7SUFDdEI7SUFFQSxJQUFJQyxNQUFNWCxHQUNOWTtJQUVKLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixNQUFNSCxNQUFNLEVBQUUsRUFBRVMsRUFBRztRQUNyQ0QsT0FBT0wsS0FBSyxDQUFDTSxFQUFFO1FBQ2YsSUFBSSxPQUFPTixLQUFLLENBQUNNLEVBQUUsS0FBSyxZQUFZLE9BQU9OLEtBQUssQ0FBQ00sRUFBRSxLQUFLLFVBQVU7WUFDaEUsTUFBTSxJQUFJSCxVQUFVLHFFQUFxRSxPQUFPSCxLQUFLLENBQUNNLEVBQUU7UUFDMUc7UUFFQSxJQUFJTCxNQUFNQyxPQUFPLENBQUNFLFFBQVEsQ0FBQyxRQUFRRyxJQUFJLENBQUNGLE9BQU87WUFDN0MsMENBQTBD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RUFBRUYsT0FBTyxFQUFFQyxHQUFHO0lBQ3JELElBQUssSUFBSWdCLE1BQU1ZLElBQUksR0FBR0EsSUFBSW5CLElBQUlQLE1BQU0sSUFBSTBCLElBQUlILElBQUl2QixNQUFNLEVBQUUsRUFBRTBCLEVBQUc7UUFDM0RaLE9BQU9QLEdBQUcsQ0FBQ21CLEVBQUU7UUFDYixJQUFJdEIsTUFBTUMsT0FBTyxDQUFDUyxTQUFTVixNQUFNQyxPQUFPLENBQUNrQixHQUFHLENBQUNHLEVBQUUsR0FBRztZQUNoREUsVUFBVWQsTUFBTVMsR0FBRyxDQUFDRyxFQUFFLEVBQUVsQixNQUFNVCxRQUFRRixTQUFTQztRQUNqRCxPQUFPLElBQUlnQixNQUFNO1lBQ2YsSUFBSWYsUUFBUTtnQkFDVkEsT0FBT2UsTUFBTU4sTUFBTVYsSUFBSXlCLEdBQUcsQ0FBQ0csRUFBRTtZQUMvQixPQUFPO2dCQUNMLElBQUlaLElBQUksQ0FBQ2pCLFFBQVEsRUFBRWlCLE9BQU9BLElBQUksQ0FBQ2pCLFFBQVE7Z0JBQ3ZDaUIsSUFBSSxDQUFDTixLQUFLLEdBQUdWLElBQUl5QixHQUFHLENBQUNHLEVBQUU7WUFDekI7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUVELFNBQVN4QixFQUFFMkIsQ0FBQztJQUNWLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibG9nLWFwcGxpY2F0aW9uLy4vbm9kZV9tb2R1bGVzL21wYXRoL2xpYi9pbmRleC5qcz83ZGEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBzdHJpY3Q6b2ZmICovXG4vKiBlc2xpbnQgbm8tdmFyOiBvZmYgKi9cbi8qIGVzbGludCBuby1yZWRlY2xhcmU6IG9mZiAqL1xuXG52YXIgc3RyaW5nVG9QYXJ0cyA9IHJlcXVpcmUoJy4vc3RyaW5nVG9QYXJ0cycpO1xuXG4vLyBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBzcGVjaWFsIGFuZCBjYW4gb3BlbiBjbGllbnQgbGlicmFyaWVzIHRvIHNlY3VyaXR5XG4vLyBpc3N1ZXNcbnZhciBpZ25vcmVQcm9wZXJ0aWVzID0gWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ107XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2Ygb2JqZWN0IGBvYCBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqICMjIyNFeGFtcGxlOlxuICpcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICBjb21tZW50czogW1xuICogICAgICAgICAgICAgeyB0aXRsZTogJ2V4Y2l0aW5nIScsIF9kb2M6IHsgdGl0bGU6ICdncmVhdCEnIH19XG4gKiAgICAgICAgICAgLCB7IHRpdGxlOiAnbnVtYmVyIGRvcycgfVxuICogICAgICAgICBdXG4gKiAgICAgfVxuICpcbiAqICAgICBtcGF0aC5nZXQoJ2NvbW1lbnRzLjAudGl0bGUnLCBvKSAgICAgICAgIC8vICdleGNpdGluZyEnXG4gKiAgICAgbXBhdGguZ2V0KCdjb21tZW50cy4wLnRpdGxlJywgbywgJ19kb2MnKSAvLyAnZ3JlYXQhJ1xuICogICAgIG1wYXRoLmdldCgnY29tbWVudHMudGl0bGUnLCBvKSAgICAgICAgICAgLy8gWydleGNpdGluZyEnLCAnbnVtYmVyIGRvcyddXG4gKlxuICogICAgIC8vIHN1bW1hcnlcbiAqICAgICBtcGF0aC5nZXQocGF0aCwgbylcbiAqICAgICBtcGF0aC5nZXQocGF0aCwgbywgc3BlY2lhbClcbiAqICAgICBtcGF0aC5nZXQocGF0aCwgbywgbWFwKVxuICogICAgIG1wYXRoLmdldChwYXRoLCBvLCBzcGVjaWFsLCBtYXApXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NwZWNpYWxdIFdoZW4gdGhpcyBwcm9wZXJ0eSBuYW1lIGlzIHByZXNlbnQgb24gYW55IG9iamVjdCBpbiB0aGUgcGF0aCwgd2Fsa2luZyB3aWxsIGNvbnRpbnVlIG9uIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW21hcF0gT3B0aW9uYWwgZnVuY3Rpb24gd2hpY2ggcmVjZWl2ZXMgZWFjaCBpbmRpdmlkdWFsIGZvdW5kIHZhbHVlLiBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSBgbWFwYCBpcyB1c2VkIGluIHRoZSBvcmlnaW5hbCB2YWx1ZXMgcGxhY2UuXG4gKi9cblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihwYXRoLCBvLCBzcGVjaWFsLCBtYXApIHtcbiAgdmFyIGxvb2t1cDtcblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3BlY2lhbCkge1xuICAgIGlmIChzcGVjaWFsLmxlbmd0aCA8IDIpIHtcbiAgICAgIG1hcCA9IHNwZWNpYWw7XG4gICAgICBzcGVjaWFsID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb29rdXAgPSBzcGVjaWFsO1xuICAgICAgc3BlY2lhbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBtYXAgfHwgKG1hcCA9IEspO1xuXG4gIHZhciBwYXJ0cyA9ICdzdHJpbmcnID09IHR5cGVvZiBwYXRoXG4gICAgPyBzdHJpbmdUb1BhcnRzKHBhdGgpXG4gICAgOiBwYXRoO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJ0cykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGBwYXRoYC4gTXVzdCBiZSBlaXRoZXIgc3RyaW5nIG9yIGFycmF5Jyk7XG4gIH1cblxuICB2YXIgb2JqID0gbyxcbiAgICAgIHBhcnQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAodHlwZW9mIHBhcnRzW2ldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcGFydHNbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIHNlZ21lbnQgb2YgcGF0aCB0byBgZ2V0KClgIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLCBnb3QgJyArIHR5cGVvZiBwYXJ0c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSAmJiAhL15cXGQrJC8udGVzdChwYXJ0KSkge1xuICAgICAgLy8gcmVhZGluZyBhIHByb3BlcnR5IGZyb20gdGhlIGFycmF5IGl0ZW1zXG4gICAgICB2YXIgcGF0aHMgPSBwYXJ0cy5zbGljZShpKTtcblxuICAgICAgLy8gTmVlZCB0byBgY29uY2F0KClgIHRvIGF2b2lkIGBtYXAoKWAgY2FsbGluZyBhIGNvbnN0cnVjdG9yIG9mIGFuIGFycmF5XG4gICAgICAvLyBzdWJjbGFzc1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChvYmopLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgPyBleHBvcnRzLmdldChwYXRocywgaXRlbSwgc3BlY2lhbCB8fCBsb29rdXAsIG1hcClcbiAgICAgICAgICA6IG1hcCh1bmRlZmluZWQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxvb2t1cCkge1xuICAgICAgb2JqID0gbG9va3VwKG9iaiwgcGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZnJvbSA9IHNwZWNpYWwgJiYgb2JqW3NwZWNpYWxdID8gb2JqW3NwZWNpYWxdIDogb2JqO1xuICAgICAgb2JqID0gX2Zyb20gaW5zdGFuY2VvZiBNYXAgP1xuICAgICAgICBfZnJvbS5nZXQocGFydCkgOlxuICAgICAgICBfZnJvbVtwYXJ0XTtcbiAgICB9XG5cbiAgICBpZiAoIW9iaikgcmV0dXJuIG1hcChvYmopO1xuICB9XG5cbiAgcmV0dXJuIG1hcChvYmopO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYGluYCByZXR1cm5zIHRydWUgZm9yIGV2ZXJ5IHBpZWNlIG9mIHRoZSBwYXRoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvXG4gKi9cblxuZXhwb3J0cy5oYXMgPSBmdW5jdGlvbihwYXRoLCBvKSB7XG4gIHZhciBwYXJ0cyA9IHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyA/XG4gICAgc3RyaW5nVG9QYXJ0cyhwYXRoKSA6XG4gICAgcGF0aDtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocGFydHMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBgcGF0aGAuIE11c3QgYmUgZWl0aGVyIHN0cmluZyBvciBhcnJheScpO1xuICB9XG5cbiAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aDtcbiAgdmFyIGN1ciA9IG87XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIHBhcnRzW2ldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcGFydHNbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIHNlZ21lbnQgb2YgcGF0aCB0byBgaGFzKClgIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLCBnb3QgJyArIHR5cGVvZiBwYXJ0c1tpXSk7XG4gICAgfVxuICAgIGlmIChjdXIgPT0gbnVsbCB8fCB0eXBlb2YgY3VyICE9PSAnb2JqZWN0JyB8fCAhKHBhcnRzW2ldIGluIGN1cikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY3VyID0gY3VyW3BhcnRzW2ldXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIHRoZSBsYXN0IHBpZWNlIG9mIGBwYXRoYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICovXG5cbmV4cG9ydHMudW5zZXQgPSBmdW5jdGlvbihwYXRoLCBvKSB7XG4gIHZhciBwYXJ0cyA9IHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyA/XG4gICAgc3RyaW5nVG9QYXJ0cyhwYXRoKSA6XG4gICAgcGF0aDtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocGFydHMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBgcGF0aGAuIE11c3QgYmUgZWl0aGVyIHN0cmluZyBvciBhcnJheScpO1xuICB9XG5cbiAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aDtcbiAgdmFyIGN1ciA9IG87XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoY3VyID09IG51bGwgfHwgdHlwZW9mIGN1ciAhPT0gJ29iamVjdCcgfHwgIShwYXJ0c1tpXSBpbiBjdXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFydHNbaV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwYXJ0c1tpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggc2VnbWVudCBvZiBwYXRoIHRvIGB1bnNldCgpYCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlciwgZ290ICcgKyB0eXBlb2YgcGFydHNbaV0pO1xuICAgIH1cbiAgICAvLyBEaXNhbGxvdyBhbnkgdXBkYXRlcyB0byBfX3Byb3RvX18gb3Igc3BlY2lhbCBwcm9wZXJ0aWVzLlxuICAgIGlmIChpZ25vcmVQcm9wZXJ0aWVzLmluZGV4T2YocGFydHNbaV0pICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gbGVuIC0gMSkge1xuICAgICAgZGVsZXRlIGN1cltwYXJ0c1tpXV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY3VyID0gY3VyIGluc3RhbmNlb2YgTWFwID8gY3VyLmdldChwYXJ0c1tpXSkgOiBjdXJbcGFydHNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGB2YWxgIGF0IHRoZSBnaXZlbiBgcGF0aGAgb2Ygb2JqZWN0IGBvYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtBbnl0aGluZ30gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICogQHBhcmFtIHtTdHJpbmd9IFtzcGVjaWFsXSBXaGVuIHRoaXMgcHJvcGVydHkgbmFtZSBpcyBwcmVzZW50IG9uIGFueSBvYmplY3QgaW4gdGhlIHBhdGgsIHdhbGtpbmcgd2lsbCBjb250aW51ZSBvbiB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFttYXBdIE9wdGlvbmFsIGZ1bmN0aW9uIHdoaWNoIGlzIHBhc3NlZCBlYWNoIGluZGl2aWR1YWwgdmFsdWUgYmVmb3JlIHNldHRpbmcgaXQuIFRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIGBtYXBgIGlzIHVzZWQgaW4gdGhlIG9yaWdpbmFsIHZhbHVlcyBwbGFjZS5cbiAqL1xuXG5leHBvcnRzLnNldCA9IGZ1bmN0aW9uKHBhdGgsIHZhbCwgbywgc3BlY2lhbCwgbWFwLCBfY29weWluZykge1xuICB2YXIgbG9va3VwO1xuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBzcGVjaWFsKSB7XG4gICAgaWYgKHNwZWNpYWwubGVuZ3RoIDwgMikge1xuICAgICAgbWFwID0gc3BlY2lhbDtcbiAgICAgIHNwZWNpYWwgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvb2t1cCA9IHNwZWNpYWw7XG4gICAgICBzcGVjaWFsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIG1hcCB8fCAobWFwID0gSyk7XG5cbiAgdmFyIHBhcnRzID0gJ3N0cmluZycgPT0gdHlwZW9mIHBhdGhcbiAgICA/IHN0cmluZ1RvUGFydHMocGF0aClcbiAgICA6IHBhdGg7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnRzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYHBhdGhgLiBNdXN0IGJlIGVpdGhlciBzdHJpbmcgb3IgYXJyYXknKTtcbiAgfVxuXG4gIGlmIChudWxsID09IG8pIHJldHVybjtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJ0c1tpXSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHBhcnRzW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBzZWdtZW50IG9mIHBhdGggdG8gYHNldCgpYCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlciwgZ290ICcgKyB0eXBlb2YgcGFydHNbaV0pO1xuICAgIH1cbiAgICAvLyBTaWxlbnRseSBpZ25vcmUgYW55IHVwZGF0ZXMgdG8gYF9fcHJvdG9fX2AsIHRoZXNlIGFyZSBwb3RlbnRpYWxseVxuICAgIC8vIGRhbmdlcm91cyBpZiB1c2luZyBtcGF0aCB3aXRoIHVuc2FuaXRpemVkIGRhdGEuXG4gICAgaWYgKGlnbm9yZVByb3BlcnRpZXMuaW5kZXhPZihwYXJ0c1tpXSkgIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIGV4aXN0YW5jZSBvZiAkIGluIGEgcGF0aCB0ZWxscyB1cyBpZiB0aGUgdXNlciBkZXNpcmVzXG4gIC8vIHRoZSBjb3B5aW5nIG9mIGFuIGFycmF5IGluc3RlYWQgb2Ygc2V0dGluZyBlYWNoIHZhbHVlIG9mXG4gIC8vIHRoZSBhcnJheSB0byB0aGUgb25lIGJ5IG9uZSB0byBtYXRjaGluZyBwb3NpdGlvbnMgb2YgdGhlXG4gIC8vIGN1cnJlbnQgYXJyYXkuIFVubGVzcyB0aGUgdXNlciBleHBsaWNpdGx5IG9wdGVkIG91dCBieSBwYXNzaW5nXG4gIC8vIGZhbHNlLCBzZWUgQXV0b21hdHRpYy9tb25nb29zZSM2MjczXG4gIHZhciBjb3B5ID0gX2NvcHlpbmcgfHwgKC9cXCQvLnRlc3QocGF0aCkgJiYgX2NvcHlpbmcgIT09IGZhbHNlKSxcbiAgICAgIG9iaiA9IG8sXG4gICAgICBwYXJ0O1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGggLSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICBpZiAoJyQnID09IHBhcnQpIHtcbiAgICAgIGlmIChpID09IGxlbiAtIDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmICEvXlxcZCskLy50ZXN0KHBhcnQpKSB7XG4gICAgICB2YXIgcGF0aHMgPSBwYXJ0cy5zbGljZShpKTtcbiAgICAgIGlmICghY29weSAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoubGVuZ3RoICYmIGogPCB2YWwubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAvLyBhc3NpZ25tZW50IG9mIHNpbmdsZSB2YWx1ZXMgb2YgYXJyYXlcbiAgICAgICAgICBleHBvcnRzLnNldChwYXRocywgdmFsW2pdLCBvYmpbal0sIHNwZWNpYWwgfHwgbG9va3VwLCBtYXAsIGNvcHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICAgIC8vIGFzc2lnbm1lbnQgb2YgZW50aXJlIHZhbHVlXG4gICAgICAgICAgZXhwb3J0cy5zZXQocGF0aHMsIHZhbCwgb2JqW2pdLCBzcGVjaWFsIHx8IGxvb2t1cCwgbWFwLCBjb3B5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsb29rdXApIHtcbiAgICAgIG9iaiA9IGxvb2t1cChvYmosIHBhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3RvID0gc3BlY2lhbCAmJiBvYmpbc3BlY2lhbF0gPyBvYmpbc3BlY2lhbF0gOiBvYmo7XG4gICAgICBvYmogPSBfdG8gaW5zdGFuY2VvZiBNYXAgP1xuICAgICAgICBfdG8uZ2V0KHBhcnQpIDpcbiAgICAgICAgX3RvW3BhcnRdO1xuICAgIH1cblxuICAgIGlmICghb2JqKSByZXR1cm47XG4gIH1cblxuICAvLyBwcm9jZXNzIHRoZSBsYXN0IHByb3BlcnR5IG9mIHRoZSBwYXRoXG5cbiAgcGFydCA9IHBhcnRzW2xlbl07XG5cbiAgLy8gdXNlIHRoZSBzcGVjaWFsIHByb3BlcnR5IGlmIGV4aXN0c1xuICBpZiAoc3BlY2lhbCAmJiBvYmpbc3BlY2lhbF0pIHtcbiAgICBvYmogPSBvYmpbc3BlY2lhbF07XG4gIH1cblxuICAvLyBzZXQgdGhlIHZhbHVlIG9uIHRoZSBsYXN0IGJyYW5jaFxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmICEvXlxcZCskLy50ZXN0KHBhcnQpKSB7XG4gICAgaWYgKCFjb3B5ICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgX3NldEFycmF5KG9iaiwgdmFsLCBwYXJ0LCBsb29rdXAsIHNwZWNpYWwsIG1hcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBpdGVtID0gb2JqW2pdO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIGlmIChsb29rdXApIHtcbiAgICAgICAgICAgIGxvb2t1cChpdGVtLCBwYXJ0LCBtYXAodmFsKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpdGVtW3NwZWNpYWxdKSBpdGVtID0gaXRlbVtzcGVjaWFsXTtcbiAgICAgICAgICAgIGl0ZW1bcGFydF0gPSBtYXAodmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxvb2t1cCkge1xuICAgICAgbG9va3VwKG9iaiwgcGFydCwgbWFwKHZhbCkpO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBvYmouc2V0KHBhcnQsIG1hcCh2YWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW3BhcnRdID0gbWFwKHZhbCk7XG4gICAgfVxuICB9XG59O1xuXG4vKiFcbiAqIFNwbGl0IGEgc3RyaW5nIHBhdGggaW50byBjb21wb25lbnRzIGRlbGltaXRlZCBieSAnLicgb3JcbiAqICdbXFxkK10nXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogICAgIHN0cmluZ1RvUGFydHMoJ2Zvb1swXS5iYXIuMScpOyAvLyBbJ2ZvbycsICcwJywgJ2JhcicsICcxJ11cbiAqL1xuXG5leHBvcnRzLnN0cmluZ1RvUGFydHMgPSBzdHJpbmdUb1BhcnRzO1xuXG4vKiFcbiAqIFJlY3Vyc2l2ZWx5IHNldCBuZXN0ZWQgYXJyYXlzXG4gKi9cblxuZnVuY3Rpb24gX3NldEFycmF5KG9iaiwgdmFsLCBwYXJ0LCBsb29rdXAsIHNwZWNpYWwsIG1hcCkge1xuICBmb3IgKHZhciBpdGVtLCBqID0gMDsgaiA8IG9iai5sZW5ndGggJiYgaiA8IHZhbC5sZW5ndGg7ICsraikge1xuICAgIGl0ZW0gPSBvYmpbal07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgJiYgQXJyYXkuaXNBcnJheSh2YWxbal0pKSB7XG4gICAgICBfc2V0QXJyYXkoaXRlbSwgdmFsW2pdLCBwYXJ0LCBsb29rdXAsIHNwZWNpYWwsIG1hcCk7XG4gICAgfSBlbHNlIGlmIChpdGVtKSB7XG4gICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgIGxvb2t1cChpdGVtLCBwYXJ0LCBtYXAodmFsW2pdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbVtzcGVjaWFsXSkgaXRlbSA9IGl0ZW1bc3BlY2lhbF07XG4gICAgICAgIGl0ZW1bcGFydF0gPSBtYXAodmFsW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBwYXNzZWQgdG8gaXQuXG4gKi9cblxuZnVuY3Rpb24gSyh2KSB7XG4gIHJldHVybiB2O1xufVxuIl0sIm5hbWVzIjpbInN0cmluZ1RvUGFydHMiLCJyZXF1aXJlIiwiaWdub3JlUHJvcGVydGllcyIsImV4cG9ydHMiLCJnZXQiLCJwYXRoIiwibyIsInNwZWNpYWwiLCJtYXAiLCJsb29rdXAiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJLIiwicGFydHMiLCJBcnJheSIsImlzQXJyYXkiLCJUeXBlRXJyb3IiLCJvYmoiLCJwYXJ0IiwiaSIsInRlc3QiLCJwYXRocyIsInNsaWNlIiwiY29uY2F0IiwiaXRlbSIsIl9mcm9tIiwiTWFwIiwiaGFzIiwibGVuIiwiY3VyIiwidW5zZXQiLCJpbmRleE9mIiwic2V0IiwidmFsIiwiX2NvcHlpbmciLCJjb3B5IiwiaiIsIl90byIsIl9zZXRBcnJheSIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mpath/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mpath/lib/stringToParts.js":
/*!*************************************************!*\
  !*** ./node_modules/mpath/lib/stringToParts.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function stringToParts(str) {\n    const result = [];\n    let curPropertyName = \"\";\n    let state = \"DEFAULT\";\n    for(let i = 0; i < str.length; ++i){\n        // Fall back to treating as property name rather than bracket notation if\n        // square brackets contains something other than a number.\n        if (state === \"IN_SQUARE_BRACKETS\" && !/\\d/.test(str[i]) && str[i] !== \"]\") {\n            state = \"DEFAULT\";\n            curPropertyName = result[result.length - 1] + \"[\" + curPropertyName;\n            result.splice(result.length - 1, 1);\n        }\n        if (str[i] === \"[\") {\n            if (state !== \"IMMEDIATELY_AFTER_SQUARE_BRACKETS\") {\n                result.push(curPropertyName);\n                curPropertyName = \"\";\n            }\n            state = \"IN_SQUARE_BRACKETS\";\n        } else if (str[i] === \"]\") {\n            if (state === \"IN_SQUARE_BRACKETS\") {\n                state = \"IMMEDIATELY_AFTER_SQUARE_BRACKETS\";\n                result.push(curPropertyName);\n                curPropertyName = \"\";\n            } else {\n                state = \"DEFAULT\";\n                curPropertyName += str[i];\n            }\n        } else if (str[i] === \".\") {\n            if (state !== \"IMMEDIATELY_AFTER_SQUARE_BRACKETS\") {\n                result.push(curPropertyName);\n                curPropertyName = \"\";\n            }\n            state = \"DEFAULT\";\n        } else {\n            curPropertyName += str[i];\n        }\n    }\n    if (state !== \"IMMEDIATELY_AFTER_SQUARE_BRACKETS\") {\n        result.push(curPropertyName);\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXBhdGgvbGliL3N0cmluZ1RvUGFydHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGNBQWNDLEdBQUc7SUFDekMsTUFBTUMsU0FBUyxFQUFFO0lBRWpCLElBQUlDLGtCQUFrQjtJQUN0QixJQUFJQyxRQUFRO0lBQ1osSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLElBQUlLLE1BQU0sRUFBRSxFQUFFRCxFQUFHO1FBQ25DLHlFQUF5RTtRQUN6RSwwREFBMEQ7UUFDMUQsSUFBSUQsVUFBVSx3QkFBd0IsQ0FBQyxLQUFLRyxJQUFJLENBQUNOLEdBQUcsQ0FBQ0ksRUFBRSxLQUFLSixHQUFHLENBQUNJLEVBQUUsS0FBSyxLQUFLO1lBQzFFRCxRQUFRO1lBQ1JELGtCQUFrQkQsTUFBTSxDQUFDQSxPQUFPSSxNQUFNLEdBQUcsRUFBRSxHQUFHLE1BQU1IO1lBQ3BERCxPQUFPTSxNQUFNLENBQUNOLE9BQU9JLE1BQU0sR0FBRyxHQUFHO1FBQ25DO1FBRUEsSUFBSUwsR0FBRyxDQUFDSSxFQUFFLEtBQUssS0FBSztZQUNsQixJQUFJRCxVQUFVLHFDQUFxQztnQkFDakRGLE9BQU9PLElBQUksQ0FBQ047Z0JBQ1pBLGtCQUFrQjtZQUNwQjtZQUNBQyxRQUFRO1FBQ1YsT0FBTyxJQUFJSCxHQUFHLENBQUNJLEVBQUUsS0FBSyxLQUFLO1lBQ3pCLElBQUlELFVBQVUsc0JBQXNCO2dCQUNsQ0EsUUFBUTtnQkFDUkYsT0FBT08sSUFBSSxDQUFDTjtnQkFDWkEsa0JBQWtCO1lBQ3BCLE9BQU87Z0JBQ0xDLFFBQVE7Z0JBQ1JELG1CQUFtQkYsR0FBRyxDQUFDSSxFQUFFO1lBQzNCO1FBQ0YsT0FBTyxJQUFJSixHQUFHLENBQUNJLEVBQUUsS0FBSyxLQUFLO1lBQ3pCLElBQUlELFVBQVUscUNBQXFDO2dCQUNqREYsT0FBT08sSUFBSSxDQUFDTjtnQkFDWkEsa0JBQWtCO1lBQ3BCO1lBQ0FDLFFBQVE7UUFDVixPQUFPO1lBQ0xELG1CQUFtQkYsR0FBRyxDQUFDSSxFQUFFO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJRCxVQUFVLHFDQUFxQztRQUNqREYsT0FBT08sSUFBSSxDQUFDTjtJQUNkO0lBRUEsT0FBT0Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2Jsb2ctYXBwbGljYXRpb24vLi9ub2RlX21vZHVsZXMvbXBhdGgvbGliL3N0cmluZ1RvUGFydHMuanM/YmU4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5nVG9QYXJ0cyhzdHIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgbGV0IGN1clByb3BlcnR5TmFtZSA9ICcnO1xuICBsZXQgc3RhdGUgPSAnREVGQVVMVCc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIHRyZWF0aW5nIGFzIHByb3BlcnR5IG5hbWUgcmF0aGVyIHRoYW4gYnJhY2tldCBub3RhdGlvbiBpZlxuICAgIC8vIHNxdWFyZSBicmFja2V0cyBjb250YWlucyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIG51bWJlci5cbiAgICBpZiAoc3RhdGUgPT09ICdJTl9TUVVBUkVfQlJBQ0tFVFMnICYmICEvXFxkLy50ZXN0KHN0cltpXSkgJiYgc3RyW2ldICE9PSAnXScpIHtcbiAgICAgIHN0YXRlID0gJ0RFRkFVTFQnO1xuICAgICAgY3VyUHJvcGVydHlOYW1lID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSArICdbJyArIGN1clByb3BlcnR5TmFtZTtcbiAgICAgIHJlc3VsdC5zcGxpY2UocmVzdWx0Lmxlbmd0aCAtIDEsIDEpO1xuICAgIH1cblxuICAgIGlmIChzdHJbaV0gPT09ICdbJykge1xuICAgICAgaWYgKHN0YXRlICE9PSAnSU1NRURJQVRFTFlfQUZURVJfU1FVQVJFX0JSQUNLRVRTJykge1xuICAgICAgICByZXN1bHQucHVzaChjdXJQcm9wZXJ0eU5hbWUpO1xuICAgICAgICBjdXJQcm9wZXJ0eU5hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIHN0YXRlID0gJ0lOX1NRVUFSRV9CUkFDS0VUUyc7XG4gICAgfSBlbHNlIGlmIChzdHJbaV0gPT09ICddJykge1xuICAgICAgaWYgKHN0YXRlID09PSAnSU5fU1FVQVJFX0JSQUNLRVRTJykge1xuICAgICAgICBzdGF0ZSA9ICdJTU1FRElBVEVMWV9BRlRFUl9TUVVBUkVfQlJBQ0tFVFMnO1xuICAgICAgICByZXN1bHQucHVzaChjdXJQcm9wZXJ0eU5hbWUpO1xuICAgICAgICBjdXJQcm9wZXJ0eU5hbWUgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gJ0RFRkFVTFQnO1xuICAgICAgICBjdXJQcm9wZXJ0eU5hbWUgKz0gc3RyW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSAnLicpIHtcbiAgICAgIGlmIChzdGF0ZSAhPT0gJ0lNTUVESUFURUxZX0FGVEVSX1NRVUFSRV9CUkFDS0VUUycpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VyUHJvcGVydHlOYW1lKTtcbiAgICAgICAgY3VyUHJvcGVydHlOYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBzdGF0ZSA9ICdERUZBVUxUJztcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyUHJvcGVydHlOYW1lICs9IHN0cltpXTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUgIT09ICdJTU1FRElBVEVMWV9BRlRFUl9TUVVBUkVfQlJBQ0tFVFMnKSB7XG4gICAgcmVzdWx0LnB1c2goY3VyUHJvcGVydHlOYW1lKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59OyJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwic3RyaW5nVG9QYXJ0cyIsInN0ciIsInJlc3VsdCIsImN1clByb3BlcnR5TmFtZSIsInN0YXRlIiwiaSIsImxlbmd0aCIsInRlc3QiLCJzcGxpY2UiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mpath/lib/stringToParts.js\n");

/***/ })

};
;